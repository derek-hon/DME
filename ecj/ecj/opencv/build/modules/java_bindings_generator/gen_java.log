
Remapped configured files (3):
{'/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/misc/java/src/java/core+Core.jcode.in': '/home/derek/Documents/thesis-ecj/ecj/opencv/build/configured/modules/core/misc/java/src/java/core+Core.jcode',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java.in': '/home/derek/Documents/thesis-ecj/ecj/opencv/build/configured/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java.in': '/home/derek/Documents/thesis-ecj/ecj/opencv/build/configured/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java'}

=== MODULE: core (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core) ===


Files (4):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core/base.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core/utility.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/misc/java/src/cpp/core_manual.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Core : , name: Core, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core/base.hpp =====
Namespaces: ['cv', 'cv.Error', 'cv.cuda', 'cv.cudev', 'cv.ipp', 'cv.ogl']

--- Incoming ---
[   'enum cv.Error.Code',
    '',
    [],
    [   ['const cv.Error.StsOk', '0', [], [], None, ''],
        ['const cv.Error.StsBackTrace', '-1', [], [], None, ''],
        ['const cv.Error.StsError', '-2', [], [], None, ''],
        ['const cv.Error.StsInternal', '-3', [], [], None, ''],
        ['const cv.Error.StsNoMem', '-4', [], [], None, ''],
        ['const cv.Error.StsBadArg', '-5', [], [], None, ''],
        ['const cv.Error.StsBadFunc', '-6', [], [], None, ''],
        ['const cv.Error.StsNoConv', '-7', [], [], None, ''],
        ['const cv.Error.StsAutoTrace', '-8', [], [], None, ''],
        ['const cv.Error.HeaderIsNull', '-9', [], [], None, ''],
        ['const cv.Error.BadImageSize', '-10', [], [], None, ''],
        ['const cv.Error.BadOffset', '-11', [], [], None, ''],
        ['const cv.Error.BadDataPtr', '-12', [], [], None, ''],
        ['const cv.Error.BadStep', '-13', [], [], None, ''],
        ['const cv.Error.BadModelOrChSeq', '-14', [], [], None, ''],
        ['const cv.Error.BadNumChannels', '-15', [], [], None, ''],
        ['const cv.Error.BadNumChannel1U', '-16', [], [], None, ''],
        ['const cv.Error.BadDepth', '-17', [], [], None, ''],
        ['const cv.Error.BadAlphaChannel', '-18', [], [], None, ''],
        ['const cv.Error.BadOrder', '-19', [], [], None, ''],
        ['const cv.Error.BadOrigin', '-20', [], [], None, ''],
        ['const cv.Error.BadAlign', '-21', [], [], None, ''],
        ['const cv.Error.BadCallBack', '-22', [], [], None, ''],
        ['const cv.Error.BadTileSize', '-23', [], [], None, ''],
        ['const cv.Error.BadCOI', '-24', [], [], None, ''],
        ['const cv.Error.BadROISize', '-25', [], [], None, ''],
        ['const cv.Error.MaskIsTiled', '-26', [], [], None, ''],
        ['const cv.Error.StsNullPtr', '-27', [], [], None, ''],
        ['const cv.Error.StsVecLengthErr', '-28', [], [], None, ''],
        ['const cv.Error.StsFilterStructContentErr', '-29', [], [], None, ''],
        ['const cv.Error.StsKernelStructContentErr', '-30', [], [], None, ''],
        ['const cv.Error.StsFilterOffsetErr', '-31', [], [], None, ''],
        ['const cv.Error.StsBadSize', '-201', [], [], None, ''],
        ['const cv.Error.StsDivByZero', '-202', [], [], None, ''],
        ['const cv.Error.StsInplaceNotSupported', '-203', [], [], None, ''],
        ['const cv.Error.StsObjectNotFound', '-204', [], [], None, ''],
        ['const cv.Error.StsUnmatchedFormats', '-205', [], [], None, ''],
        ['const cv.Error.StsBadFlag', '-206', [], [], None, ''],
        ['const cv.Error.StsBadPoint', '-207', [], [], None, ''],
        ['const cv.Error.StsBadMask', '-208', [], [], None, ''],
        ['const cv.Error.StsUnmatchedSizes', '-209', [], [], None, ''],
        ['const cv.Error.StsUnsupportedFormat', '-210', [], [], None, ''],
        ['const cv.Error.StsOutOfRange', '-211', [], [], None, ''],
        ['const cv.Error.StsParseError', '-212', [], [], None, ''],
        ['const cv.Error.StsNotImplemented', '-213', [], [], None, ''],
        ['const cv.Error.StsBadMemBlock', '-214', [], [], None, ''],
        ['const cv.Error.StsAssert', '-215', [], [], None, ''],
        ['const cv.Error.GpuNotSupported', '-216', [], [], None, ''],
        ['const cv.Error.GpuApiCallError', '-217', [], [], None, ''],
        ['const cv.Error.OpenGlNotSupported', '-218', [], [], None, ''],
        ['const cv.Error.OpenGlApiCallError', '-219', [], [], None, ''],
        ['const cv.Error.OpenCLApiCallError', '-220', [], [], None, ''],
        ['const cv.Error.OpenCLDoubleNotSupported', '-221', [], [], None, ''],
        ['const cv.Error.OpenCLInitError', '-222', [], [], None, ''],
        ['const cv.Error.OpenCLNoAMDBlasFft', '-223', [], [], None, '']],
    None]
ok: CONST StsOk=0
ok: CONST StsBackTrace=-1
ok: CONST StsError=-2
ok: CONST StsInternal=-3
ok: CONST StsNoMem=-4
ok: CONST StsBadArg=-5
ok: CONST StsBadFunc=-6
ok: CONST StsNoConv=-7
ok: CONST StsAutoTrace=-8
ok: CONST HeaderIsNull=-9
ok: CONST BadImageSize=-10
ok: CONST BadOffset=-11
ok: CONST BadDataPtr=-12
ok: CONST BadStep=-13
ok: CONST BadModelOrChSeq=-14
ok: CONST BadNumChannels=-15
ok: CONST BadNumChannel1U=-16
ok: CONST BadDepth=-17
ok: CONST BadAlphaChannel=-18
ok: CONST BadOrder=-19
ok: CONST BadOrigin=-20
ok: CONST BadAlign=-21
ok: CONST BadCallBack=-22
ok: CONST BadTileSize=-23
ok: CONST BadCOI=-24
ok: CONST BadROISize=-25
ok: CONST MaskIsTiled=-26
ok: CONST StsNullPtr=-27
ok: CONST StsVecLengthErr=-28
ok: CONST StsFilterStructContentErr=-29
ok: CONST StsKernelStructContentErr=-30
ok: CONST StsFilterOffsetErr=-31
ok: CONST StsBadSize=-201
ok: CONST StsDivByZero=-202
ok: CONST StsInplaceNotSupported=-203
ok: CONST StsObjectNotFound=-204
ok: CONST StsUnmatchedFormats=-205
ok: CONST StsBadFlag=-206
ok: CONST StsBadPoint=-207
ok: CONST StsBadMask=-208
ok: CONST StsUnmatchedSizes=-209
ok: CONST StsUnsupportedFormat=-210
ok: CONST StsOutOfRange=-211
ok: CONST StsParseError=-212
ok: CONST StsNotImplemented=-213
ok: CONST StsBadMemBlock=-214
ok: CONST StsAssert=-215
ok: CONST GpuNotSupported=-216
ok: CONST GpuApiCallError=-217
ok: CONST OpenGlNotSupported=-218
ok: CONST OpenGlApiCallError=-219
ok: CONST OpenCLApiCallError=-220
ok: CONST OpenCLDoubleNotSupported=-221
ok: CONST OpenCLInitError=-222
ok: CONST OpenCLNoAMDBlasFft=-223

--- Incoming ---
[   'enum cv.DecompTypes',
    '',
    [],
    [   ['const cv.DECOMP_LU', '0', [], [], None, ''],
        ['const cv.DECOMP_SVD', '1', [], [], None, ''],
        ['const cv.DECOMP_EIG', '2', [], [], None, ''],
        ['const cv.DECOMP_CHOLESKY', '3', [], [], None, ''],
        ['const cv.DECOMP_QR', '4', [], [], None, ''],
        ['const cv.DECOMP_NORMAL', '16', [], [], None, '']],
    None]
ok: CONST DECOMP_LU=0
ok: CONST DECOMP_SVD=1
ok: CONST DECOMP_EIG=2
ok: CONST DECOMP_CHOLESKY=3
ok: CONST DECOMP_QR=4
ok: CONST DECOMP_NORMAL=16

--- Incoming ---
[   'enum cv.NormTypes',
    '',
    [],
    [   ['const cv.NORM_INF', '1', [], [], None, ''],
        ['const cv.NORM_L1', '2', [], [], None, ''],
        ['const cv.NORM_L2', '4', [], [], None, ''],
        ['const cv.NORM_L2SQR', '5', [], [], None, ''],
        ['const cv.NORM_HAMMING', '6', [], [], None, ''],
        ['const cv.NORM_HAMMING2', '7', [], [], None, ''],
        ['const cv.NORM_TYPE_MASK', '7', [], [], None, ''],
        ['const cv.NORM_RELATIVE', '8', [], [], None, ''],
        ['const cv.NORM_MINMAX', '32', [], [], None, '']],
    None]
ok: CONST NORM_INF=1
ok: CONST NORM_L1=2
ok: CONST NORM_L2=4
ok: CONST NORM_L2SQR=5
ok: CONST NORM_HAMMING=6
ok: CONST NORM_HAMMING2=7
ok: CONST NORM_TYPE_MASK=7
ok: CONST NORM_RELATIVE=8
ok: CONST NORM_MINMAX=32

--- Incoming ---
[   'enum cv.CmpTypes',
    '',
    [],
    [   ['const cv.CMP_EQ', '0', [], [], None, ''],
        ['const cv.CMP_GT', '1', [], [], None, ''],
        ['const cv.CMP_GE', '2', [], [], None, ''],
        ['const cv.CMP_LT', '3', [], [], None, ''],
        ['const cv.CMP_LE', '4', [], [], None, ''],
        ['const cv.CMP_NE', '5', [], [], None, '']],
    None]
ok: CONST CMP_EQ=0
ok: CONST CMP_GT=1
ok: CONST CMP_GE=2
ok: CONST CMP_LT=3
ok: CONST CMP_LE=4
ok: CONST CMP_NE=5

--- Incoming ---
[   'enum cv.GemmFlags',
    '',
    [],
    [   ['const cv.GEMM_1_T', '1', [], [], None, ''],
        ['const cv.GEMM_2_T', '2', [], [], None, ''],
        ['const cv.GEMM_3_T', '4', [], [], None, '']],
    None]
ok: CONST GEMM_1_T=1
ok: CONST GEMM_2_T=2
ok: CONST GEMM_3_T=4

--- Incoming ---
[   'enum cv.DftFlags',
    '',
    [],
    [   ['const cv.DFT_INVERSE', '1', [], [], None, ''],
        ['const cv.DFT_SCALE', '2', [], [], None, ''],
        ['const cv.DFT_ROWS', '4', [], [], None, ''],
        ['const cv.DFT_COMPLEX_OUTPUT', '16', [], [], None, ''],
        ['const cv.DFT_REAL_OUTPUT', '32', [], [], None, ''],
        ['const cv.DFT_COMPLEX_INPUT', '64', [], [], None, ''],
        ['const cv.DCT_INVERSE', 'DFT_INVERSE', [], [], None, ''],
        ['const cv.DCT_ROWS', 'DFT_ROWS', [], [], None, '']],
    None]
ok: CONST DFT_INVERSE=1
ok: CONST DFT_SCALE=2
ok: CONST DFT_ROWS=4
ok: CONST DFT_COMPLEX_OUTPUT=16
ok: CONST DFT_REAL_OUTPUT=32
ok: CONST DFT_COMPLEX_INPUT=64
ok: CONST DCT_INVERSE=DFT_INVERSE
ok: CONST DCT_ROWS=DFT_ROWS

--- Incoming ---
[   'enum cv.BorderTypes',
    '',
    [],
    [   ['const cv.BORDER_CONSTANT', '0', [], [], None, ''],
        ['const cv.BORDER_REPLICATE', '1', [], [], None, ''],
        ['const cv.BORDER_REFLECT', '2', [], [], None, ''],
        ['const cv.BORDER_WRAP', '3', [], [], None, ''],
        ['const cv.BORDER_REFLECT_101', '4', [], [], None, ''],
        ['const cv.BORDER_TRANSPARENT', '5', [], [], None, ''],
        ['const cv.BORDER_REFLECT101', 'BORDER_REFLECT_101', [], [], None, ''],
        ['const cv.BORDER_DEFAULT', 'BORDER_REFLECT_101', [], [], None, ''],
        ['const cv.BORDER_ISOLATED', '16', [], [], None, '']],
    None]
ok: CONST BORDER_CONSTANT=0
ok: CONST BORDER_REPLICATE=1
ok: CONST BORDER_REFLECT=2
ok: CONST BORDER_WRAP=3
ok: CONST BORDER_REFLECT_101=4
ok: CONST BORDER_TRANSPARENT=5
ok: CONST BORDER_REFLECT101=BORDER_REFLECT_101
ok: CONST BORDER_DEFAULT=BORDER_REFLECT_101
ok: CONST BORDER_ISOLATED=16

--- Incoming ---
['cv.cubeRoot', 'float', [], [['float', 'val', '', []]], 'float']
ok: FUNC <float cv..cubeRoot [ARG float val=]>

--- Incoming ---
[   'cv.fastAtan2',
    'float',
    [],
    [['float', 'y', '', []], ['float', 'x', '', []]],
    'float']
ok: FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>

--- Incoming ---
['cv.ipp.useIPP', 'bool', [], [], 'bool']
ok: FUNC <bool cv.ipp..useIPP []>

--- Incoming ---
['cv.ipp.setUseIPP', 'void', [], [['bool', 'flag', '', []]], 'void']
ok: FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>

--- Incoming ---
['cv.ipp.getIppVersion', 'String', [], [], 'String']
ok: FUNC <String cv.ipp..getIppVersion []>

--- Incoming ---
['cv.ipp.useIPP_NotExact', 'bool', [], [], 'bool']
ok: FUNC <bool cv.ipp..useIPP_NotExact []>

--- Incoming ---
['cv.ipp.setUseIPP_NotExact', 'void', [], [['bool', 'flag', '', []]], 'void']
ok: FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core.hpp =====
Namespaces: ['cv', 'cv.Error', 'cv.cuda', 'cv.cudev', 'cv.ipp', 'cv.ogl']

--- Incoming ---
[   'enum cv.SortFlags',
    '',
    [],
    [   ['const cv.SORT_EVERY_ROW', '0', [], [], None, ''],
        ['const cv.SORT_EVERY_COLUMN', '1', [], [], None, ''],
        ['const cv.SORT_ASCENDING', '0', [], [], None, ''],
        ['const cv.SORT_DESCENDING', '16', [], [], None, '']],
    None]
ok: CONST SORT_EVERY_ROW=0
ok: CONST SORT_EVERY_COLUMN=1
ok: CONST SORT_ASCENDING=0
ok: CONST SORT_DESCENDING=16

--- Incoming ---
[   'enum cv.CovarFlags',
    '',
    [],
    [   ['const cv.COVAR_SCRAMBLED', '0', [], [], None, ''],
        ['const cv.COVAR_NORMAL', '1', [], [], None, ''],
        ['const cv.COVAR_USE_AVG', '2', [], [], None, ''],
        ['const cv.COVAR_SCALE', '4', [], [], None, ''],
        ['const cv.COVAR_ROWS', '8', [], [], None, ''],
        ['const cv.COVAR_COLS', '16', [], [], None, '']],
    None]
ok: CONST COVAR_SCRAMBLED=0
ok: CONST COVAR_NORMAL=1
ok: CONST COVAR_USE_AVG=2
ok: CONST COVAR_SCALE=4
ok: CONST COVAR_ROWS=8
ok: CONST COVAR_COLS=16

--- Incoming ---
[   'enum cv.KmeansFlags',
    '',
    [],
    [   ['const cv.KMEANS_RANDOM_CENTERS', '0', [], [], None, ''],
        ['const cv.KMEANS_PP_CENTERS', '2', [], [], None, ''],
        ['const cv.KMEANS_USE_INITIAL_LABELS', '1', [], [], None, '']],
    None]
ok: CONST KMEANS_RANDOM_CENTERS=0
ok: CONST KMEANS_PP_CENTERS=2
ok: CONST KMEANS_USE_INITIAL_LABELS=1

--- Incoming ---
[   'enum cv.ReduceTypes',
    '',
    [],
    [   ['const cv.REDUCE_SUM', '0', [], [], None, ''],
        ['const cv.REDUCE_AVG', '1', [], [], None, ''],
        ['const cv.REDUCE_MAX', '2', [], [], None, ''],
        ['const cv.REDUCE_MIN', '3', [], [], None, '']],
    None]
manual: CONST REDUCE_SUM=0
manual: CONST REDUCE_AVG=1
manual: CONST REDUCE_MAX=2
manual: CONST REDUCE_MIN=3

--- Incoming ---
[   'cv.borderInterpolate',
    'int',
    [],
    [   ['int', 'p', '', []],
        ['int', 'len', '', []],
        ['int', 'borderType', '', []]],
    'int']
ok: FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>

--- Incoming ---
[   'cv.copyMakeBorder',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'top', '', []],
        ['int', 'bottom', '', []],
        ['int', 'left', '', []],
        ['int', 'right', '', []],
        ['int', 'borderType', '', []],
        ['Scalar', 'value', 'Scalar()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>

--- Incoming ---
[   'cv.add',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   'cv.subtract',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   'cv.multiply',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'scale', '1', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   'cv.divide',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'scale', '1', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   'cv.divide',
    'void',
    [],
    [   ['double', 'scale', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   'cv.scaleAdd',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['double', 'alpha', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.addWeighted',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['double', 'alpha', '', []],
        ['Mat', 'src2', '', []],
        ['double', 'beta', '', []],
        ['double', 'gamma', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   'cv.convertScaleAbs',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'alpha', '1', []],
        ['double', 'beta', '0', []]],
    'void']
ok: FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>

--- Incoming ---
[   'cv.convertFp16',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.LUT',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'lut', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>

--- Incoming ---
['cv.sum', 'Scalar', ['=sumElems'], [['Mat', 'src', '', []]], 'Scalar']
ok: FUNC <Scalar cv..sum [ARG Mat src=]>

--- Incoming ---
['cv.countNonZero', 'int', [], [['Mat', 'src', '', []]], 'int']
ok: FUNC <int cv..countNonZero [ARG Mat src=]>

--- Incoming ---
[   'cv.findNonZero',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'idx', '', ['/O']]],
    'void']
ok: FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>

--- Incoming ---
[   'cv.mean',
    'Scalar',
    [],
    [['Mat', 'src', '', []], ['Mat', 'mask', 'Mat()', []]],
    'Scalar']
ok: FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.meanStdDev',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mean', '', ['/O']],
        ['Mat', 'stddev', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.norm',
    'double',
    [],
    [   ['Mat', 'src1', '', []],
        ['int', 'normType', 'NORM_L2', []],
        ['Mat', 'mask', 'Mat()', []]],
    'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.norm',
    'double',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['int', 'normType', 'NORM_L2', []],
        ['Mat', 'mask', 'Mat()', []]],
    'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.PSNR',
    'double',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['double', 'R', '255.', []]],
    'double']
ok: FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>

--- Incoming ---
[   'cv.batchDistance',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dist', '', ['/O']],
        ['int', 'dtype', '', []],
        ['Mat', 'nidx', '', ['/O']],
        ['int', 'normType', 'NORM_L2', []],
        ['int', 'K', '0', []],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'update', '0', []],
        ['bool', 'crosscheck', 'false', []]],
    'void']
ok: FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>

--- Incoming ---
[   'cv.normalize',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['double', 'alpha', '1', []],
        ['double', 'beta', '0', []],
        ['int', 'norm_type', 'NORM_L2', []],
        ['int', 'dtype', '-1', []],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.minMaxLoc',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['double*', 'minVal', '', ['/O']],
        ['double*', 'maxVal', '0', ['/O']],
        ['Point*', 'minLoc', '0', ['/O']],
        ['Point*', 'maxLoc', '0', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
manual: FUNC <void cv..minMaxLoc [ARG Mat src=, ARG double * minVal=, ARG double * maxVal=0, ARG Point * minLoc=0, ARG Point * maxLoc=0, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.reduceArgMin',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'axis', '', []],
        ['bool', 'lastIndex', 'false', []]],
    'void']
ok: FUNC <void cv..reduceArgMin [ARG Mat src=, ARG Mat dst=, ARG int axis=, ARG bool lastIndex=false]>

--- Incoming ---
[   'cv.reduceArgMax',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'axis', '', []],
        ['bool', 'lastIndex', 'false', []]],
    'void']
ok: FUNC <void cv..reduceArgMax [ARG Mat src=, ARG Mat dst=, ARG int axis=, ARG bool lastIndex=false]>

--- Incoming ---
[   'cv.reduce',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dim', '', []],
        ['int', 'rtype', '', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>

--- Incoming ---
[   'cv.merge',
    'void',
    [],
    [['vector_Mat', 'mv', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>

--- Incoming ---
[   'cv.split',
    'void',
    [],
    [['Mat', 'm', '', []], ['vector_Mat', 'mv', '', ['/O']]],
    'void']
ok: FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>

--- Incoming ---
[   'cv.mixChannels',
    'void',
    [],
    [   ['vector_Mat', 'src', '', []],
        ['vector_Mat', 'dst', '', ['/IO']],
        ['vector_int', 'fromTo', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>

--- Incoming ---
[   'cv.extractChannel',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'coi', '', []]],
    'void']
ok: FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   'cv.insertChannel',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['int', 'coi', '', []]],
    'void']
ok: FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   'cv.flip',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flipCode', '', []]],
    'void']
ok: FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>

--- Incoming ---
[   'cv.flipND',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'axis', '', []]],
    'void']
ok: FUNC <void cv..flipND [ARG Mat src=, ARG Mat dst=, ARG int axis=]>

--- Incoming ---
[   'enum cv.RotateFlags',
    '',
    [],
    [   ['const cv.ROTATE_90_CLOCKWISE', '0', [], [], None, ''],
        ['const cv.ROTATE_180', '1', [], [], None, ''],
        ['const cv.ROTATE_90_COUNTERCLOCKWISE', '2', [], [], None, '']],
    None]
ok: CONST ROTATE_90_CLOCKWISE=0
ok: CONST ROTATE_180=1
ok: CONST ROTATE_90_COUNTERCLOCKWISE=2

--- Incoming ---
[   'cv.rotate',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'rotateCode', '', []]],
    'void']
ok: FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>

--- Incoming ---
[   'cv.repeat',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['int', 'ny', '', []],
        ['int', 'nx', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>

--- Incoming ---
[   'cv.hconcat',
    'void',
    [],
    [['vector_Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.vconcat',
    'void',
    [],
    [['vector_Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.bitwise_and',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.bitwise_or',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.bitwise_xor',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.bitwise_not',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.absdiff',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.copyTo',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', '', []]],
    'void']
ok: FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>

--- Incoming ---
[   'cv.inRange',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'lowerb', '', []],
        ['Mat', 'upperb', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>

--- Incoming ---
[   'cv.compare',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'cmpop', '', []]],
    'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   'cv.min',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.max',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.sqrt',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.pow',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['double', 'power', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>

--- Incoming ---
[   'cv.exp',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.log',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.polarToCart',
    'void',
    [],
    [   ['Mat', 'magnitude', '', []],
        ['Mat', 'angle', '', []],
        ['Mat', 'x', '', ['/O']],
        ['Mat', 'y', '', ['/O']],
        ['bool', 'angleInDegrees', 'false', []]],
    'void']
ok: FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   'cv.cartToPolar',
    'void',
    [],
    [   ['Mat', 'x', '', []],
        ['Mat', 'y', '', []],
        ['Mat', 'magnitude', '', ['/O']],
        ['Mat', 'angle', '', ['/O']],
        ['bool', 'angleInDegrees', 'false', []]],
    'void']
ok: FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   'cv.phase',
    'void',
    [],
    [   ['Mat', 'x', '', []],
        ['Mat', 'y', '', []],
        ['Mat', 'angle', '', ['/O']],
        ['bool', 'angleInDegrees', 'false', []]],
    'void']
ok: FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   'cv.magnitude',
    'void',
    [],
    [   ['Mat', 'x', '', []],
        ['Mat', 'y', '', []],
        ['Mat', 'magnitude', '', ['/O']]],
    'void']
ok: FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>

--- Incoming ---
[   'cv.checkRange',
    'bool',
    [],
    [   ['Mat', 'a', '', []],
        ['bool', 'quiet', 'true', []],
        ['Point*', 'pos', '0', ['/O']],
        ['double', 'minVal', '-DBL_MAX', []],
        ['double', 'maxVal', 'DBL_MAX', []]],
    'bool']
ok: FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>

--- Incoming ---
[   'cv.patchNaNs',
    'void',
    [],
    [['Mat', 'a', '', ['/IO']], ['double', 'val', '0', []]],
    'void']
ok: FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>

--- Incoming ---
[   'cv.gemm',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['double', 'alpha', '', []],
        ['Mat', 'src3', '', []],
        ['double', 'beta', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '0', []]],
    'void']
ok: FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   'cv.mulTransposed',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['bool', 'aTa', '', []],
        ['Mat', 'delta', 'Mat()', []],
        ['double', 'scale', '1', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   'cv.transpose',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.transposeND',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['vector_int', 'order', '', ['/C', '/Ref']],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..transposeND [ARG Mat src=, ARG vector_int order=, ARG Mat dst=]>

--- Incoming ---
[   'cv.transform',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']], ['Mat', 'm', '', []]],
    'void']
ok: FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   'cv.perspectiveTransform',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']], ['Mat', 'm', '', []]],
    'void']
ok: FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   'cv.completeSymm',
    'void',
    [],
    [['Mat', 'm', '', ['/IO']], ['bool', 'lowerToUpper', 'false', []]],
    'void']
ok: FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>

--- Incoming ---
[   'cv.setIdentity',
    'void',
    [],
    [['Mat', 'mtx', '', ['/IO']], ['Scalar', 's', 'Scalar(1)', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>

--- Incoming ---
['cv.determinant', 'double', [], [['Mat', 'mtx', '', []]], 'double']
ok: FUNC <double cv..determinant [ARG Mat mtx=]>

--- Incoming ---
['cv.trace', 'Scalar', [], [['Mat', 'mtx', '', []]], 'Scalar']
ok: FUNC <Scalar cv..trace [ARG Mat mtx=]>

--- Incoming ---
[   'cv.invert',
    'double',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', 'DECOMP_LU', []]],
    'double']
ok: FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   'cv.solve',
    'bool',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', 'DECOMP_LU', []]],
    'bool']
ok: FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   'cv.sort',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   'cv.sortIdx',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   'cv.solveCubic',
    'int',
    [],
    [['Mat', 'coeffs', '', []], ['Mat', 'roots', '', ['/O']]],
    'int']
ok: FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>

--- Incoming ---
[   'cv.solvePoly',
    'double',
    [],
    [   ['Mat', 'coeffs', '', []],
        ['Mat', 'roots', '', ['/O']],
        ['int', 'maxIters', '300', []]],
    'double']
ok: FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>

--- Incoming ---
[   'cv.eigen',
    'bool',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'eigenvalues', '', ['/O']],
        ['Mat', 'eigenvectors', 'Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>

--- Incoming ---
[   'cv.eigenNonSymmetric',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'eigenvalues', '', ['/O']],
        ['Mat', 'eigenvectors', '', ['/O']]],
    'void']
ok: FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>

--- Incoming ---
[   'cv.calcCovarMatrix',
    'void',
    [],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'covar', '', ['/O']],
        ['Mat', 'mean', '', ['/IO']],
        ['int', 'flags', '', []],
        ['int', 'ctype', 'CV_64F', []]],
    'void']
ok: FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>

--- Incoming ---
[   'cv.PCACompute',
    'void',
    [],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', ['/IO']],
        ['Mat', 'eigenvectors', '', ['/O']],
        ['int', 'maxComponents', '0', []]],
    'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>

--- Incoming ---
[   'cv.PCACompute',
    'void',
    ['=PCACompute2'],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', ['/IO']],
        ['Mat', 'eigenvectors', '', ['/O']],
        ['Mat', 'eigenvalues', '', ['/O']],
        ['int', 'maxComponents', '0', []]],
    'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>

--- Incoming ---
[   'cv.PCACompute',
    'void',
    [],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', ['/IO']],
        ['Mat', 'eigenvectors', '', ['/O']],
        ['double', 'retainedVariance', '', []]],
    'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>

--- Incoming ---
[   'cv.PCACompute',
    'void',
    ['=PCACompute2'],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', ['/IO']],
        ['Mat', 'eigenvectors', '', ['/O']],
        ['Mat', 'eigenvalues', '', ['/O']],
        ['double', 'retainedVariance', '', []]],
    'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>

--- Incoming ---
[   'cv.PCAProject',
    'void',
    [],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', []],
        ['Mat', 'eigenvectors', '', []],
        ['Mat', 'result', '', ['/O']]],
    'void']
ok: FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   'cv.PCABackProject',
    'void',
    [],
    [   ['Mat', 'data', '', []],
        ['Mat', 'mean', '', []],
        ['Mat', 'eigenvectors', '', []],
        ['Mat', 'result', '', ['/O']]],
    'void']
ok: FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   'cv.SVDecomp',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'w', '', ['/O']],
        ['Mat', 'u', '', ['/O']],
        ['Mat', 'vt', '', ['/O']],
        ['int', 'flags', '0', []]],
    'void']
ok: FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>

--- Incoming ---
[   'cv.SVBackSubst',
    'void',
    [],
    [   ['Mat', 'w', '', []],
        ['Mat', 'u', '', []],
        ['Mat', 'vt', '', []],
        ['Mat', 'rhs', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>

--- Incoming ---
[   'cv.Mahalanobis',
    'double',
    [],
    [['Mat', 'v1', '', []], ['Mat', 'v2', '', []], ['Mat', 'icovar', '', []]],
    'double']
ok: FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>

--- Incoming ---
[   'cv.dft',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '0', []],
        ['int', 'nonzeroRows', '0', []]],
    'void']
ok: FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   'cv.idft',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '0', []],
        ['int', 'nonzeroRows', '0', []]],
    'void']
ok: FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   'cv.dct',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '0', []]],
    'void']
ok: FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   'cv.idct',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '0', []]],
    'void']
ok: FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   'cv.mulSpectrums',
    'void',
    [],
    [   ['Mat', 'a', '', []],
        ['Mat', 'b', '', []],
        ['Mat', 'c', '', ['/O']],
        ['int', 'flags', '', []],
        ['bool', 'conjB', 'false', []]],
    'void']
ok: FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>

--- Incoming ---
['cv.getOptimalDFTSize', 'int', [], [['int', 'vecsize', '', []]], 'int']
ok: FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>

--- Incoming ---
['cv.setRNGSeed', 'void', [], [['int', 'seed', '', []]], 'void']
ok: FUNC <void cv..setRNGSeed [ARG int seed=]>

--- Incoming ---
[   'cv.randu',
    'void',
    [],
    [   ['Mat', 'dst', '', ['/IO']],
        ['Mat', 'low', '', []],
        ['Mat', 'high', '', []]],
    'void']
ok: FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>

--- Incoming ---
[   'cv.randn',
    'void',
    [],
    [   ['Mat', 'dst', '', ['/IO']],
        ['Mat', 'mean', '', []],
        ['Mat', 'stddev', '', []]],
    'void']
ok: FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>

--- Incoming ---
[   'cv.randShuffle',
    'void',
    [],
    [   ['Mat', 'dst', '', ['/IO']],
        ['double', 'iterFactor', '1.', []],
        ['RNG*', 'rng', '0', []]],
    'void']
ok: FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>

--- Incoming ---
[   'enum cv.PCA.Flags',
    '',
    [],
    [   ['const cv.PCA.DATA_AS_ROW', '0', [], [], None, ''],
        ['const cv.PCA.DATA_AS_COL', '1', [], [], None, ''],
        ['const cv.PCA.USE_AVG', '2', [], [], None, '']],
    None]
class not found: CONST DATA_AS_ROW=0
ok: CONST PCA_DATA_AS_ROW=0
class not found: CONST DATA_AS_COL=1
ok: CONST PCA_DATA_AS_COL=1
class not found: CONST USE_AVG=2
ok: CONST PCA_USE_AVG=2

--- Incoming ---
[   'enum cv.SVD.Flags',
    '',
    [],
    [   ['const cv.SVD.MODIFY_A', '1', [], [], None, ''],
        ['const cv.SVD.NO_UV', '2', [], [], None, ''],
        ['const cv.SVD.FULL_UV', '4', [], [], None, '']],
    None]
class not found: CONST MODIFY_A=1
manual: CONST SVD_MODIFY_A=1
class not found: CONST NO_UV=2
manual: CONST SVD_NO_UV=2
class not found: CONST FULL_UV=4
manual: CONST SVD_FULL_UV=4

--- Incoming ---
[   'enum cv.RNG.<unnamed>',
    '',
    [],
    [   ['const cv.RNG.UNIFORM', '0', [], [], None, ''],
        ['const cv.RNG.NORMAL', '1', [], [], None, '']],
    None]
class not found: CONST UNIFORM=0
ok: CONST RNG_UNIFORM=0
class not found: CONST NORMAL=1
ok: CONST RNG_NORMAL=1

--- Incoming ---
[   'cv.kmeans',
    'double',
    [],
    [   ['Mat', 'data', '', []],
        ['int', 'K', '', []],
        ['Mat', 'bestLabels', '', ['/IO']],
        ['TermCriteria', 'criteria', '', []],
        ['int', 'attempts', '', []],
        ['int', 'flags', '', []],
        ['Mat', 'centers', 'Mat()', ['/O']]],
    'double']
ok: FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>

--- Incoming ---
[   'enum cv.Formatter.FormatType',
    '',
    [],
    [   ['const cv.Formatter.FMT_DEFAULT', '0', [], [], None, ''],
        ['const cv.Formatter.FMT_MATLAB', '1', [], [], None, ''],
        ['const cv.Formatter.FMT_CSV', '2', [], [], None, ''],
        ['const cv.Formatter.FMT_PYTHON', '3', [], [], None, ''],
        ['const cv.Formatter.FMT_NUMPY', '4', [], [], None, ''],
        ['const cv.Formatter.FMT_C', '5', [], [], None, '']],
    None]
class not found: CONST FMT_DEFAULT=0
ok: CONST Formatter_FMT_DEFAULT=0
class not found: CONST FMT_MATLAB=1
ok: CONST Formatter_FMT_MATLAB=1
class not found: CONST FMT_CSV=2
ok: CONST Formatter_FMT_CSV=2
class not found: CONST FMT_PYTHON=3
ok: CONST Formatter_FMT_PYTHON=3
class not found: CONST FMT_NUMPY=4
ok: CONST Formatter_FMT_NUMPY=4
class not found: CONST FMT_C=5
ok: CONST Formatter_FMT_C=5

--- Incoming ---
['class cv.Algorithm', '', [], [], None]
duplicated: CLASS cv::.Algorithm : 

--- Incoming ---
['cv.Algorithm.clear', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.Algorithm.clear []>

--- Incoming ---
[   'cv.Algorithm.write',
    'void',
    ['/C', '/V'],
    [['FileStorage', 'fs', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.Algorithm.write [ARG FileStorage fs=]>

--- Incoming ---
[   'cv.Algorithm.write',
    'void',
    ['/C'],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Algorithm.write [ARG FileStorage fs=, ARG String name=]>

--- Incoming ---
[   'cv.Algorithm.read',
    'void',
    ['/V'],
    [['FileNode', 'fn', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Algorithm.read [ARG FileNode fn=]>

--- Incoming ---
['cv.Algorithm.empty', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.Algorithm.empty []>

--- Incoming ---
[   'cv.Algorithm.save',
    'void',
    ['/C', '/V'],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Algorithm.save [ARG String filename=]>

--- Incoming ---
['cv.Algorithm.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.Algorithm.getDefaultName []>

--- Incoming ---
[   'enum struct cv.Param',
    '',
    [],
    [   ['const cv.Param.INT', '0', [], [], None, ''],
        ['const cv.Param.BOOLEAN', '1', [], [], None, ''],
        ['const cv.Param.REAL', '2', [], [], None, ''],
        ['const cv.Param.STRING', '3', [], [], None, ''],
        ['const cv.Param.MAT', '4', [], [], None, ''],
        ['const cv.Param.MAT_VECTOR', '5', [], [], None, ''],
        ['const cv.Param.ALGORITHM', '6', [], [], None, ''],
        ['const cv.Param.FLOAT', '7', [], [], None, ''],
        ['const cv.Param.UNSIGNED_INT', '8', [], [], None, ''],
        ['const cv.Param.UINT64', '9', [], [], None, ''],
        ['const cv.Param.UCHAR', '11', [], [], None, ''],
        ['const cv.Param.SCALAR', '12', [], [], None, '']],
    None]
class not found: CONST INT=0
ok: CONST Param_INT=0
class not found: CONST BOOLEAN=1
ok: CONST Param_BOOLEAN=1
class not found: CONST REAL=2
ok: CONST Param_REAL=2
class not found: CONST STRING=3
ok: CONST Param_STRING=3
class not found: CONST MAT=4
ok: CONST Param_MAT=4
class not found: CONST MAT_VECTOR=5
ok: CONST Param_MAT_VECTOR=5
class not found: CONST ALGORITHM=6
ok: CONST Param_ALGORITHM=6
class not found: CONST FLOAT=7
ok: CONST Param_FLOAT=7
class not found: CONST UNSIGNED_INT=8
ok: CONST Param_UNSIGNED_INT=8
class not found: CONST UINT64=9
ok: CONST Param_UINT64=9
class not found: CONST UCHAR=11
ok: CONST Param_UCHAR=11
class not found: CONST SCALAR=12
ok: CONST Param_SCALAR=12


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/include/opencv2/core/utility.hpp =====
Namespaces: ['cv', 'cv.Error', 'cv.cuda', 'cv.cudev', 'cv.ipp', 'cv.ogl', 'cv.samples', 'cv.utils']

--- Incoming ---
['cv.setNumThreads', 'void', [], [['int', 'nthreads', '', []]], 'void']
ok: FUNC <void cv..setNumThreads [ARG int nthreads=]>

--- Incoming ---
['cv.getNumThreads', 'int', [], [], 'int']
ok: FUNC <int cv..getNumThreads []>

--- Incoming ---
['cv.getThreadNum', 'int', [], [], 'int']
ok: FUNC <int cv..getThreadNum []>

--- Incoming ---
['cv.getBuildInformation', 'String', [], [], 'String']
ok: FUNC <String cv..getBuildInformation []>

--- Incoming ---
['cv.getVersionString', 'String', [], [], 'String']
ok: FUNC <String cv..getVersionString []>

--- Incoming ---
['cv.getVersionMajor', 'int', [], [], 'int']
ok: FUNC <int cv..getVersionMajor []>

--- Incoming ---
['cv.getVersionMinor', 'int', [], [], 'int']
ok: FUNC <int cv..getVersionMinor []>

--- Incoming ---
['cv.getVersionRevision', 'int', [], [], 'int']
ok: FUNC <int cv..getVersionRevision []>

--- Incoming ---
['cv.getTickCount', 'int64', [], [], 'int64']
ok: FUNC <int64 cv..getTickCount []>

--- Incoming ---
['cv.getTickFrequency', 'double', [], [], 'double']
ok: FUNC <double cv..getTickFrequency []>

--- Incoming ---
['class cv.TickMeter', '', [], [], None]
ok: class CLASS cv::.TickMeter : , name: TickMeter, base: 

--- Incoming ---
['cv.TickMeter.TickMeter', '', [], [], None]
ok: FUNC < cv.TickMeter.TickMeter []>

--- Incoming ---
['cv.TickMeter.start', 'void', [], [], 'void']
ok: FUNC <void cv.TickMeter.start []>

--- Incoming ---
['cv.TickMeter.stop', 'void', [], [], 'void']
ok: FUNC <void cv.TickMeter.stop []>

--- Incoming ---
['cv.TickMeter.getTimeTicks', 'int64', ['/C'], [], 'int64']
ok: FUNC <int64 cv.TickMeter.getTimeTicks []>

--- Incoming ---
['cv.TickMeter.getTimeMicro', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getTimeMicro []>

--- Incoming ---
['cv.TickMeter.getTimeMilli', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getTimeMilli []>

--- Incoming ---
['cv.TickMeter.getTimeSec', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getTimeSec []>

--- Incoming ---
['cv.TickMeter.getCounter', 'int64', ['/C'], [], 'int64']
ok: FUNC <int64 cv.TickMeter.getCounter []>

--- Incoming ---
['cv.TickMeter.getFPS', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getFPS []>

--- Incoming ---
['cv.TickMeter.getAvgTimeSec', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getAvgTimeSec []>

--- Incoming ---
['cv.TickMeter.getAvgTimeMilli', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.TickMeter.getAvgTimeMilli []>

--- Incoming ---
['cv.TickMeter.reset', 'void', [], [], 'void']
ok: FUNC <void cv.TickMeter.reset []>

--- Incoming ---
['cv.getCPUTickCount', 'int64', [], [], 'int64']
ok: FUNC <int64 cv..getCPUTickCount []>

--- Incoming ---
['cv.checkHardwareSupport', 'bool', [], [['int', 'feature', '', []]], 'bool']
manual: FUNC <bool cv..checkHardwareSupport [ARG int feature=]>

--- Incoming ---
[   'cv.getHardwareFeatureName',
    'String',
    [],
    [['int', 'feature', '', []]],
    'String']
ok: FUNC <String cv..getHardwareFeatureName [ARG int feature=]>

--- Incoming ---
['cv.getCPUFeaturesLine', 'string', [], [], 'std::string']
ok: FUNC <string cv..getCPUFeaturesLine []>

--- Incoming ---
['cv.getNumberOfCPUs', 'int', [], [], 'int']
ok: FUNC <int cv..getNumberOfCPUs []>

--- Incoming ---
['cv.setUseOptimized', 'void', [], [['bool', 'onoff', '', []]], 'void']
manual: FUNC <void cv..setUseOptimized [ARG bool onoff=]>

--- Incoming ---
['cv.useOptimized', 'bool', [], [], 'bool']
manual: FUNC <bool cv..useOptimized []>

--- Incoming ---
[   'cv.samples.findFile',
    'String',
    [],
    [   ['String', 'relative_path', '', ['/C', '/Ref']],
        ['bool', 'required', 'true', []],
        ['bool', 'silentMode', 'false', []]],
    'cv::String']
ok: FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>

--- Incoming ---
[   'cv.samples.findFileOrKeep',
    'String',
    [],
    [   ['String', 'relative_path', '', ['/C', '/Ref']],
        ['bool', 'silentMode', 'false', []]],
    'cv::String']
ok: FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>

--- Incoming ---
[   'cv.samples.addSamplesDataSearchPath',
    'void',
    [],
    [['String', 'path', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>

--- Incoming ---
[   'cv.samples.addSamplesDataSearchSubDirectory',
    'void',
    [],
    [['String', 'subdir', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/core/misc/java/src/cpp/core_manual.hpp =====
Namespaces: ['cv', 'cv.Error', 'cv.cuda', 'cv.cudev', 'cv.ipp', 'cv.ogl', 'cv.samples', 'cv.utils']

--- Incoming ---
['cv.setErrorVerbosity', 'void', [], [['bool', 'verbose', '', []]], 'void']
ok: FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>

--- Incoming ---
[   'cv.add',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   'cv.subtract',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   'cv.multiply',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'scale', '1', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   'cv.divide',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'scale', '1', []],
        ['int', 'dtype', '-1', []]],
    'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   'cv.absdiff',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.compare',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'cmpop', '', []]],
    'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   'cv.min',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.max',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Scalar', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>


===== Generating... =====
CLASS cv::.Algorithm : 
FUNC <void cv.Algorithm.clear []>
java: void clear()
FUNC <void cv.Algorithm.write [ARG FileStorage fs=]>
SKIP:void cv::Algorithm::write(FileStorage fs)	 due to ARG type FileStorage/I
FUNC <void cv.Algorithm.write [ARG FileStorage fs=, ARG String name=]>
SKIP:void cv::Algorithm::write(FileStorage fs, String name)	 due to ARG type FileStorage/I
FUNC <void cv.Algorithm.read [ARG FileNode fn=]>
SKIP:void cv::Algorithm::read(FileNode fn)	 due to ARG type FileNode/I
FUNC <bool cv.Algorithm.empty []>
java: boolean empty()
FUNC <void cv.Algorithm.save [ARG String filename=]>
java: void save(String filename)
FUNC <String cv.Algorithm.getDefaultName []>
java: String getDefaultName()
CLASS cv::.Core : 
[CONST CV_8U=0(manual), CONST CV_8S=1(manual), CONST CV_16U=2(manual), CONST CV_16S=3(manual), CONST CV_32S=4(manual), CONST CV_32F=5(manual), CONST CV_64F=6(manual), CONST CV_USRTYPE1=7(manual)]
[CONST SVD_MODIFY_A=1(manual), CONST SVD_NO_UV=2(manual), CONST SVD_FULL_UV=4(manual), CONST FILLED=-1(manual), CONST REDUCE_SUM=0(manual), CONST REDUCE_AVG=1(manual), CONST REDUCE_MAX=2(manual), CONST REDUCE_MIN=3(manual), CONST RNG_UNIFORM=0, CONST RNG_NORMAL=1]
[CONST BORDER_CONSTANT=0, CONST BORDER_REPLICATE=1, CONST BORDER_REFLECT=2, CONST BORDER_WRAP=3, CONST BORDER_REFLECT_101=4, CONST BORDER_TRANSPARENT=5, CONST BORDER_REFLECT101=BORDER_REFLECT_101, CONST BORDER_DEFAULT=BORDER_REFLECT_101, CONST BORDER_ISOLATED=16]
[CONST CMP_EQ=0, CONST CMP_GT=1, CONST CMP_GE=2, CONST CMP_LT=3, CONST CMP_LE=4, CONST CMP_NE=5]
[CONST COVAR_SCRAMBLED=0, CONST COVAR_NORMAL=1, CONST COVAR_USE_AVG=2, CONST COVAR_SCALE=4, CONST COVAR_ROWS=8, CONST COVAR_COLS=16]
[CONST DECOMP_LU=0, CONST DECOMP_SVD=1, CONST DECOMP_EIG=2, CONST DECOMP_CHOLESKY=3, CONST DECOMP_QR=4, CONST DECOMP_NORMAL=16]
[CONST DFT_INVERSE=1, CONST DFT_SCALE=2, CONST DFT_ROWS=4, CONST DFT_COMPLEX_OUTPUT=16, CONST DFT_REAL_OUTPUT=32, CONST DFT_COMPLEX_INPUT=64, CONST DCT_INVERSE=DFT_INVERSE, CONST DCT_ROWS=DFT_ROWS]
[CONST StsOk=0, CONST StsBackTrace=-1, CONST StsError=-2, CONST StsInternal=-3, CONST StsNoMem=-4, CONST StsBadArg=-5, CONST StsBadFunc=-6, CONST StsNoConv=-7, CONST StsAutoTrace=-8, CONST HeaderIsNull=-9, CONST BadImageSize=-10, CONST BadOffset=-11, CONST BadDataPtr=-12, CONST BadStep=-13, CONST BadModelOrChSeq=-14, CONST BadNumChannels=-15, CONST BadNumChannel1U=-16, CONST BadDepth=-17, CONST BadAlphaChannel=-18, CONST BadOrder=-19, CONST BadOrigin=-20, CONST BadAlign=-21, CONST BadCallBack=-22, CONST BadTileSize=-23, CONST BadCOI=-24, CONST BadROISize=-25, CONST MaskIsTiled=-26, CONST StsNullPtr=-27, CONST StsVecLengthErr=-28, CONST StsFilterStructContentErr=-29, CONST StsKernelStructContentErr=-30, CONST StsFilterOffsetErr=-31, CONST StsBadSize=-201, CONST StsDivByZero=-202, CONST StsInplaceNotSupported=-203, CONST StsObjectNotFound=-204, CONST StsUnmatchedFormats=-205, CONST StsBadFlag=-206, CONST StsBadPoint=-207, CONST StsBadMask=-208, CONST StsUnmatchedSizes=-209, CONST StsUnsupportedFormat=-210, CONST StsOutOfRange=-211, CONST StsParseError=-212, CONST StsNotImplemented=-213, CONST StsBadMemBlock=-214, CONST StsAssert=-215, CONST GpuNotSupported=-216, CONST GpuApiCallError=-217, CONST OpenGlNotSupported=-218, CONST OpenGlApiCallError=-219, CONST OpenCLApiCallError=-220, CONST OpenCLDoubleNotSupported=-221, CONST OpenCLInitError=-222, CONST OpenCLNoAMDBlasFft=-223]
[CONST Formatter_FMT_DEFAULT=0, CONST Formatter_FMT_MATLAB=1, CONST Formatter_FMT_CSV=2, CONST Formatter_FMT_PYTHON=3, CONST Formatter_FMT_NUMPY=4, CONST Formatter_FMT_C=5]
[CONST GEMM_1_T=1, CONST GEMM_2_T=2, CONST GEMM_3_T=4]
[CONST KMEANS_RANDOM_CENTERS=0, CONST KMEANS_PP_CENTERS=2, CONST KMEANS_USE_INITIAL_LABELS=1]
[CONST NORM_INF=1, CONST NORM_L1=2, CONST NORM_L2=4, CONST NORM_L2SQR=5, CONST NORM_HAMMING=6, CONST NORM_HAMMING2=7, CONST NORM_TYPE_MASK=7, CONST NORM_RELATIVE=8, CONST NORM_MINMAX=32]
[CONST PCA_DATA_AS_ROW=0, CONST PCA_DATA_AS_COL=1, CONST PCA_USE_AVG=2]
[CONST Param_INT=0, CONST Param_BOOLEAN=1, CONST Param_REAL=2, CONST Param_STRING=3, CONST Param_MAT=4, CONST Param_MAT_VECTOR=5, CONST Param_ALGORITHM=6, CONST Param_FLOAT=7, CONST Param_UNSIGNED_INT=8, CONST Param_UINT64=9, CONST Param_UCHAR=11, CONST Param_SCALAR=12]
[CONST ROTATE_90_CLOCKWISE=0, CONST ROTATE_180=1, CONST ROTATE_90_COUNTERCLOCKWISE=2]
[CONST SORT_EVERY_ROW=0, CONST SORT_EVERY_COLUMN=1, CONST SORT_ASCENDING=0, CONST SORT_DESCENDING=16]
FUNC <float cv..cubeRoot [ARG float val=]>
java: float cubeRoot(float val)
FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>
java: float fastAtan2(float y, float x)
FUNC <bool cv.ipp..useIPP []>
java: boolean useIPP()
FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>
java: void setUseIPP(boolean flag)
FUNC <String cv.ipp..getIppVersion []>
java: String getIppVersion()
FUNC <bool cv.ipp..useIPP_NotExact []>
java: boolean useIPP_NotExact()
FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>
java: void setUseIPP_NotExact(boolean flag)
FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>
java: int borderInterpolate(int p, int len, int borderType)
FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType, Scalar value)
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType)
FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Mat src2, Mat dst, Mat mask)
java: void add(Mat src1, Mat src2, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Mat src2, Mat dst)
FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Mat src2, Mat dst, double scale)
java: void multiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Mat src2, Mat dst, double scale)
java: void divide(Mat src1, Mat src2, Mat dst)
FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>
java: void divide(double scale, Mat src2, Mat dst, int dtype)
java: void divide(double scale, Mat src2, Mat dst)
FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>
java: void scaleAdd(Mat src1, double alpha, Mat src2, Mat dst)
FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst, int dtype)
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst)
FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>
java: void convertScaleAbs(Mat src, Mat dst, double alpha, double beta)
java: void convertScaleAbs(Mat src, Mat dst, double alpha)
java: void convertScaleAbs(Mat src, Mat dst)
FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>
java: void convertFp16(Mat src, Mat dst)
FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>
java: void LUT(Mat src, Mat lut, Mat dst)
FUNC <Scalar cv..sum [ARG Mat src=]>
java: Scalar sumElems(Mat src)
FUNC <int cv..countNonZero [ARG Mat src=]>
java: int countNonZero(Mat src)
FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>
java: void findNonZero(Mat src, Mat idx)
FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>
java: Scalar mean(Mat src, Mat mask)
java: Scalar mean(Mat src)
FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev, Mat mask)
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev)
FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, int normType, Mat mask)
java: double norm(Mat src1, int normType)
java: double norm(Mat src1)
FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, Mat src2, int normType, Mat mask)
java: double norm(Mat src1, Mat src2, int normType)
java: double norm(Mat src1, Mat src2)
FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>
java: double PSNR(Mat src1, Mat src2, double R)
java: double PSNR(Mat src1, Mat src2)
FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update, boolean crosscheck)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx)
FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype, Mat mask)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type)
java: void normalize(Mat src, Mat dst, double alpha, double beta)
java: void normalize(Mat src, Mat dst, double alpha)
java: void normalize(Mat src, Mat dst)
FUNC <void cv..reduceArgMin [ARG Mat src=, ARG Mat dst=, ARG int axis=, ARG bool lastIndex=false]>
java: void reduceArgMin(Mat src, Mat dst, int axis, boolean lastIndex)
java: void reduceArgMin(Mat src, Mat dst, int axis)
FUNC <void cv..reduceArgMax [ARG Mat src=, ARG Mat dst=, ARG int axis=, ARG bool lastIndex=false]>
java: void reduceArgMax(Mat src, Mat dst, int axis, boolean lastIndex)
java: void reduceArgMax(Mat src, Mat dst, int axis)
FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>
java: void reduce(Mat src, Mat dst, int dim, int rtype, int dtype)
java: void reduce(Mat src, Mat dst, int dim, int rtype)
FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>
java: void merge(List<Mat> mv, Mat dst)
FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>
java: void split(Mat m, List<Mat> mv)
FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>
java: void mixChannels(List<Mat> src, List<Mat> dst, MatOfInt fromTo)
FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void extractChannel(Mat src, Mat dst, int coi)
FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void insertChannel(Mat src, Mat dst, int coi)
FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>
java: void flip(Mat src, Mat dst, int flipCode)
FUNC <void cv..flipND [ARG Mat src=, ARG Mat dst=, ARG int axis=]>
java: void flipND(Mat src, Mat dst, int axis)
FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>
java: void rotate(Mat src, Mat dst, int rotateCode)
FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>
java: void repeat(Mat src, int ny, int nx, Mat dst)
FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void hconcat(List<Mat> src, Mat dst)
FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void vconcat(List<Mat> src, Mat dst)
FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_and(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_and(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_or(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_or(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_xor(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_xor(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_not(Mat src, Mat dst, Mat mask)
java: void bitwise_not(Mat src, Mat dst)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Mat src2, Mat dst)
FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>
java: void copyTo(Mat src, Mat dst, Mat mask)
FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>
java: void inRange(Mat src, Scalar lowerb, Scalar upperb, Mat dst)
FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Mat src2, Mat dst, int cmpop)
FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void min(Mat src1, Mat src2, Mat dst)
FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void max(Mat src1, Mat src2, Mat dst)
FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>
java: void sqrt(Mat src, Mat dst)
FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>
java: void pow(Mat src, double power, Mat dst)
FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>
java: void exp(Mat src, Mat dst)
FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>
java: void log(Mat src, Mat dst)
FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y, boolean angleInDegrees)
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y)
FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle, boolean angleInDegrees)
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle)
FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void phase(Mat x, Mat y, Mat angle, boolean angleInDegrees)
java: void phase(Mat x, Mat y, Mat angle)
FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>
java: void magnitude(Mat x, Mat y, Mat magnitude)
FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>
java: boolean checkRange(Mat a, boolean quiet, double minVal, double maxVal)
java: boolean checkRange(Mat a, boolean quiet, double minVal)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a)
FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>
java: void patchNaNs(Mat a, double val)
java: void patchNaNs(Mat a)
FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst, int flags)
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst)
FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale, int dtype)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta)
java: void mulTransposed(Mat src, Mat dst, boolean aTa)
FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>
java: void transpose(Mat src, Mat dst)
FUNC <void cv..transposeND [ARG Mat src=, ARG vector_int order=, ARG Mat dst=]>
java: void transposeND(Mat src, MatOfInt order, Mat dst)
FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void transform(Mat src, Mat dst, Mat m)
FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void perspectiveTransform(Mat src, Mat dst, Mat m)
FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>
java: void completeSymm(Mat m, boolean lowerToUpper)
java: void completeSymm(Mat m)
FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>
java: void setIdentity(Mat mtx, Scalar s)
java: void setIdentity(Mat mtx)
FUNC <double cv..determinant [ARG Mat mtx=]>
java: double determinant(Mat mtx)
FUNC <Scalar cv..trace [ARG Mat mtx=]>
java: Scalar trace(Mat mtx)
FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: double invert(Mat src, Mat dst, int flags)
java: double invert(Mat src, Mat dst)
FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: boolean solve(Mat src1, Mat src2, Mat dst, int flags)
java: boolean solve(Mat src1, Mat src2, Mat dst)
FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sort(Mat src, Mat dst, int flags)
FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sortIdx(Mat src, Mat dst, int flags)
FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>
java: int solveCubic(Mat coeffs, Mat roots)
FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>
java: double solvePoly(Mat coeffs, Mat roots, int maxIters)
java: double solvePoly(Mat coeffs, Mat roots)
FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>
java: boolean eigen(Mat src, Mat eigenvalues, Mat eigenvectors)
java: boolean eigen(Mat src, Mat eigenvalues)
FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>
java: void eigenNonSymmetric(Mat src, Mat eigenvalues, Mat eigenvectors)
FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags, int ctype)
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, int maxComponents)
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, int maxComponents)
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, double retainedVariance)
FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCAProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCABackProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt, int flags)
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt)
FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>
java: void SVBackSubst(Mat w, Mat u, Mat vt, Mat rhs, Mat dst)
FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>
java: double Mahalanobis(Mat v1, Mat v2, Mat icovar)
FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void dft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void dft(Mat src, Mat dst, int flags)
java: void dft(Mat src, Mat dst)
FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void idft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void idft(Mat src, Mat dst, int flags)
java: void idft(Mat src, Mat dst)
FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void dct(Mat src, Mat dst, int flags)
java: void dct(Mat src, Mat dst)
FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void idct(Mat src, Mat dst, int flags)
java: void idct(Mat src, Mat dst)
FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags, boolean conjB)
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags)
FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>
java: int getOptimalDFTSize(int vecsize)
FUNC <void cv..setRNGSeed [ARG int seed=]>
java: void setRNGSeed(int seed)
FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>
java: void randu(Mat dst, double low, double high)
FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>
java: void randn(Mat dst, double mean, double stddev)
FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst)
FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags, Mat centers)
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags)
FUNC <void cv..setNumThreads [ARG int nthreads=]>
java: void setNumThreads(int nthreads)
FUNC <int cv..getNumThreads []>
java: int getNumThreads()
FUNC <int cv..getThreadNum []>
java: int getThreadNum()
FUNC <String cv..getBuildInformation []>
java: String getBuildInformation()
FUNC <String cv..getVersionString []>
java: String getVersionString()
FUNC <int cv..getVersionMajor []>
java: int getVersionMajor()
FUNC <int cv..getVersionMinor []>
java: int getVersionMinor()
FUNC <int cv..getVersionRevision []>
java: int getVersionRevision()
FUNC <int64 cv..getTickCount []>
java: long getTickCount()
FUNC <double cv..getTickFrequency []>
java: double getTickFrequency()
FUNC <int64 cv..getCPUTickCount []>
java: long getCPUTickCount()
FUNC <String cv..getHardwareFeatureName [ARG int feature=]>
java: String getHardwareFeatureName(int feature)
FUNC <string cv..getCPUFeaturesLine []>
java: String getCPUFeaturesLine()
FUNC <int cv..getNumberOfCPUs []>
java: int getNumberOfCPUs()
FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>
java: String findFile(String relative_path, boolean required, boolean silentMode)
java: String findFile(String relative_path, boolean required)
java: String findFile(String relative_path)
FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>
java: String findFileOrKeep(String relative_path, boolean silentMode)
java: String findFileOrKeep(String relative_path)
FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>
java: void addSamplesDataSearchPath(String path)
FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>
java: void addSamplesDataSearchSubDirectory(String subdir)
FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>
java: void setErrorVerbosity(boolean verbose)
FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void add(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale)
java: void multiply(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Scalar src2, Mat dst, double scale)
java: void divide(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Scalar src2, Mat dst, int cmpop)
FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void min(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void max(Mat src1, Scalar src2, Mat dst)
manual function: checkHardwareSupport
manual function: minMaxLoc
manual function: setUseOptimized
manual function: useOptimized
CLASS cv::.TickMeter : 
FUNC < cv.TickMeter.TickMeter []>
java:  TickMeter()
FUNC <void cv.TickMeter.start []>
java: void start()
FUNC <void cv.TickMeter.stop []>
java: void stop()
FUNC <int64 cv.TickMeter.getTimeTicks []>
java: long getTimeTicks()
FUNC <double cv.TickMeter.getTimeMicro []>
java: double getTimeMicro()
FUNC <double cv.TickMeter.getTimeMilli []>
java: double getTimeMilli()
FUNC <double cv.TickMeter.getTimeSec []>
java: double getTimeSec()
FUNC <int64 cv.TickMeter.getCounter []>
java: long getCounter()
FUNC <double cv.TickMeter.getFPS []>
java: double getFPS()
FUNC <double cv.TickMeter.getAvgTimeSec []>
java: double getAvgTimeSec()
FUNC <double cv.TickMeter.getAvgTimeMilli []>
java: double getAvgTimeMilli()
FUNC <void cv.TickMeter.reset []>
java: void reset()

=== MODULE: imgproc (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc) ===


Files (9):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/types_c.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc_c.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/interface.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/bindings.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/segmentation.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Imgproc : , name: Imgproc, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/types_c.h =====
Namespaces: ['']

--- Incoming ---
[   'enum SmoothMethod_c',
    '',
    [],
    [   ['const CV_BLUR_NO_SCALE', '0', [], [], None, ''],
        ['const CV_BLUR', '1', [], [], None, ''],
        ['const CV_GAUSSIAN', '2', [], [], None, ''],
        ['const CV_MEDIAN', '3', [], [], None, ''],
        ['const CV_BILATERAL', '4', [], [], None, '']],
    None]
ok: CONST CV_BLUR_NO_SCALE=0
ok: CONST CV_BLUR=1
ok: CONST CV_GAUSSIAN=2
ok: CONST CV_MEDIAN=3
ok: CONST CV_BILATERAL=4

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [['const CV_GAUSSIAN_5x5', '7', [], [], None, '']],
    None]
ok: CONST CV_GAUSSIAN_5x5=7

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_SCHARR', '-1', [], [], None, ''],
        ['const CV_MAX_SOBEL_KSIZE', '7', [], [], None, '']],
    None]
ok: CONST CV_SCHARR=-1
ok: CONST CV_MAX_SOBEL_KSIZE=7

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_BGR2BGRA', '0', [], [], None, ''],
        ['const CV_RGB2RGBA', 'CV_BGR2BGRA', [], [], None, ''],
        ['const CV_BGRA2BGR', '1', [], [], None, ''],
        ['const CV_RGBA2RGB', 'CV_BGRA2BGR', [], [], None, ''],
        ['const CV_BGR2RGBA', '2', [], [], None, ''],
        ['const CV_RGB2BGRA', 'CV_BGR2RGBA', [], [], None, ''],
        ['const CV_RGBA2BGR', '3', [], [], None, ''],
        ['const CV_BGRA2RGB', 'CV_RGBA2BGR', [], [], None, ''],
        ['const CV_BGR2RGB', '4', [], [], None, ''],
        ['const CV_RGB2BGR', 'CV_BGR2RGB', [], [], None, ''],
        ['const CV_BGRA2RGBA', '5', [], [], None, ''],
        ['const CV_RGBA2BGRA', 'CV_BGRA2RGBA', [], [], None, ''],
        ['const CV_BGR2GRAY', '6', [], [], None, ''],
        ['const CV_RGB2GRAY', '7', [], [], None, ''],
        ['const CV_GRAY2BGR', '8', [], [], None, ''],
        ['const CV_GRAY2RGB', 'CV_GRAY2BGR', [], [], None, ''],
        ['const CV_GRAY2BGRA', '9', [], [], None, ''],
        ['const CV_GRAY2RGBA', 'CV_GRAY2BGRA', [], [], None, ''],
        ['const CV_BGRA2GRAY', '10', [], [], None, ''],
        ['const CV_RGBA2GRAY', '11', [], [], None, ''],
        ['const CV_BGR2BGR565', '12', [], [], None, ''],
        ['const CV_RGB2BGR565', '13', [], [], None, ''],
        ['const CV_BGR5652BGR', '14', [], [], None, ''],
        ['const CV_BGR5652RGB', '15', [], [], None, ''],
        ['const CV_BGRA2BGR565', '16', [], [], None, ''],
        ['const CV_RGBA2BGR565', '17', [], [], None, ''],
        ['const CV_BGR5652BGRA', '18', [], [], None, ''],
        ['const CV_BGR5652RGBA', '19', [], [], None, ''],
        ['const CV_GRAY2BGR565', '20', [], [], None, ''],
        ['const CV_BGR5652GRAY', '21', [], [], None, ''],
        ['const CV_BGR2BGR555', '22', [], [], None, ''],
        ['const CV_RGB2BGR555', '23', [], [], None, ''],
        ['const CV_BGR5552BGR', '24', [], [], None, ''],
        ['const CV_BGR5552RGB', '25', [], [], None, ''],
        ['const CV_BGRA2BGR555', '26', [], [], None, ''],
        ['const CV_RGBA2BGR555', '27', [], [], None, ''],
        ['const CV_BGR5552BGRA', '28', [], [], None, ''],
        ['const CV_BGR5552RGBA', '29', [], [], None, ''],
        ['const CV_GRAY2BGR555', '30', [], [], None, ''],
        ['const CV_BGR5552GRAY', '31', [], [], None, ''],
        ['const CV_BGR2XYZ', '32', [], [], None, ''],
        ['const CV_RGB2XYZ', '33', [], [], None, ''],
        ['const CV_XYZ2BGR', '34', [], [], None, ''],
        ['const CV_XYZ2RGB', '35', [], [], None, ''],
        ['const CV_BGR2YCrCb', '36', [], [], None, ''],
        ['const CV_RGB2YCrCb', '37', [], [], None, ''],
        ['const CV_YCrCb2BGR', '38', [], [], None, ''],
        ['const CV_YCrCb2RGB', '39', [], [], None, ''],
        ['const CV_BGR2HSV', '40', [], [], None, ''],
        ['const CV_RGB2HSV', '41', [], [], None, ''],
        ['const CV_BGR2Lab', '44', [], [], None, ''],
        ['const CV_RGB2Lab', '45', [], [], None, ''],
        ['const CV_BayerBG2BGR', '46', [], [], None, ''],
        ['const CV_BayerGB2BGR', '47', [], [], None, ''],
        ['const CV_BayerRG2BGR', '48', [], [], None, ''],
        ['const CV_BayerGR2BGR', '49', [], [], None, ''],
        ['const CV_BayerBG2RGB', 'CV_BayerRG2BGR', [], [], None, ''],
        ['const CV_BayerGB2RGB', 'CV_BayerGR2BGR', [], [], None, ''],
        ['const CV_BayerRG2RGB', 'CV_BayerBG2BGR', [], [], None, ''],
        ['const CV_BayerGR2RGB', 'CV_BayerGB2BGR', [], [], None, ''],
        ['const CV_BGR2Luv', '50', [], [], None, ''],
        ['const CV_RGB2Luv', '51', [], [], None, ''],
        ['const CV_BGR2HLS', '52', [], [], None, ''],
        ['const CV_RGB2HLS', '53', [], [], None, ''],
        ['const CV_HSV2BGR', '54', [], [], None, ''],
        ['const CV_HSV2RGB', '55', [], [], None, ''],
        ['const CV_Lab2BGR', '56', [], [], None, ''],
        ['const CV_Lab2RGB', '57', [], [], None, ''],
        ['const CV_Luv2BGR', '58', [], [], None, ''],
        ['const CV_Luv2RGB', '59', [], [], None, ''],
        ['const CV_HLS2BGR', '60', [], [], None, ''],
        ['const CV_HLS2RGB', '61', [], [], None, ''],
        ['const CV_BayerBG2BGR_VNG', '62', [], [], None, ''],
        ['const CV_BayerGB2BGR_VNG', '63', [], [], None, ''],
        ['const CV_BayerRG2BGR_VNG', '64', [], [], None, ''],
        ['const CV_BayerGR2BGR_VNG', '65', [], [], None, ''],
        ['const CV_BayerBG2RGB_VNG', 'CV_BayerRG2BGR_VNG', [], [], None, ''],
        ['const CV_BayerGB2RGB_VNG', 'CV_BayerGR2BGR_VNG', [], [], None, ''],
        ['const CV_BayerRG2RGB_VNG', 'CV_BayerBG2BGR_VNG', [], [], None, ''],
        ['const CV_BayerGR2RGB_VNG', 'CV_BayerGB2BGR_VNG', [], [], None, ''],
        ['const CV_BGR2HSV_FULL', '66', [], [], None, ''],
        ['const CV_RGB2HSV_FULL', '67', [], [], None, ''],
        ['const CV_BGR2HLS_FULL', '68', [], [], None, ''],
        ['const CV_RGB2HLS_FULL', '69', [], [], None, ''],
        ['const CV_HSV2BGR_FULL', '70', [], [], None, ''],
        ['const CV_HSV2RGB_FULL', '71', [], [], None, ''],
        ['const CV_HLS2BGR_FULL', '72', [], [], None, ''],
        ['const CV_HLS2RGB_FULL', '73', [], [], None, ''],
        ['const CV_LBGR2Lab', '74', [], [], None, ''],
        ['const CV_LRGB2Lab', '75', [], [], None, ''],
        ['const CV_LBGR2Luv', '76', [], [], None, ''],
        ['const CV_LRGB2Luv', '77', [], [], None, ''],
        ['const CV_Lab2LBGR', '78', [], [], None, ''],
        ['const CV_Lab2LRGB', '79', [], [], None, ''],
        ['const CV_Luv2LBGR', '80', [], [], None, ''],
        ['const CV_Luv2LRGB', '81', [], [], None, ''],
        ['const CV_BGR2YUV', '82', [], [], None, ''],
        ['const CV_RGB2YUV', '83', [], [], None, ''],
        ['const CV_YUV2BGR', '84', [], [], None, ''],
        ['const CV_YUV2RGB', '85', [], [], None, ''],
        ['const CV_BayerBG2GRAY', '86', [], [], None, ''],
        ['const CV_BayerGB2GRAY', '87', [], [], None, ''],
        ['const CV_BayerRG2GRAY', '88', [], [], None, ''],
        ['const CV_BayerGR2GRAY', '89', [], [], None, ''],
        ['const CV_YUV2RGB_NV12', '90', [], [], None, ''],
        ['const CV_YUV2BGR_NV12', '91', [], [], None, ''],
        ['const CV_YUV2RGB_NV21', '92', [], [], None, ''],
        ['const CV_YUV2BGR_NV21', '93', [], [], None, ''],
        ['const CV_YUV420sp2RGB', 'CV_YUV2RGB_NV21', [], [], None, ''],
        ['const CV_YUV420sp2BGR', 'CV_YUV2BGR_NV21', [], [], None, ''],
        ['const CV_YUV2RGBA_NV12', '94', [], [], None, ''],
        ['const CV_YUV2BGRA_NV12', '95', [], [], None, ''],
        ['const CV_YUV2RGBA_NV21', '96', [], [], None, ''],
        ['const CV_YUV2BGRA_NV21', '97', [], [], None, ''],
        ['const CV_YUV420sp2RGBA', 'CV_YUV2RGBA_NV21', [], [], None, ''],
        ['const CV_YUV420sp2BGRA', 'CV_YUV2BGRA_NV21', [], [], None, ''],
        ['const CV_YUV2RGB_YV12', '98', [], [], None, ''],
        ['const CV_YUV2BGR_YV12', '99', [], [], None, ''],
        ['const CV_YUV2RGB_IYUV', '100', [], [], None, ''],
        ['const CV_YUV2BGR_IYUV', '101', [], [], None, ''],
        ['const CV_YUV2RGB_I420', 'CV_YUV2RGB_IYUV', [], [], None, ''],
        ['const CV_YUV2BGR_I420', 'CV_YUV2BGR_IYUV', [], [], None, ''],
        ['const CV_YUV420p2RGB', 'CV_YUV2RGB_YV12', [], [], None, ''],
        ['const CV_YUV420p2BGR', 'CV_YUV2BGR_YV12', [], [], None, ''],
        ['const CV_YUV2RGBA_YV12', '102', [], [], None, ''],
        ['const CV_YUV2BGRA_YV12', '103', [], [], None, ''],
        ['const CV_YUV2RGBA_IYUV', '104', [], [], None, ''],
        ['const CV_YUV2BGRA_IYUV', '105', [], [], None, ''],
        ['const CV_YUV2RGBA_I420', 'CV_YUV2RGBA_IYUV', [], [], None, ''],
        ['const CV_YUV2BGRA_I420', 'CV_YUV2BGRA_IYUV', [], [], None, ''],
        ['const CV_YUV420p2RGBA', 'CV_YUV2RGBA_YV12', [], [], None, ''],
        ['const CV_YUV420p2BGRA', 'CV_YUV2BGRA_YV12', [], [], None, ''],
        ['const CV_YUV2GRAY_420', '106', [], [], None, ''],
        ['const CV_YUV2GRAY_NV21', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV2GRAY_NV12', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV2GRAY_YV12', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV2GRAY_IYUV', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV2GRAY_I420', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV420sp2GRAY', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV420p2GRAY', 'CV_YUV2GRAY_420', [], [], None, ''],
        ['const CV_YUV2RGB_UYVY', '107', [], [], None, ''],
        ['const CV_YUV2BGR_UYVY', '108', [], [], None, ''],
        ['const CV_YUV2RGB_Y422', 'CV_YUV2RGB_UYVY', [], [], None, ''],
        ['const CV_YUV2BGR_Y422', 'CV_YUV2BGR_UYVY', [], [], None, ''],
        ['const CV_YUV2RGB_UYNV', 'CV_YUV2RGB_UYVY', [], [], None, ''],
        ['const CV_YUV2BGR_UYNV', 'CV_YUV2BGR_UYVY', [], [], None, ''],
        ['const CV_YUV2RGBA_UYVY', '111', [], [], None, ''],
        ['const CV_YUV2BGRA_UYVY', '112', [], [], None, ''],
        ['const CV_YUV2RGBA_Y422', 'CV_YUV2RGBA_UYVY', [], [], None, ''],
        ['const CV_YUV2BGRA_Y422', 'CV_YUV2BGRA_UYVY', [], [], None, ''],
        ['const CV_YUV2RGBA_UYNV', 'CV_YUV2RGBA_UYVY', [], [], None, ''],
        ['const CV_YUV2BGRA_UYNV', 'CV_YUV2BGRA_UYVY', [], [], None, ''],
        ['const CV_YUV2RGB_YUY2', '115', [], [], None, ''],
        ['const CV_YUV2BGR_YUY2', '116', [], [], None, ''],
        ['const CV_YUV2RGB_YVYU', '117', [], [], None, ''],
        ['const CV_YUV2BGR_YVYU', '118', [], [], None, ''],
        ['const CV_YUV2RGB_YUYV', 'CV_YUV2RGB_YUY2', [], [], None, ''],
        ['const CV_YUV2BGR_YUYV', 'CV_YUV2BGR_YUY2', [], [], None, ''],
        ['const CV_YUV2RGB_YUNV', 'CV_YUV2RGB_YUY2', [], [], None, ''],
        ['const CV_YUV2BGR_YUNV', 'CV_YUV2BGR_YUY2', [], [], None, ''],
        ['const CV_YUV2RGBA_YUY2', '119', [], [], None, ''],
        ['const CV_YUV2BGRA_YUY2', '120', [], [], None, ''],
        ['const CV_YUV2RGBA_YVYU', '121', [], [], None, ''],
        ['const CV_YUV2BGRA_YVYU', '122', [], [], None, ''],
        ['const CV_YUV2RGBA_YUYV', 'CV_YUV2RGBA_YUY2', [], [], None, ''],
        ['const CV_YUV2BGRA_YUYV', 'CV_YUV2BGRA_YUY2', [], [], None, ''],
        ['const CV_YUV2RGBA_YUNV', 'CV_YUV2RGBA_YUY2', [], [], None, ''],
        ['const CV_YUV2BGRA_YUNV', 'CV_YUV2BGRA_YUY2', [], [], None, ''],
        ['const CV_YUV2GRAY_UYVY', '123', [], [], None, ''],
        ['const CV_YUV2GRAY_YUY2', '124', [], [], None, ''],
        ['const CV_YUV2GRAY_Y422', 'CV_YUV2GRAY_UYVY', [], [], None, ''],
        ['const CV_YUV2GRAY_UYNV', 'CV_YUV2GRAY_UYVY', [], [], None, ''],
        ['const CV_YUV2GRAY_YVYU', 'CV_YUV2GRAY_YUY2', [], [], None, ''],
        ['const CV_YUV2GRAY_YUYV', 'CV_YUV2GRAY_YUY2', [], [], None, ''],
        ['const CV_YUV2GRAY_YUNV', 'CV_YUV2GRAY_YUY2', [], [], None, ''],
        ['const CV_RGBA2mRGBA', '125', [], [], None, ''],
        ['const CV_mRGBA2RGBA', '126', [], [], None, ''],
        ['const CV_RGB2YUV_I420', '127', [], [], None, ''],
        ['const CV_BGR2YUV_I420', '128', [], [], None, ''],
        ['const CV_RGB2YUV_IYUV', 'CV_RGB2YUV_I420', [], [], None, ''],
        ['const CV_BGR2YUV_IYUV', 'CV_BGR2YUV_I420', [], [], None, ''],
        ['const CV_RGBA2YUV_I420', '129', [], [], None, ''],
        ['const CV_BGRA2YUV_I420', '130', [], [], None, ''],
        ['const CV_RGBA2YUV_IYUV', 'CV_RGBA2YUV_I420', [], [], None, ''],
        ['const CV_BGRA2YUV_IYUV', 'CV_BGRA2YUV_I420', [], [], None, ''],
        ['const CV_RGB2YUV_YV12', '131', [], [], None, ''],
        ['const CV_BGR2YUV_YV12', '132', [], [], None, ''],
        ['const CV_RGBA2YUV_YV12', '133', [], [], None, ''],
        ['const CV_BGRA2YUV_YV12', '134', [], [], None, ''],
        ['const CV_BayerBG2BGR_EA', '135', [], [], None, ''],
        ['const CV_BayerGB2BGR_EA', '136', [], [], None, ''],
        ['const CV_BayerRG2BGR_EA', '137', [], [], None, ''],
        ['const CV_BayerGR2BGR_EA', '138', [], [], None, ''],
        ['const CV_BayerBG2RGB_EA', 'CV_BayerRG2BGR_EA', [], [], None, ''],
        ['const CV_BayerGB2RGB_EA', 'CV_BayerGR2BGR_EA', [], [], None, ''],
        ['const CV_BayerRG2RGB_EA', 'CV_BayerBG2BGR_EA', [], [], None, ''],
        ['const CV_BayerGR2RGB_EA', 'CV_BayerGB2BGR_EA', [], [], None, ''],
        ['const CV_BayerBG2BGRA', '139', [], [], None, ''],
        ['const CV_BayerGB2BGRA', '140', [], [], None, ''],
        ['const CV_BayerRG2BGRA', '141', [], [], None, ''],
        ['const CV_BayerGR2BGRA', '142', [], [], None, ''],
        ['const CV_BayerBG2RGBA', 'CV_BayerRG2BGRA', [], [], None, ''],
        ['const CV_BayerGB2RGBA', 'CV_BayerGR2BGRA', [], [], None, ''],
        ['const CV_BayerRG2RGBA', 'CV_BayerBG2BGRA', [], [], None, ''],
        ['const CV_BayerGR2RGBA', 'CV_BayerGB2BGRA', [], [], None, ''],
        ['const CV_COLORCVT_MAX', '143', [], [], None, '']],
    None]
ignored: CONST CV_BGR2BGRA=0
ignored: CONST CV_RGB2RGBA=CV_BGR2BGRA
ignored: CONST CV_BGRA2BGR=1
ignored: CONST CV_RGBA2RGB=CV_BGRA2BGR
ignored: CONST CV_BGR2RGBA=2
ignored: CONST CV_RGB2BGRA=CV_BGR2RGBA
ignored: CONST CV_RGBA2BGR=3
ignored: CONST CV_BGRA2RGB=CV_RGBA2BGR
ignored: CONST CV_BGR2RGB=4
ignored: CONST CV_RGB2BGR=CV_BGR2RGB
ignored: CONST CV_BGRA2RGBA=5
ignored: CONST CV_RGBA2BGRA=CV_BGRA2RGBA
ignored: CONST CV_BGR2GRAY=6
ignored: CONST CV_RGB2GRAY=7
ignored: CONST CV_GRAY2BGR=8
ignored: CONST CV_GRAY2RGB=CV_GRAY2BGR
ignored: CONST CV_GRAY2BGRA=9
ignored: CONST CV_GRAY2RGBA=CV_GRAY2BGRA
ignored: CONST CV_BGRA2GRAY=10
ignored: CONST CV_RGBA2GRAY=11
ignored: CONST CV_BGR2BGR565=12
ignored: CONST CV_RGB2BGR565=13
ignored: CONST CV_BGR5652BGR=14
ignored: CONST CV_BGR5652RGB=15
ignored: CONST CV_BGRA2BGR565=16
ignored: CONST CV_RGBA2BGR565=17
ignored: CONST CV_BGR5652BGRA=18
ignored: CONST CV_BGR5652RGBA=19
ignored: CONST CV_GRAY2BGR565=20
ignored: CONST CV_BGR5652GRAY=21
ignored: CONST CV_BGR2BGR555=22
ignored: CONST CV_RGB2BGR555=23
ignored: CONST CV_BGR5552BGR=24
ignored: CONST CV_BGR5552RGB=25
ignored: CONST CV_BGRA2BGR555=26
ignored: CONST CV_RGBA2BGR555=27
ignored: CONST CV_BGR5552BGRA=28
ignored: CONST CV_BGR5552RGBA=29
ignored: CONST CV_GRAY2BGR555=30
ignored: CONST CV_BGR5552GRAY=31
ignored: CONST CV_BGR2XYZ=32
ignored: CONST CV_RGB2XYZ=33
ignored: CONST CV_XYZ2BGR=34
ignored: CONST CV_XYZ2RGB=35
ignored: CONST CV_BGR2YCrCb=36
ignored: CONST CV_RGB2YCrCb=37
ignored: CONST CV_YCrCb2BGR=38
ignored: CONST CV_YCrCb2RGB=39
ignored: CONST CV_BGR2HSV=40
ignored: CONST CV_RGB2HSV=41
ignored: CONST CV_BGR2Lab=44
ignored: CONST CV_RGB2Lab=45
ignored: CONST CV_BayerBG2BGR=46
ignored: CONST CV_BayerGB2BGR=47
ignored: CONST CV_BayerRG2BGR=48
ignored: CONST CV_BayerGR2BGR=49
ignored: CONST CV_BayerBG2RGB=CV_BayerRG2BGR
ignored: CONST CV_BayerGB2RGB=CV_BayerGR2BGR
ignored: CONST CV_BayerRG2RGB=CV_BayerBG2BGR
ignored: CONST CV_BayerGR2RGB=CV_BayerGB2BGR
ignored: CONST CV_BGR2Luv=50
ignored: CONST CV_RGB2Luv=51
ignored: CONST CV_BGR2HLS=52
ignored: CONST CV_RGB2HLS=53
ignored: CONST CV_HSV2BGR=54
ignored: CONST CV_HSV2RGB=55
ignored: CONST CV_Lab2BGR=56
ignored: CONST CV_Lab2RGB=57
ignored: CONST CV_Luv2BGR=58
ignored: CONST CV_Luv2RGB=59
ignored: CONST CV_HLS2BGR=60
ignored: CONST CV_HLS2RGB=61
ignored: CONST CV_BayerBG2BGR_VNG=62
ignored: CONST CV_BayerGB2BGR_VNG=63
ignored: CONST CV_BayerRG2BGR_VNG=64
ignored: CONST CV_BayerGR2BGR_VNG=65
ignored: CONST CV_BayerBG2RGB_VNG=CV_BayerRG2BGR_VNG
ignored: CONST CV_BayerGB2RGB_VNG=CV_BayerGR2BGR_VNG
ignored: CONST CV_BayerRG2RGB_VNG=CV_BayerBG2BGR_VNG
ignored: CONST CV_BayerGR2RGB_VNG=CV_BayerGB2BGR_VNG
ignored: CONST CV_BGR2HSV_FULL=66
ignored: CONST CV_RGB2HSV_FULL=67
ignored: CONST CV_BGR2HLS_FULL=68
ignored: CONST CV_RGB2HLS_FULL=69
ignored: CONST CV_HSV2BGR_FULL=70
ignored: CONST CV_HSV2RGB_FULL=71
ignored: CONST CV_HLS2BGR_FULL=72
ignored: CONST CV_HLS2RGB_FULL=73
ignored: CONST CV_LBGR2Lab=74
ignored: CONST CV_LRGB2Lab=75
ignored: CONST CV_LBGR2Luv=76
ignored: CONST CV_LRGB2Luv=77
ignored: CONST CV_Lab2LBGR=78
ignored: CONST CV_Lab2LRGB=79
ignored: CONST CV_Luv2LBGR=80
ignored: CONST CV_Luv2LRGB=81
ignored: CONST CV_BGR2YUV=82
ignored: CONST CV_RGB2YUV=83
ignored: CONST CV_YUV2BGR=84
ignored: CONST CV_YUV2RGB=85
ignored: CONST CV_BayerBG2GRAY=86
ignored: CONST CV_BayerGB2GRAY=87
ignored: CONST CV_BayerRG2GRAY=88
ignored: CONST CV_BayerGR2GRAY=89
ignored: CONST CV_YUV2RGB_NV12=90
ignored: CONST CV_YUV2BGR_NV12=91
ignored: CONST CV_YUV2RGB_NV21=92
ignored: CONST CV_YUV2BGR_NV21=93
ignored: CONST CV_YUV420sp2RGB=CV_YUV2RGB_NV21
ignored: CONST CV_YUV420sp2BGR=CV_YUV2BGR_NV21
ignored: CONST CV_YUV2RGBA_NV12=94
ignored: CONST CV_YUV2BGRA_NV12=95
ignored: CONST CV_YUV2RGBA_NV21=96
ignored: CONST CV_YUV2BGRA_NV21=97
ignored: CONST CV_YUV420sp2RGBA=CV_YUV2RGBA_NV21
ignored: CONST CV_YUV420sp2BGRA=CV_YUV2BGRA_NV21
ignored: CONST CV_YUV2RGB_YV12=98
ignored: CONST CV_YUV2BGR_YV12=99
ignored: CONST CV_YUV2RGB_IYUV=100
ignored: CONST CV_YUV2BGR_IYUV=101
ignored: CONST CV_YUV2RGB_I420=CV_YUV2RGB_IYUV
ignored: CONST CV_YUV2BGR_I420=CV_YUV2BGR_IYUV
ignored: CONST CV_YUV420p2RGB=CV_YUV2RGB_YV12
ignored: CONST CV_YUV420p2BGR=CV_YUV2BGR_YV12
ignored: CONST CV_YUV2RGBA_YV12=102
ignored: CONST CV_YUV2BGRA_YV12=103
ignored: CONST CV_YUV2RGBA_IYUV=104
ignored: CONST CV_YUV2BGRA_IYUV=105
ignored: CONST CV_YUV2RGBA_I420=CV_YUV2RGBA_IYUV
ignored: CONST CV_YUV2BGRA_I420=CV_YUV2BGRA_IYUV
ignored: CONST CV_YUV420p2RGBA=CV_YUV2RGBA_YV12
ignored: CONST CV_YUV420p2BGRA=CV_YUV2BGRA_YV12
ignored: CONST CV_YUV2GRAY_420=106
ignored: CONST CV_YUV2GRAY_NV21=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_NV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_YV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_IYUV=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_I420=CV_YUV2GRAY_420
ignored: CONST CV_YUV420sp2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV420p2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV2RGB_UYVY=107
ignored: CONST CV_YUV2BGR_UYVY=108
ignored: CONST CV_YUV2RGB_Y422=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_Y422=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGB_UYNV=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_UYNV=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGBA_UYVY=111
ignored: CONST CV_YUV2BGRA_UYVY=112
ignored: CONST CV_YUV2RGBA_Y422=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_Y422=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGBA_UYNV=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_UYNV=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGB_YUY2=115
ignored: CONST CV_YUV2BGR_YUY2=116
ignored: CONST CV_YUV2RGB_YVYU=117
ignored: CONST CV_YUV2BGR_YVYU=118
ignored: CONST CV_YUV2RGB_YUYV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUYV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGB_YUNV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUNV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGBA_YUY2=119
ignored: CONST CV_YUV2BGRA_YUY2=120
ignored: CONST CV_YUV2RGBA_YVYU=121
ignored: CONST CV_YUV2BGRA_YVYU=122
ignored: CONST CV_YUV2RGBA_YUYV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUYV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2RGBA_YUNV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUNV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2GRAY_UYVY=123
ignored: CONST CV_YUV2GRAY_YUY2=124
ignored: CONST CV_YUV2GRAY_Y422=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_UYNV=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_YVYU=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUYV=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUNV=CV_YUV2GRAY_YUY2
ok: CONST CV_RGBA2mRGBA=125
ok: CONST CV_mRGBA2RGBA=126
ignored: CONST CV_RGB2YUV_I420=127
ignored: CONST CV_BGR2YUV_I420=128
ignored: CONST CV_RGB2YUV_IYUV=CV_RGB2YUV_I420
ignored: CONST CV_BGR2YUV_IYUV=CV_BGR2YUV_I420
ignored: CONST CV_RGBA2YUV_I420=129
ignored: CONST CV_BGRA2YUV_I420=130
ignored: CONST CV_RGBA2YUV_IYUV=CV_RGBA2YUV_I420
ignored: CONST CV_BGRA2YUV_IYUV=CV_BGRA2YUV_I420
ignored: CONST CV_RGB2YUV_YV12=131
ignored: CONST CV_BGR2YUV_YV12=132
ignored: CONST CV_RGBA2YUV_YV12=133
ignored: CONST CV_BGRA2YUV_YV12=134
ignored: CONST CV_BayerBG2BGR_EA=135
ignored: CONST CV_BayerGB2BGR_EA=136
ignored: CONST CV_BayerRG2BGR_EA=137
ignored: CONST CV_BayerGR2BGR_EA=138
ignored: CONST CV_BayerBG2RGB_EA=CV_BayerRG2BGR_EA
ignored: CONST CV_BayerGB2RGB_EA=CV_BayerGR2BGR_EA
ignored: CONST CV_BayerRG2RGB_EA=CV_BayerBG2BGR_EA
ignored: CONST CV_BayerGR2RGB_EA=CV_BayerGB2BGR_EA
ignored: CONST CV_BayerBG2BGRA=139
ignored: CONST CV_BayerGB2BGRA=140
ignored: CONST CV_BayerRG2BGRA=141
ignored: CONST CV_BayerGR2BGRA=142
ignored: CONST CV_BayerBG2RGBA=CV_BayerRG2BGRA
ignored: CONST CV_BayerGB2RGBA=CV_BayerGR2BGRA
ignored: CONST CV_BayerRG2RGBA=CV_BayerBG2BGRA
ignored: CONST CV_BayerGR2RGBA=CV_BayerGB2BGRA
ignored: CONST CV_COLORCVT_MAX=143

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_INTER_NN', '0', [], [], None, ''],
        ['const CV_INTER_LINEAR', '1', [], [], None, ''],
        ['const CV_INTER_CUBIC', '2', [], [], None, ''],
        ['const CV_INTER_AREA', '3', [], [], None, ''],
        ['const CV_INTER_LANCZOS4', '4', [], [], None, '']],
    None]
ok: CONST CV_INTER_NN=0
ok: CONST CV_INTER_LINEAR=1
ok: CONST CV_INTER_CUBIC=2
ok: CONST CV_INTER_AREA=3
ok: CONST CV_INTER_LANCZOS4=4

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_WARP_FILL_OUTLIERS', '8', [], [], None, ''],
        ['const CV_WARP_INVERSE_MAP', '16', [], [], None, '']],
    None]
ok: CONST CV_WARP_FILL_OUTLIERS=8
ok: CONST CV_WARP_INVERSE_MAP=16

--- Incoming ---
[   'enum MorphShapes_c',
    '',
    [],
    [   ['const CV_SHAPE_RECT', '0', [], [], None, ''],
        ['const CV_SHAPE_CROSS', '1', [], [], None, ''],
        ['const CV_SHAPE_ELLIPSE', '2', [], [], None, ''],
        ['const CV_SHAPE_CUSTOM', '100', [], [], None, '']],
    None]
ok: CONST CV_SHAPE_RECT=0
ok: CONST CV_SHAPE_CROSS=1
ok: CONST CV_SHAPE_ELLIPSE=2
ok: CONST CV_SHAPE_CUSTOM=100

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_MOP_ERODE', '0', [], [], None, ''],
        ['const CV_MOP_DILATE', '1', [], [], None, ''],
        ['const CV_MOP_OPEN', '2', [], [], None, ''],
        ['const CV_MOP_CLOSE', '3', [], [], None, ''],
        ['const CV_MOP_GRADIENT', '4', [], [], None, ''],
        ['const CV_MOP_TOPHAT', '5', [], [], None, ''],
        ['const CV_MOP_BLACKHAT', '6', [], [], None, '']],
    None]
ok: CONST CV_MOP_ERODE=0
ok: CONST CV_MOP_DILATE=1
ok: CONST CV_MOP_OPEN=2
ok: CONST CV_MOP_CLOSE=3
ok: CONST CV_MOP_GRADIENT=4
ok: CONST CV_MOP_TOPHAT=5
ok: CONST CV_MOP_BLACKHAT=6

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_TM_SQDIFF', '0', [], [], None, ''],
        ['const CV_TM_SQDIFF_NORMED', '1', [], [], None, ''],
        ['const CV_TM_CCORR', '2', [], [], None, ''],
        ['const CV_TM_CCORR_NORMED', '3', [], [], None, ''],
        ['const CV_TM_CCOEFF', '4', [], [], None, ''],
        ['const CV_TM_CCOEFF_NORMED', '5', [], [], None, '']],
    None]
ignored: CONST CV_TM_SQDIFF=0
ignored: CONST CV_TM_SQDIFF_NORMED=1
ignored: CONST CV_TM_CCORR=2
ignored: CONST CV_TM_CCORR_NORMED=3
ignored: CONST CV_TM_CCOEFF=4
ignored: CONST CV_TM_CCOEFF_NORMED=5

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_RETR_EXTERNAL', '0', [], [], None, ''],
        ['const CV_RETR_LIST', '1', [], [], None, ''],
        ['const CV_RETR_CCOMP', '2', [], [], None, ''],
        ['const CV_RETR_TREE', '3', [], [], None, ''],
        ['const CV_RETR_FLOODFILL', '4', [], [], None, '']],
    None]
ok: CONST CV_RETR_EXTERNAL=0
ok: CONST CV_RETR_LIST=1
ok: CONST CV_RETR_CCOMP=2
ok: CONST CV_RETR_TREE=3
ok: CONST CV_RETR_FLOODFILL=4

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_CHAIN_CODE', '0', [], [], None, ''],
        ['const CV_CHAIN_APPROX_NONE', '1', [], [], None, ''],
        ['const CV_CHAIN_APPROX_SIMPLE', '2', [], [], None, ''],
        ['const CV_CHAIN_APPROX_TC89_L1', '3', [], [], None, ''],
        ['const CV_CHAIN_APPROX_TC89_KCOS', '4', [], [], None, ''],
        ['const CV_LINK_RUNS', '5', [], [], None, '']],
    None]
ok: CONST CV_CHAIN_CODE=0
ok: CONST CV_CHAIN_APPROX_NONE=1
ok: CONST CV_CHAIN_APPROX_SIMPLE=2
ok: CONST CV_CHAIN_APPROX_TC89_L1=3
ok: CONST CV_CHAIN_APPROX_TC89_KCOS=4
ok: CONST CV_LINK_RUNS=5

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [['const CV_POLY_APPROX_DP', '0', [], [], None, '']],
    None]
ok: CONST CV_POLY_APPROX_DP=0

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_CONTOURS_MATCH_I1', '1', [], [], None, ''],
        ['const CV_CONTOURS_MATCH_I2', '2', [], [], None, ''],
        ['const CV_CONTOURS_MATCH_I3', '3', [], [], None, '']],
    None]
ok: CONST CV_CONTOURS_MATCH_I1=1
ok: CONST CV_CONTOURS_MATCH_I2=2
ok: CONST CV_CONTOURS_MATCH_I3=3

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_CLOCKWISE', '1', [], [], None, ''],
        ['const CV_COUNTER_CLOCKWISE', '2', [], [], None, '']],
    None]
ok: CONST CV_CLOCKWISE=1
ok: CONST CV_COUNTER_CLOCKWISE=2

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_COMP_CORREL', '0', [], [], None, ''],
        ['const CV_COMP_CHISQR', '1', [], [], None, ''],
        ['const CV_COMP_INTERSECT', '2', [], [], None, ''],
        ['const CV_COMP_BHATTACHARYYA', '3', [], [], None, ''],
        ['const CV_COMP_HELLINGER', 'CV_COMP_BHATTACHARYYA', [], [], None, ''],
        ['const CV_COMP_CHISQR_ALT', '4', [], [], None, ''],
        ['const CV_COMP_KL_DIV', '5', [], [], None, '']],
    None]
ok: CONST CV_COMP_CORREL=0
ok: CONST CV_COMP_CHISQR=1
ok: CONST CV_COMP_INTERSECT=2
ok: CONST CV_COMP_BHATTACHARYYA=3
ok: CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA
ok: CONST CV_COMP_CHISQR_ALT=4
ok: CONST CV_COMP_KL_DIV=5

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_DIST_MASK_3', '3', [], [], None, ''],
        ['const CV_DIST_MASK_5', '5', [], [], None, ''],
        ['const CV_DIST_MASK_PRECISE', '0', [], [], None, '']],
    None]
ok: CONST CV_DIST_MASK_3=3
ok: CONST CV_DIST_MASK_5=5
ok: CONST CV_DIST_MASK_PRECISE=0

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_DIST_LABEL_CCOMP', '0', [], [], None, ''],
        ['const CV_DIST_LABEL_PIXEL', '1', [], [], None, '']],
    None]
ok: CONST CV_DIST_LABEL_CCOMP=0
ok: CONST CV_DIST_LABEL_PIXEL=1

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_DIST_USER', '-1', [], [], None, ''],
        ['const CV_DIST_L1', '1', [], [], None, ''],
        ['const CV_DIST_L2', '2', [], [], None, ''],
        ['const CV_DIST_C', '3', [], [], None, ''],
        ['const CV_DIST_L12', '4', [], [], None, ''],
        ['const CV_DIST_FAIR', '5', [], [], None, ''],
        ['const CV_DIST_WELSCH', '6', [], [], None, ''],
        ['const CV_DIST_HUBER', '7', [], [], None, '']],
    None]
ok: CONST CV_DIST_USER=-1
ok: CONST CV_DIST_L1=1
ok: CONST CV_DIST_L2=2
ok: CONST CV_DIST_C=3
ok: CONST CV_DIST_L12=4
ok: CONST CV_DIST_FAIR=5
ok: CONST CV_DIST_WELSCH=6
ok: CONST CV_DIST_HUBER=7

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_THRESH_BINARY', '0', [], [], None, ''],
        ['const CV_THRESH_BINARY_INV', '1', [], [], None, ''],
        ['const CV_THRESH_TRUNC', '2', [], [], None, ''],
        ['const CV_THRESH_TOZERO', '3', [], [], None, ''],
        ['const CV_THRESH_TOZERO_INV', '4', [], [], None, ''],
        ['const CV_THRESH_MASK', '7', [], [], None, ''],
        ['const CV_THRESH_OTSU', '8', [], [], None, ''],
        ['const CV_THRESH_TRIANGLE', '16', [], [], None, '']],
    None]
ok: CONST CV_THRESH_BINARY=0
ok: CONST CV_THRESH_BINARY_INV=1
ok: CONST CV_THRESH_TRUNC=2
ok: CONST CV_THRESH_TOZERO=3
ok: CONST CV_THRESH_TOZERO_INV=4
ok: CONST CV_THRESH_MASK=7
ok: CONST CV_THRESH_OTSU=8
ok: CONST CV_THRESH_TRIANGLE=16

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_ADAPTIVE_THRESH_MEAN_C', '0', [], [], None, ''],
        ['const CV_ADAPTIVE_THRESH_GAUSSIAN_C', '1', [], [], None, '']],
    None]
ignored: CONST CV_ADAPTIVE_THRESH_MEAN_C=0
ignored: CONST CV_ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_FLOODFILL_FIXED_RANGE', '(1 << 16)', [], [], None, ''],
        ['const CV_FLOODFILL_MASK_ONLY', '(1 << 17)', [], [], None, '']],
    None]
ignored: CONST CV_FLOODFILL_FIXED_RANGE=(1 << 16)
ignored: CONST CV_FLOODFILL_MASK_ONLY=(1 << 17)

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [['const CV_CANNY_L2_GRADIENT', '(1 << 31)', [], [], None, '']],
    None]
ok: CONST CV_CANNY_L2_GRADIENT=(1 << 31)

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_HOUGH_STANDARD', '0', [], [], None, ''],
        ['const CV_HOUGH_PROBABILISTIC', '1', [], [], None, ''],
        ['const CV_HOUGH_MULTI_SCALE', '2', [], [], None, ''],
        ['const CV_HOUGH_GRADIENT', '3', [], [], None, '']],
    None]
ok: CONST CV_HOUGH_STANDARD=0
ok: CONST CV_HOUGH_PROBABILISTIC=1
ok: CONST CV_HOUGH_MULTI_SCALE=2
ok: CONST CV_HOUGH_GRADIENT=3


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc_c.h =====
Namespaces: ['']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc_c.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/interface.h =====
Namespaces: ['']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/interface.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc.hpp =====
Namespaces: ['', 'cv']

--- Incoming ---
[   'enum cv.SpecialFilter',
    '',
    [],
    [['const cv.FILTER_SCHARR', '-1', [], [], None, '']],
    None]
ok: CONST FILTER_SCHARR=-1

--- Incoming ---
[   'enum cv.MorphTypes',
    '',
    [],
    [   ['const cv.MORPH_ERODE', '0', [], [], None, ''],
        ['const cv.MORPH_DILATE', '1', [], [], None, ''],
        ['const cv.MORPH_OPEN', '2', [], [], None, ''],
        ['const cv.MORPH_CLOSE', '3', [], [], None, ''],
        ['const cv.MORPH_GRADIENT', '4', [], [], None, ''],
        ['const cv.MORPH_TOPHAT', '5', [], [], None, ''],
        ['const cv.MORPH_BLACKHAT', '6', [], [], None, ''],
        ['const cv.MORPH_HITMISS', '7', [], [], None, '']],
    None]
ok: CONST MORPH_ERODE=0
ok: CONST MORPH_DILATE=1
ok: CONST MORPH_OPEN=2
ok: CONST MORPH_CLOSE=3
ok: CONST MORPH_GRADIENT=4
ok: CONST MORPH_TOPHAT=5
ok: CONST MORPH_BLACKHAT=6
ok: CONST MORPH_HITMISS=7

--- Incoming ---
[   'enum cv.MorphShapes',
    '',
    [],
    [   ['const cv.MORPH_RECT', '0', [], [], None, ''],
        ['const cv.MORPH_CROSS', '1', [], [], None, ''],
        ['const cv.MORPH_ELLIPSE', '2', [], [], None, '']],
    None]
ok: CONST MORPH_RECT=0
ok: CONST MORPH_CROSS=1
ok: CONST MORPH_ELLIPSE=2

--- Incoming ---
[   'enum cv.InterpolationFlags',
    '',
    [],
    [   ['const cv.INTER_NEAREST', '0', [], [], None, ''],
        ['const cv.INTER_LINEAR', '1', [], [], None, ''],
        ['const cv.INTER_CUBIC', '2', [], [], None, ''],
        ['const cv.INTER_AREA', '3', [], [], None, ''],
        ['const cv.INTER_LANCZOS4', '4', [], [], None, ''],
        ['const cv.INTER_LINEAR_EXACT', '5', [], [], None, ''],
        ['const cv.INTER_NEAREST_EXACT', '6', [], [], None, ''],
        ['const cv.INTER_MAX', '7', [], [], None, ''],
        ['const cv.WARP_FILL_OUTLIERS', '8', [], [], None, ''],
        ['const cv.WARP_INVERSE_MAP', '16', [], [], None, '']],
    None]
ok: CONST INTER_NEAREST=0
ok: CONST INTER_LINEAR=1
ok: CONST INTER_CUBIC=2
ok: CONST INTER_AREA=3
ok: CONST INTER_LANCZOS4=4
ok: CONST INTER_LINEAR_EXACT=5
ok: CONST INTER_NEAREST_EXACT=6
ok: CONST INTER_MAX=7
ok: CONST WARP_FILL_OUTLIERS=8
ok: CONST WARP_INVERSE_MAP=16

--- Incoming ---
[   'enum cv.WarpPolarMode',
    '',
    [],
    [   ['const cv.WARP_POLAR_LINEAR', '0', [], [], None, ''],
        ['const cv.WARP_POLAR_LOG', '256', [], [], None, '']],
    None]
ok: CONST WARP_POLAR_LINEAR=0
ok: CONST WARP_POLAR_LOG=256

--- Incoming ---
[   'enum cv.InterpolationMasks',
    '',
    [],
    [   ['const cv.INTER_BITS', '5', [], [], None, ''],
        ['const cv.INTER_BITS2', 'INTER_BITS * 2', [], [], None, ''],
        ['const cv.INTER_TAB_SIZE', '1 << INTER_BITS', [], [], None, ''],
        [   'const cv.INTER_TAB_SIZE2',
            'INTER_TAB_SIZE * INTER_TAB_SIZE',
            [],
            [],
            None,
            '']],
    None]
ok: CONST INTER_BITS=5
ok: CONST INTER_BITS2=INTER_BITS * 2
ok: CONST INTER_TAB_SIZE=1 << INTER_BITS
ok: CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE

--- Incoming ---
[   'enum cv.DistanceTypes',
    '',
    [],
    [   ['const cv.DIST_USER', '-1', [], [], None, ''],
        ['const cv.DIST_L1', '1', [], [], None, ''],
        ['const cv.DIST_L2', '2', [], [], None, ''],
        ['const cv.DIST_C', '3', [], [], None, ''],
        ['const cv.DIST_L12', '4', [], [], None, ''],
        ['const cv.DIST_FAIR', '5', [], [], None, ''],
        ['const cv.DIST_WELSCH', '6', [], [], None, ''],
        ['const cv.DIST_HUBER', '7', [], [], None, '']],
    None]
ok: CONST DIST_USER=-1
ok: CONST DIST_L1=1
ok: CONST DIST_L2=2
ok: CONST DIST_C=3
ok: CONST DIST_L12=4
ok: CONST DIST_FAIR=5
ok: CONST DIST_WELSCH=6
ok: CONST DIST_HUBER=7

--- Incoming ---
[   'enum cv.DistanceTransformMasks',
    '',
    [],
    [   ['const cv.DIST_MASK_3', '3', [], [], None, ''],
        ['const cv.DIST_MASK_5', '5', [], [], None, ''],
        ['const cv.DIST_MASK_PRECISE', '0', [], [], None, '']],
    None]
ok: CONST DIST_MASK_3=3
ok: CONST DIST_MASK_5=5
ok: CONST DIST_MASK_PRECISE=0

--- Incoming ---
[   'enum cv.ThresholdTypes',
    '',
    [],
    [   ['const cv.THRESH_BINARY', '0', [], [], None, ''],
        ['const cv.THRESH_BINARY_INV', '1', [], [], None, ''],
        ['const cv.THRESH_TRUNC', '2', [], [], None, ''],
        ['const cv.THRESH_TOZERO', '3', [], [], None, ''],
        ['const cv.THRESH_TOZERO_INV', '4', [], [], None, ''],
        ['const cv.THRESH_MASK', '7', [], [], None, ''],
        ['const cv.THRESH_OTSU', '8', [], [], None, ''],
        ['const cv.THRESH_TRIANGLE', '16', [], [], None, '']],
    None]
ok: CONST THRESH_BINARY=0
ok: CONST THRESH_BINARY_INV=1
ok: CONST THRESH_TRUNC=2
ok: CONST THRESH_TOZERO=3
ok: CONST THRESH_TOZERO_INV=4
ok: CONST THRESH_MASK=7
ok: CONST THRESH_OTSU=8
ok: CONST THRESH_TRIANGLE=16

--- Incoming ---
[   'enum cv.AdaptiveThresholdTypes',
    '',
    [],
    [   ['const cv.ADAPTIVE_THRESH_MEAN_C', '0', [], [], None, ''],
        ['const cv.ADAPTIVE_THRESH_GAUSSIAN_C', '1', [], [], None, '']],
    None]
ok: CONST ADAPTIVE_THRESH_MEAN_C=0
ok: CONST ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   'enum cv.GrabCutClasses',
    '',
    [],
    [   ['const cv.GC_BGD', '0', [], [], None, ''],
        ['const cv.GC_FGD', '1', [], [], None, ''],
        ['const cv.GC_PR_BGD', '2', [], [], None, ''],
        ['const cv.GC_PR_FGD', '3', [], [], None, '']],
    None]
ok: CONST GC_BGD=0
ok: CONST GC_FGD=1
ok: CONST GC_PR_BGD=2
ok: CONST GC_PR_FGD=3

--- Incoming ---
[   'enum cv.GrabCutModes',
    '',
    [],
    [   ['const cv.GC_INIT_WITH_RECT', '0', [], [], None, ''],
        ['const cv.GC_INIT_WITH_MASK', '1', [], [], None, ''],
        ['const cv.GC_EVAL', '2', [], [], None, ''],
        ['const cv.GC_EVAL_FREEZE_MODEL', '3', [], [], None, '']],
    None]
ok: CONST GC_INIT_WITH_RECT=0
ok: CONST GC_INIT_WITH_MASK=1
ok: CONST GC_EVAL=2
ok: CONST GC_EVAL_FREEZE_MODEL=3

--- Incoming ---
[   'enum cv.DistanceTransformLabelTypes',
    '',
    [],
    [   ['const cv.DIST_LABEL_CCOMP', '0', [], [], None, ''],
        ['const cv.DIST_LABEL_PIXEL', '1', [], [], None, '']],
    None]
ok: CONST DIST_LABEL_CCOMP=0
ok: CONST DIST_LABEL_PIXEL=1

--- Incoming ---
[   'enum cv.FloodFillFlags',
    '',
    [],
    [   ['const cv.FLOODFILL_FIXED_RANGE', '1 << 16', [], [], None, ''],
        ['const cv.FLOODFILL_MASK_ONLY', '1 << 17', [], [], None, '']],
    None]
ok: CONST FLOODFILL_FIXED_RANGE=1 << 16
ok: CONST FLOODFILL_MASK_ONLY=1 << 17

--- Incoming ---
[   'enum cv.ConnectedComponentsTypes',
    '',
    [],
    [   ['const cv.CC_STAT_LEFT', '0', [], [], None, ''],
        ['const cv.CC_STAT_TOP', '1', [], [], None, ''],
        ['const cv.CC_STAT_WIDTH', '2', [], [], None, ''],
        ['const cv.CC_STAT_HEIGHT', '3', [], [], None, ''],
        ['const cv.CC_STAT_AREA', '4', [], [], None, ''],
        ['const cv.CC_STAT_MAX', '5', [], [], None, '']],
    None]
ok: CONST CC_STAT_LEFT=0
ok: CONST CC_STAT_TOP=1
ok: CONST CC_STAT_WIDTH=2
ok: CONST CC_STAT_HEIGHT=3
ok: CONST CC_STAT_AREA=4
ok: CONST CC_STAT_MAX=5

--- Incoming ---
[   'enum cv.ConnectedComponentsAlgorithmsTypes',
    '',
    [],
    [   ['const cv.CCL_DEFAULT', '-1', [], [], None, ''],
        ['const cv.CCL_WU', '0', [], [], None, ''],
        ['const cv.CCL_GRANA', '1', [], [], None, ''],
        ['const cv.CCL_BOLELLI', '2', [], [], None, ''],
        ['const cv.CCL_SAUF', '3', [], [], None, ''],
        ['const cv.CCL_BBDT', '4', [], [], None, ''],
        ['const cv.CCL_SPAGHETTI', '5', [], [], None, '']],
    None]
ok: CONST CCL_DEFAULT=-1
ok: CONST CCL_WU=0
ok: CONST CCL_GRANA=1
ok: CONST CCL_BOLELLI=2
ok: CONST CCL_SAUF=3
ok: CONST CCL_BBDT=4
ok: CONST CCL_SPAGHETTI=5

--- Incoming ---
[   'enum cv.RetrievalModes',
    '',
    [],
    [   ['const cv.RETR_EXTERNAL', '0', [], [], None, ''],
        ['const cv.RETR_LIST', '1', [], [], None, ''],
        ['const cv.RETR_CCOMP', '2', [], [], None, ''],
        ['const cv.RETR_TREE', '3', [], [], None, ''],
        ['const cv.RETR_FLOODFILL', '4', [], [], None, '']],
    None]
ok: CONST RETR_EXTERNAL=0
ok: CONST RETR_LIST=1
ok: CONST RETR_CCOMP=2
ok: CONST RETR_TREE=3
ok: CONST RETR_FLOODFILL=4

--- Incoming ---
[   'enum cv.ContourApproximationModes',
    '',
    [],
    [   ['const cv.CHAIN_APPROX_NONE', '1', [], [], None, ''],
        ['const cv.CHAIN_APPROX_SIMPLE', '2', [], [], None, ''],
        ['const cv.CHAIN_APPROX_TC89_L1', '3', [], [], None, ''],
        ['const cv.CHAIN_APPROX_TC89_KCOS', '4', [], [], None, '']],
    None]
ok: CONST CHAIN_APPROX_NONE=1
ok: CONST CHAIN_APPROX_SIMPLE=2
ok: CONST CHAIN_APPROX_TC89_L1=3
ok: CONST CHAIN_APPROX_TC89_KCOS=4

--- Incoming ---
[   'enum cv.ShapeMatchModes',
    '',
    [],
    [   ['const cv.CONTOURS_MATCH_I1', '1', [], [], None, ''],
        ['const cv.CONTOURS_MATCH_I2', '2', [], [], None, ''],
        ['const cv.CONTOURS_MATCH_I3', '3', [], [], None, '']],
    None]
ok: CONST CONTOURS_MATCH_I1=1
ok: CONST CONTOURS_MATCH_I2=2
ok: CONST CONTOURS_MATCH_I3=3

--- Incoming ---
[   'enum cv.HoughModes',
    '',
    [],
    [   ['const cv.HOUGH_STANDARD', '0', [], [], None, ''],
        ['const cv.HOUGH_PROBABILISTIC', '1', [], [], None, ''],
        ['const cv.HOUGH_MULTI_SCALE', '2', [], [], None, ''],
        ['const cv.HOUGH_GRADIENT', '3', [], [], None, ''],
        ['const cv.HOUGH_GRADIENT_ALT', '4', [], [], None, '']],
    None]
ok: CONST HOUGH_STANDARD=0
ok: CONST HOUGH_PROBABILISTIC=1
ok: CONST HOUGH_MULTI_SCALE=2
ok: CONST HOUGH_GRADIENT=3
ok: CONST HOUGH_GRADIENT_ALT=4

--- Incoming ---
[   'enum cv.LineSegmentDetectorModes',
    '',
    [],
    [   ['const cv.LSD_REFINE_NONE', '0', [], [], None, ''],
        ['const cv.LSD_REFINE_STD', '1', [], [], None, ''],
        ['const cv.LSD_REFINE_ADV', '2', [], [], None, '']],
    None]
ok: CONST LSD_REFINE_NONE=0
ok: CONST LSD_REFINE_STD=1
ok: CONST LSD_REFINE_ADV=2

--- Incoming ---
[   'enum cv.HistCompMethods',
    '',
    [],
    [   ['const cv.HISTCMP_CORREL', '0', [], [], None, ''],
        ['const cv.HISTCMP_CHISQR', '1', [], [], None, ''],
        ['const cv.HISTCMP_INTERSECT', '2', [], [], None, ''],
        ['const cv.HISTCMP_BHATTACHARYYA', '3', [], [], None, ''],
        [   'const cv.HISTCMP_HELLINGER',
            'HISTCMP_BHATTACHARYYA',
            [],
            [],
            None,
            ''],
        ['const cv.HISTCMP_CHISQR_ALT', '4', [], [], None, ''],
        ['const cv.HISTCMP_KL_DIV', '5', [], [], None, '']],
    None]
ok: CONST HISTCMP_CORREL=0
ok: CONST HISTCMP_CHISQR=1
ok: CONST HISTCMP_INTERSECT=2
ok: CONST HISTCMP_BHATTACHARYYA=3
ok: CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA
ok: CONST HISTCMP_CHISQR_ALT=4
ok: CONST HISTCMP_KL_DIV=5

--- Incoming ---
[   'enum cv.ColorConversionCodes',
    '',
    [],
    [   ['const cv.COLOR_BGR2BGRA', '0', [], [], None, ''],
        ['const cv.COLOR_RGB2RGBA', 'COLOR_BGR2BGRA', [], [], None, ''],
        ['const cv.COLOR_BGRA2BGR', '1', [], [], None, ''],
        ['const cv.COLOR_RGBA2RGB', 'COLOR_BGRA2BGR', [], [], None, ''],
        ['const cv.COLOR_BGR2RGBA', '2', [], [], None, ''],
        ['const cv.COLOR_RGB2BGRA', 'COLOR_BGR2RGBA', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR', '3', [], [], None, ''],
        ['const cv.COLOR_BGRA2RGB', 'COLOR_RGBA2BGR', [], [], None, ''],
        ['const cv.COLOR_BGR2RGB', '4', [], [], None, ''],
        ['const cv.COLOR_RGB2BGR', 'COLOR_BGR2RGB', [], [], None, ''],
        ['const cv.COLOR_BGRA2RGBA', '5', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGRA', 'COLOR_BGRA2RGBA', [], [], None, ''],
        ['const cv.COLOR_BGR2GRAY', '6', [], [], None, ''],
        ['const cv.COLOR_RGB2GRAY', '7', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGR', '8', [], [], None, ''],
        ['const cv.COLOR_GRAY2RGB', 'COLOR_GRAY2BGR', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGRA', '9', [], [], None, ''],
        ['const cv.COLOR_GRAY2RGBA', 'COLOR_GRAY2BGRA', [], [], None, ''],
        ['const cv.COLOR_BGRA2GRAY', '10', [], [], None, ''],
        ['const cv.COLOR_RGBA2GRAY', '11', [], [], None, ''],
        ['const cv.COLOR_BGR2BGR565', '12', [], [], None, ''],
        ['const cv.COLOR_RGB2BGR565', '13', [], [], None, ''],
        ['const cv.COLOR_BGR5652BGR', '14', [], [], None, ''],
        ['const cv.COLOR_BGR5652RGB', '15', [], [], None, ''],
        ['const cv.COLOR_BGRA2BGR565', '16', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR565', '17', [], [], None, ''],
        ['const cv.COLOR_BGR5652BGRA', '18', [], [], None, ''],
        ['const cv.COLOR_BGR5652RGBA', '19', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGR565', '20', [], [], None, ''],
        ['const cv.COLOR_BGR5652GRAY', '21', [], [], None, ''],
        ['const cv.COLOR_BGR2BGR555', '22', [], [], None, ''],
        ['const cv.COLOR_RGB2BGR555', '23', [], [], None, ''],
        ['const cv.COLOR_BGR5552BGR', '24', [], [], None, ''],
        ['const cv.COLOR_BGR5552RGB', '25', [], [], None, ''],
        ['const cv.COLOR_BGRA2BGR555', '26', [], [], None, ''],
        ['const cv.COLOR_RGBA2BGR555', '27', [], [], None, ''],
        ['const cv.COLOR_BGR5552BGRA', '28', [], [], None, ''],
        ['const cv.COLOR_BGR5552RGBA', '29', [], [], None, ''],
        ['const cv.COLOR_GRAY2BGR555', '30', [], [], None, ''],
        ['const cv.COLOR_BGR5552GRAY', '31', [], [], None, ''],
        ['const cv.COLOR_BGR2XYZ', '32', [], [], None, ''],
        ['const cv.COLOR_RGB2XYZ', '33', [], [], None, ''],
        ['const cv.COLOR_XYZ2BGR', '34', [], [], None, ''],
        ['const cv.COLOR_XYZ2RGB', '35', [], [], None, ''],
        ['const cv.COLOR_BGR2YCrCb', '36', [], [], None, ''],
        ['const cv.COLOR_RGB2YCrCb', '37', [], [], None, ''],
        ['const cv.COLOR_YCrCb2BGR', '38', [], [], None, ''],
        ['const cv.COLOR_YCrCb2RGB', '39', [], [], None, ''],
        ['const cv.COLOR_BGR2HSV', '40', [], [], None, ''],
        ['const cv.COLOR_RGB2HSV', '41', [], [], None, ''],
        ['const cv.COLOR_BGR2Lab', '44', [], [], None, ''],
        ['const cv.COLOR_RGB2Lab', '45', [], [], None, ''],
        ['const cv.COLOR_BGR2Luv', '50', [], [], None, ''],
        ['const cv.COLOR_RGB2Luv', '51', [], [], None, ''],
        ['const cv.COLOR_BGR2HLS', '52', [], [], None, ''],
        ['const cv.COLOR_RGB2HLS', '53', [], [], None, ''],
        ['const cv.COLOR_HSV2BGR', '54', [], [], None, ''],
        ['const cv.COLOR_HSV2RGB', '55', [], [], None, ''],
        ['const cv.COLOR_Lab2BGR', '56', [], [], None, ''],
        ['const cv.COLOR_Lab2RGB', '57', [], [], None, ''],
        ['const cv.COLOR_Luv2BGR', '58', [], [], None, ''],
        ['const cv.COLOR_Luv2RGB', '59', [], [], None, ''],
        ['const cv.COLOR_HLS2BGR', '60', [], [], None, ''],
        ['const cv.COLOR_HLS2RGB', '61', [], [], None, ''],
        ['const cv.COLOR_BGR2HSV_FULL', '66', [], [], None, ''],
        ['const cv.COLOR_RGB2HSV_FULL', '67', [], [], None, ''],
        ['const cv.COLOR_BGR2HLS_FULL', '68', [], [], None, ''],
        ['const cv.COLOR_RGB2HLS_FULL', '69', [], [], None, ''],
        ['const cv.COLOR_HSV2BGR_FULL', '70', [], [], None, ''],
        ['const cv.COLOR_HSV2RGB_FULL', '71', [], [], None, ''],
        ['const cv.COLOR_HLS2BGR_FULL', '72', [], [], None, ''],
        ['const cv.COLOR_HLS2RGB_FULL', '73', [], [], None, ''],
        ['const cv.COLOR_LBGR2Lab', '74', [], [], None, ''],
        ['const cv.COLOR_LRGB2Lab', '75', [], [], None, ''],
        ['const cv.COLOR_LBGR2Luv', '76', [], [], None, ''],
        ['const cv.COLOR_LRGB2Luv', '77', [], [], None, ''],
        ['const cv.COLOR_Lab2LBGR', '78', [], [], None, ''],
        ['const cv.COLOR_Lab2LRGB', '79', [], [], None, ''],
        ['const cv.COLOR_Luv2LBGR', '80', [], [], None, ''],
        ['const cv.COLOR_Luv2LRGB', '81', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV', '82', [], [], None, ''],
        ['const cv.COLOR_RGB2YUV', '83', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR', '84', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB', '85', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_NV12', '90', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_NV12', '91', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_NV21', '92', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_NV21', '93', [], [], None, ''],
        ['const cv.COLOR_YUV420sp2RGB', 'COLOR_YUV2RGB_NV21', [], [], None, ''],
        ['const cv.COLOR_YUV420sp2BGR', 'COLOR_YUV2BGR_NV21', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_NV12', '94', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_NV12', '95', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_NV21', '96', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_NV21', '97', [], [], None, ''],
        [   'const cv.COLOR_YUV420sp2RGBA',
            'COLOR_YUV2RGBA_NV21',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420sp2BGRA',
            'COLOR_YUV2BGRA_NV21',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2RGB_YV12', '98', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YV12', '99', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_IYUV', '100', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_IYUV', '101', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_I420', 'COLOR_YUV2RGB_IYUV', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_I420', 'COLOR_YUV2BGR_IYUV', [], [], None, ''],
        ['const cv.COLOR_YUV420p2RGB', 'COLOR_YUV2RGB_YV12', [], [], None, ''],
        ['const cv.COLOR_YUV420p2BGR', 'COLOR_YUV2BGR_YV12', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YV12', '102', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YV12', '103', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_IYUV', '104', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_IYUV', '105', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_I420',
            'COLOR_YUV2RGBA_IYUV',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_I420',
            'COLOR_YUV2BGRA_IYUV',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420p2RGBA',
            'COLOR_YUV2RGBA_YV12',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420p2BGRA',
            'COLOR_YUV2BGRA_YV12',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2GRAY_420', '106', [], [], None, ''],
        [   'const cv.COLOR_YUV2GRAY_NV21',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_NV12',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YV12',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_IYUV',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_I420',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV420sp2GRAY',
            'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV420p2GRAY', 'COLOR_YUV2GRAY_420', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_UYVY', '107', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_UYVY', '108', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_Y422', 'COLOR_YUV2RGB_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_Y422', 'COLOR_YUV2BGR_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_UYNV', 'COLOR_YUV2RGB_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_UYNV', 'COLOR_YUV2BGR_UYVY', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_UYVY', '111', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_UYVY', '112', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_Y422',
            'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_Y422',
            'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2RGBA_UYNV',
            'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_UYNV',
            'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2RGB_YUY2', '115', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUY2', '116', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YVYU', '117', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YVYU', '118', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YUYV', 'COLOR_YUV2RGB_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUYV', 'COLOR_YUV2BGR_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2RGB_YUNV', 'COLOR_YUV2RGB_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2BGR_YUNV', 'COLOR_YUV2BGR_YUY2', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YUY2', '119', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YUY2', '120', [], [], None, ''],
        ['const cv.COLOR_YUV2RGBA_YVYU', '121', [], [], None, ''],
        ['const cv.COLOR_YUV2BGRA_YVYU', '122', [], [], None, ''],
        [   'const cv.COLOR_YUV2RGBA_YUYV',
            'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_YUYV',
            'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2RGBA_YUNV',
            'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2BGRA_YUNV',
            'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_YUV2GRAY_UYVY', '123', [], [], None, ''],
        ['const cv.COLOR_YUV2GRAY_YUY2', '124', [], [], None, ''],
        [   'const cv.COLOR_YUV2GRAY_Y422',
            'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_UYNV',
            'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YVYU',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YUYV',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_YUV2GRAY_YUNV',
            'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_RGBA2mRGBA', '125', [], [], None, ''],
        ['const cv.COLOR_mRGBA2RGBA', '126', [], [], None, ''],
        ['const cv.COLOR_RGB2YUV_I420', '127', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_I420', '128', [], [], None, ''],
        ['const cv.COLOR_RGB2YUV_IYUV', 'COLOR_RGB2YUV_I420', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_IYUV', 'COLOR_BGR2YUV_I420', [], [], None, ''],
        ['const cv.COLOR_RGBA2YUV_I420', '129', [], [], None, ''],
        ['const cv.COLOR_BGRA2YUV_I420', '130', [], [], None, ''],
        [   'const cv.COLOR_RGBA2YUV_IYUV',
            'COLOR_RGBA2YUV_I420',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BGRA2YUV_IYUV',
            'COLOR_BGRA2YUV_I420',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_RGB2YUV_YV12', '131', [], [], None, ''],
        ['const cv.COLOR_BGR2YUV_YV12', '132', [], [], None, ''],
        ['const cv.COLOR_RGBA2YUV_YV12', '133', [], [], None, ''],
        ['const cv.COLOR_BGRA2YUV_YV12', '134', [], [], None, ''],
        ['const cv.COLOR_BayerBG2BGR', '46', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR', '47', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR', '48', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR', '49', [], [], None, ''],
        ['const cv.COLOR_BayerRGGB2BGR', 'COLOR_BayerBG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGRBG2BGR', 'COLOR_BayerGB2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerBGGR2BGR', 'COLOR_BayerRG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGBRG2BGR', 'COLOR_BayerGR2BGR', [], [], None, ''],
        [   'const cv.COLOR_BayerRGGB2RGB',
            'COLOR_BayerBGGR2BGR',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2RGB',
            'COLOR_BayerGBRG2BGR',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2RGB',
            'COLOR_BayerRGGB2BGR',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2RGB',
            'COLOR_BayerGRBG2BGR',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2RGB', 'COLOR_BayerRG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGB2RGB', 'COLOR_BayerGR2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerRG2RGB', 'COLOR_BayerBG2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerGR2RGB', 'COLOR_BayerGB2BGR', [], [], None, ''],
        ['const cv.COLOR_BayerBG2GRAY', '86', [], [], None, ''],
        ['const cv.COLOR_BayerGB2GRAY', '87', [], [], None, ''],
        ['const cv.COLOR_BayerRG2GRAY', '88', [], [], None, ''],
        ['const cv.COLOR_BayerGR2GRAY', '89', [], [], None, ''],
        [   'const cv.COLOR_BayerRGGB2GRAY',
            'COLOR_BayerBG2GRAY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2GRAY',
            'COLOR_BayerGB2GRAY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2GRAY',
            'COLOR_BayerRG2GRAY',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2GRAY',
            'COLOR_BayerGR2GRAY',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2BGR_VNG', '62', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR_VNG', '63', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR_VNG', '64', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR_VNG', '65', [], [], None, ''],
        [   'const cv.COLOR_BayerRGGB2BGR_VNG',
            'COLOR_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2BGR_VNG',
            'COLOR_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2BGR_VNG',
            'COLOR_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2BGR_VNG',
            'COLOR_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRGGB2RGB_VNG',
            'COLOR_BayerBGGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2RGB_VNG',
            'COLOR_BayerGBRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2RGB_VNG',
            'COLOR_BayerRGGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2RGB_VNG',
            'COLOR_BayerGRBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBG2RGB_VNG',
            'COLOR_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGB2RGB_VNG',
            'COLOR_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRG2RGB_VNG',
            'COLOR_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGR2RGB_VNG',
            'COLOR_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2BGR_EA', '135', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGR_EA', '136', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGR_EA', '137', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGR_EA', '138', [], [], None, ''],
        [   'const cv.COLOR_BayerRGGB2BGR_EA',
            'COLOR_BayerBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2BGR_EA',
            'COLOR_BayerGB2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2BGR_EA',
            'COLOR_BayerRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2BGR_EA',
            'COLOR_BayerGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRGGB2RGB_EA',
            'COLOR_BayerBGGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2RGB_EA',
            'COLOR_BayerGBRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2RGB_EA',
            'COLOR_BayerRGGB2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2RGB_EA',
            'COLOR_BayerGRBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBG2RGB_EA',
            'COLOR_BayerRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGB2RGB_EA',
            'COLOR_BayerGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRG2RGB_EA',
            'COLOR_BayerBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGR2RGB_EA',
            'COLOR_BayerGB2BGR_EA',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2BGRA', '139', [], [], None, ''],
        ['const cv.COLOR_BayerGB2BGRA', '140', [], [], None, ''],
        ['const cv.COLOR_BayerRG2BGRA', '141', [], [], None, ''],
        ['const cv.COLOR_BayerGR2BGRA', '142', [], [], None, ''],
        [   'const cv.COLOR_BayerRGGB2BGRA',
            'COLOR_BayerBG2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2BGRA',
            'COLOR_BayerGB2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2BGRA',
            'COLOR_BayerRG2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2BGRA',
            'COLOR_BayerGR2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerRGGB2RGBA',
            'COLOR_BayerBGGR2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGRBG2RGBA',
            'COLOR_BayerGBRG2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerBGGR2RGBA',
            'COLOR_BayerRGGB2BGRA',
            [],
            [],
            None,
            ''],
        [   'const cv.COLOR_BayerGBRG2RGBA',
            'COLOR_BayerGRBG2BGRA',
            [],
            [],
            None,
            ''],
        ['const cv.COLOR_BayerBG2RGBA', 'COLOR_BayerRG2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerGB2RGBA', 'COLOR_BayerGR2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerRG2RGBA', 'COLOR_BayerBG2BGRA', [], [], None, ''],
        ['const cv.COLOR_BayerGR2RGBA', 'COLOR_BayerGB2BGRA', [], [], None, ''],
        ['const cv.COLOR_COLORCVT_MAX', '143', [], [], None, '']],
    None]
ok: CONST COLOR_BGR2BGRA=0
ok: CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA
ok: CONST COLOR_BGRA2BGR=1
ok: CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR
ok: CONST COLOR_BGR2RGBA=2
ok: CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA
ok: CONST COLOR_RGBA2BGR=3
ok: CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR
ok: CONST COLOR_BGR2RGB=4
ok: CONST COLOR_RGB2BGR=COLOR_BGR2RGB
ok: CONST COLOR_BGRA2RGBA=5
ok: CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA
ok: CONST COLOR_BGR2GRAY=6
ok: CONST COLOR_RGB2GRAY=7
ok: CONST COLOR_GRAY2BGR=8
ok: CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR
ok: CONST COLOR_GRAY2BGRA=9
ok: CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA
ok: CONST COLOR_BGRA2GRAY=10
ok: CONST COLOR_RGBA2GRAY=11
ok: CONST COLOR_BGR2BGR565=12
ok: CONST COLOR_RGB2BGR565=13
ok: CONST COLOR_BGR5652BGR=14
ok: CONST COLOR_BGR5652RGB=15
ok: CONST COLOR_BGRA2BGR565=16
ok: CONST COLOR_RGBA2BGR565=17
ok: CONST COLOR_BGR5652BGRA=18
ok: CONST COLOR_BGR5652RGBA=19
ok: CONST COLOR_GRAY2BGR565=20
ok: CONST COLOR_BGR5652GRAY=21
ok: CONST COLOR_BGR2BGR555=22
ok: CONST COLOR_RGB2BGR555=23
ok: CONST COLOR_BGR5552BGR=24
ok: CONST COLOR_BGR5552RGB=25
ok: CONST COLOR_BGRA2BGR555=26
ok: CONST COLOR_RGBA2BGR555=27
ok: CONST COLOR_BGR5552BGRA=28
ok: CONST COLOR_BGR5552RGBA=29
ok: CONST COLOR_GRAY2BGR555=30
ok: CONST COLOR_BGR5552GRAY=31
ok: CONST COLOR_BGR2XYZ=32
ok: CONST COLOR_RGB2XYZ=33
ok: CONST COLOR_XYZ2BGR=34
ok: CONST COLOR_XYZ2RGB=35
ok: CONST COLOR_BGR2YCrCb=36
ok: CONST COLOR_RGB2YCrCb=37
ok: CONST COLOR_YCrCb2BGR=38
ok: CONST COLOR_YCrCb2RGB=39
ok: CONST COLOR_BGR2HSV=40
ok: CONST COLOR_RGB2HSV=41
ok: CONST COLOR_BGR2Lab=44
ok: CONST COLOR_RGB2Lab=45
ok: CONST COLOR_BGR2Luv=50
ok: CONST COLOR_RGB2Luv=51
ok: CONST COLOR_BGR2HLS=52
ok: CONST COLOR_RGB2HLS=53
ok: CONST COLOR_HSV2BGR=54
ok: CONST COLOR_HSV2RGB=55
ok: CONST COLOR_Lab2BGR=56
ok: CONST COLOR_Lab2RGB=57
ok: CONST COLOR_Luv2BGR=58
ok: CONST COLOR_Luv2RGB=59
ok: CONST COLOR_HLS2BGR=60
ok: CONST COLOR_HLS2RGB=61
ok: CONST COLOR_BGR2HSV_FULL=66
ok: CONST COLOR_RGB2HSV_FULL=67
ok: CONST COLOR_BGR2HLS_FULL=68
ok: CONST COLOR_RGB2HLS_FULL=69
ok: CONST COLOR_HSV2BGR_FULL=70
ok: CONST COLOR_HSV2RGB_FULL=71
ok: CONST COLOR_HLS2BGR_FULL=72
ok: CONST COLOR_HLS2RGB_FULL=73
ok: CONST COLOR_LBGR2Lab=74
ok: CONST COLOR_LRGB2Lab=75
ok: CONST COLOR_LBGR2Luv=76
ok: CONST COLOR_LRGB2Luv=77
ok: CONST COLOR_Lab2LBGR=78
ok: CONST COLOR_Lab2LRGB=79
ok: CONST COLOR_Luv2LBGR=80
ok: CONST COLOR_Luv2LRGB=81
ok: CONST COLOR_BGR2YUV=82
ok: CONST COLOR_RGB2YUV=83
ok: CONST COLOR_YUV2BGR=84
ok: CONST COLOR_YUV2RGB=85
ok: CONST COLOR_YUV2RGB_NV12=90
ok: CONST COLOR_YUV2BGR_NV12=91
ok: CONST COLOR_YUV2RGB_NV21=92
ok: CONST COLOR_YUV2BGR_NV21=93
ok: CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21
ok: CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21
ok: CONST COLOR_YUV2RGBA_NV12=94
ok: CONST COLOR_YUV2BGRA_NV12=95
ok: CONST COLOR_YUV2RGBA_NV21=96
ok: CONST COLOR_YUV2BGRA_NV21=97
ok: CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21
ok: CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21
ok: CONST COLOR_YUV2RGB_YV12=98
ok: CONST COLOR_YUV2BGR_YV12=99
ok: CONST COLOR_YUV2RGB_IYUV=100
ok: CONST COLOR_YUV2BGR_IYUV=101
ok: CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV
ok: CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV
ok: CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12
ok: CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12
ok: CONST COLOR_YUV2RGBA_YV12=102
ok: CONST COLOR_YUV2BGRA_YV12=103
ok: CONST COLOR_YUV2RGBA_IYUV=104
ok: CONST COLOR_YUV2BGRA_IYUV=105
ok: CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV
ok: CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV
ok: CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12
ok: CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12
ok: CONST COLOR_YUV2GRAY_420=106
ok: CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2RGB_UYVY=107
ok: CONST COLOR_YUV2BGR_UYVY=108
ok: CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGBA_UYVY=111
ok: CONST COLOR_YUV2BGRA_UYVY=112
ok: CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGB_YUY2=115
ok: CONST COLOR_YUV2BGR_YUY2=116
ok: CONST COLOR_YUV2RGB_YVYU=117
ok: CONST COLOR_YUV2BGR_YVYU=118
ok: CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGBA_YUY2=119
ok: CONST COLOR_YUV2BGRA_YUY2=120
ok: CONST COLOR_YUV2RGBA_YVYU=121
ok: CONST COLOR_YUV2BGRA_YVYU=122
ok: CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2GRAY_UYVY=123
ok: CONST COLOR_YUV2GRAY_YUY2=124
ok: CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_RGBA2mRGBA=125
ok: CONST COLOR_mRGBA2RGBA=126
ok: CONST COLOR_RGB2YUV_I420=127
ok: CONST COLOR_BGR2YUV_I420=128
ok: CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420
ok: CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420
ok: CONST COLOR_RGBA2YUV_I420=129
ok: CONST COLOR_BGRA2YUV_I420=130
ok: CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420
ok: CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420
ok: CONST COLOR_RGB2YUV_YV12=131
ok: CONST COLOR_BGR2YUV_YV12=132
ok: CONST COLOR_RGBA2YUV_YV12=133
ok: CONST COLOR_BGRA2YUV_YV12=134
ok: CONST COLOR_BayerBG2BGR=46
ok: CONST COLOR_BayerGB2BGR=47
ok: CONST COLOR_BayerRG2BGR=48
ok: CONST COLOR_BayerGR2BGR=49
ok: CONST COLOR_BayerRGGB2BGR=COLOR_BayerBG2BGR
ok: CONST COLOR_BayerGRBG2BGR=COLOR_BayerGB2BGR
ok: CONST COLOR_BayerBGGR2BGR=COLOR_BayerRG2BGR
ok: CONST COLOR_BayerGBRG2BGR=COLOR_BayerGR2BGR
ok: CONST COLOR_BayerRGGB2RGB=COLOR_BayerBGGR2BGR
ok: CONST COLOR_BayerGRBG2RGB=COLOR_BayerGBRG2BGR
ok: CONST COLOR_BayerBGGR2RGB=COLOR_BayerRGGB2BGR
ok: CONST COLOR_BayerGBRG2RGB=COLOR_BayerGRBG2BGR
ok: CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR
ok: CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR
ok: CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR
ok: CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR
ok: CONST COLOR_BayerBG2GRAY=86
ok: CONST COLOR_BayerGB2GRAY=87
ok: CONST COLOR_BayerRG2GRAY=88
ok: CONST COLOR_BayerGR2GRAY=89
ok: CONST COLOR_BayerRGGB2GRAY=COLOR_BayerBG2GRAY
ok: CONST COLOR_BayerGRBG2GRAY=COLOR_BayerGB2GRAY
ok: CONST COLOR_BayerBGGR2GRAY=COLOR_BayerRG2GRAY
ok: CONST COLOR_BayerGBRG2GRAY=COLOR_BayerGR2GRAY
ok: CONST COLOR_BayerBG2BGR_VNG=62
ok: CONST COLOR_BayerGB2BGR_VNG=63
ok: CONST COLOR_BayerRG2BGR_VNG=64
ok: CONST COLOR_BayerGR2BGR_VNG=65
ok: CONST COLOR_BayerRGGB2BGR_VNG=COLOR_BayerBG2BGR_VNG
ok: CONST COLOR_BayerGRBG2BGR_VNG=COLOR_BayerGB2BGR_VNG
ok: CONST COLOR_BayerBGGR2BGR_VNG=COLOR_BayerRG2BGR_VNG
ok: CONST COLOR_BayerGBRG2BGR_VNG=COLOR_BayerGR2BGR_VNG
ok: CONST COLOR_BayerRGGB2RGB_VNG=COLOR_BayerBGGR2BGR_VNG
ok: CONST COLOR_BayerGRBG2RGB_VNG=COLOR_BayerGBRG2BGR_VNG
ok: CONST COLOR_BayerBGGR2RGB_VNG=COLOR_BayerRGGB2BGR_VNG
ok: CONST COLOR_BayerGBRG2RGB_VNG=COLOR_BayerGRBG2BGR_VNG
ok: CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG
ok: CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG
ok: CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG
ok: CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG
ok: CONST COLOR_BayerBG2BGR_EA=135
ok: CONST COLOR_BayerGB2BGR_EA=136
ok: CONST COLOR_BayerRG2BGR_EA=137
ok: CONST COLOR_BayerGR2BGR_EA=138
ok: CONST COLOR_BayerRGGB2BGR_EA=COLOR_BayerBG2BGR_EA
ok: CONST COLOR_BayerGRBG2BGR_EA=COLOR_BayerGB2BGR_EA
ok: CONST COLOR_BayerBGGR2BGR_EA=COLOR_BayerRG2BGR_EA
ok: CONST COLOR_BayerGBRG2BGR_EA=COLOR_BayerGR2BGR_EA
ok: CONST COLOR_BayerRGGB2RGB_EA=COLOR_BayerBGGR2BGR_EA
ok: CONST COLOR_BayerGRBG2RGB_EA=COLOR_BayerGBRG2BGR_EA
ok: CONST COLOR_BayerBGGR2RGB_EA=COLOR_BayerRGGB2BGR_EA
ok: CONST COLOR_BayerGBRG2RGB_EA=COLOR_BayerGRBG2BGR_EA
ok: CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA
ok: CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA
ok: CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA
ok: CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA
ok: CONST COLOR_BayerBG2BGRA=139
ok: CONST COLOR_BayerGB2BGRA=140
ok: CONST COLOR_BayerRG2BGRA=141
ok: CONST COLOR_BayerGR2BGRA=142
ok: CONST COLOR_BayerRGGB2BGRA=COLOR_BayerBG2BGRA
ok: CONST COLOR_BayerGRBG2BGRA=COLOR_BayerGB2BGRA
ok: CONST COLOR_BayerBGGR2BGRA=COLOR_BayerRG2BGRA
ok: CONST COLOR_BayerGBRG2BGRA=COLOR_BayerGR2BGRA
ok: CONST COLOR_BayerRGGB2RGBA=COLOR_BayerBGGR2BGRA
ok: CONST COLOR_BayerGRBG2RGBA=COLOR_BayerGBRG2BGRA
ok: CONST COLOR_BayerBGGR2RGBA=COLOR_BayerRGGB2BGRA
ok: CONST COLOR_BayerGBRG2RGBA=COLOR_BayerGRBG2BGRA
ok: CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA
ok: CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA
ok: CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA
ok: CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA
ok: CONST COLOR_COLORCVT_MAX=143

--- Incoming ---
[   'enum cv.RectanglesIntersectTypes',
    '',
    [],
    [   ['const cv.INTERSECT_NONE', '0', [], [], None, ''],
        ['const cv.INTERSECT_PARTIAL', '1', [], [], None, ''],
        ['const cv.INTERSECT_FULL', '2', [], [], None, '']],
    None]
ok: CONST INTERSECT_NONE=0
ok: CONST INTERSECT_PARTIAL=1
ok: CONST INTERSECT_FULL=2

--- Incoming ---
[   'enum cv.LineTypes',
    '',
    [],
    [   ['const cv.FILLED', '-1', [], [], None, ''],
        ['const cv.LINE_4', '4', [], [], None, ''],
        ['const cv.LINE_8', '8', [], [], None, ''],
        ['const cv.LINE_AA', '16', [], [], None, '']],
    None]
ok: CONST FILLED=-1
ok: CONST LINE_4=4
ok: CONST LINE_8=8
ok: CONST LINE_AA=16

--- Incoming ---
[   'enum cv.HersheyFonts',
    '',
    [],
    [   ['const cv.FONT_HERSHEY_SIMPLEX', '0', [], [], None, ''],
        ['const cv.FONT_HERSHEY_PLAIN', '1', [], [], None, ''],
        ['const cv.FONT_HERSHEY_DUPLEX', '2', [], [], None, ''],
        ['const cv.FONT_HERSHEY_COMPLEX', '3', [], [], None, ''],
        ['const cv.FONT_HERSHEY_TRIPLEX', '4', [], [], None, ''],
        ['const cv.FONT_HERSHEY_COMPLEX_SMALL', '5', [], [], None, ''],
        ['const cv.FONT_HERSHEY_SCRIPT_SIMPLEX', '6', [], [], None, ''],
        ['const cv.FONT_HERSHEY_SCRIPT_COMPLEX', '7', [], [], None, ''],
        ['const cv.FONT_ITALIC', '16', [], [], None, '']],
    None]
ok: CONST FONT_HERSHEY_SIMPLEX=0
ok: CONST FONT_HERSHEY_PLAIN=1
ok: CONST FONT_HERSHEY_DUPLEX=2
ok: CONST FONT_HERSHEY_COMPLEX=3
ok: CONST FONT_HERSHEY_TRIPLEX=4
ok: CONST FONT_HERSHEY_COMPLEX_SMALL=5
ok: CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6
ok: CONST FONT_HERSHEY_SCRIPT_COMPLEX=7
ok: CONST FONT_ITALIC=16

--- Incoming ---
[   'enum cv.MarkerTypes',
    '',
    [],
    [   ['const cv.MARKER_CROSS', '0', [], [], None, ''],
        ['const cv.MARKER_TILTED_CROSS', '1', [], [], None, ''],
        ['const cv.MARKER_STAR', '2', [], [], None, ''],
        ['const cv.MARKER_DIAMOND', '3', [], [], None, ''],
        ['const cv.MARKER_SQUARE', '4', [], [], None, ''],
        ['const cv.MARKER_TRIANGLE_UP', '5', [], [], None, ''],
        ['const cv.MARKER_TRIANGLE_DOWN', '6', [], [], None, '']],
    None]
ok: CONST MARKER_CROSS=0
ok: CONST MARKER_TILTED_CROSS=1
ok: CONST MARKER_STAR=2
ok: CONST MARKER_DIAMOND=3
ok: CONST MARKER_SQUARE=4
ok: CONST MARKER_TRIANGLE_UP=5
ok: CONST MARKER_TRIANGLE_DOWN=6

--- Incoming ---
['class cv.GeneralizedHough', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.GeneralizedHough : Algorithm, name: GeneralizedHough, base: Algorithm

--- Incoming ---
[   'cv.GeneralizedHough.setTemplate',
    'void',
    ['/V', '/PV'],
    [['Mat', 'templ', '', []], ['Point', 'templCenter', 'Point(-1, -1)', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   'cv.GeneralizedHough.setTemplate',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'edges', '', []],
        ['Mat', 'dx', '', []],
        ['Mat', 'dy', '', []],
        ['Point', 'templCenter', 'Point(-1, -1)', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   'cv.GeneralizedHough.detect',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'positions', '', ['/O']],
        ['Mat', 'votes', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   'cv.GeneralizedHough.detect',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'edges', '', []],
        ['Mat', 'dx', '', []],
        ['Mat', 'dy', '', []],
        ['Mat', 'positions', '', ['/O']],
        ['Mat', 'votes', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   'cv.GeneralizedHough.setCannyLowThresh',
    'void',
    ['/V', '/PV'],
    [['int', 'cannyLowThresh', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>

--- Incoming ---
['cv.GeneralizedHough.getCannyLowThresh', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GeneralizedHough.getCannyLowThresh []>

--- Incoming ---
[   'cv.GeneralizedHough.setCannyHighThresh',
    'void',
    ['/V', '/PV'],
    [['int', 'cannyHighThresh', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>

--- Incoming ---
[   'cv.GeneralizedHough.getCannyHighThresh',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.GeneralizedHough.getCannyHighThresh []>

--- Incoming ---
[   'cv.GeneralizedHough.setMinDist',
    'void',
    ['/V', '/PV'],
    [['double', 'minDist', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>

--- Incoming ---
['cv.GeneralizedHough.getMinDist', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GeneralizedHough.getMinDist []>

--- Incoming ---
[   'cv.GeneralizedHough.setDp',
    'void',
    ['/V', '/PV'],
    [['double', 'dp', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>

--- Incoming ---
['cv.GeneralizedHough.getDp', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GeneralizedHough.getDp []>

--- Incoming ---
[   'cv.GeneralizedHough.setMaxBufferSize',
    'void',
    ['/V', '/PV'],
    [['int', 'maxBufferSize', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>

--- Incoming ---
['cv.GeneralizedHough.getMaxBufferSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GeneralizedHough.getMaxBufferSize []>

--- Incoming ---
['class cv.GeneralizedHoughBallard', ': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughBallard : GeneralizedHough, name: GeneralizedHoughBallard, base: GeneralizedHough

--- Incoming ---
[   'cv.GeneralizedHoughBallard.setLevels',
    'void',
    ['/V', '/PV'],
    [['int', 'levels', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>

--- Incoming ---
['cv.GeneralizedHoughBallard.getLevels', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getLevels []>

--- Incoming ---
[   'cv.GeneralizedHoughBallard.setVotesThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'votesThreshold', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>

--- Incoming ---
[   'cv.GeneralizedHoughBallard.getVotesThreshold',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>

--- Incoming ---
['class cv.GeneralizedHoughGuil', ': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughGuil : GeneralizedHough, name: GeneralizedHoughGuil, base: GeneralizedHough

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setXi',
    'void',
    ['/V', '/PV'],
    [['double', 'xi', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>

--- Incoming ---
['cv.GeneralizedHoughGuil.getXi', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getXi []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setLevels',
    'void',
    ['/V', '/PV'],
    [['int', 'levels', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>

--- Incoming ---
['cv.GeneralizedHoughGuil.getLevels', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getLevels []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleEpsilon',
    'void',
    ['/V', '/PV'],
    [['double', 'angleEpsilon', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getAngleEpsilon',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMinAngle',
    'void',
    ['/V', '/PV'],
    [['double', 'minAngle', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getMinAngle',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMaxAngle',
    'void',
    ['/V', '/PV'],
    [['double', 'maxAngle', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getMaxAngle',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleStep',
    'void',
    ['/V', '/PV'],
    [['double', 'angleStep', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getAngleStep',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setAngleThresh',
    'void',
    ['/V', '/PV'],
    [['int', 'angleThresh', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getAngleThresh',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMinScale',
    'void',
    ['/V', '/PV'],
    [['double', 'minScale', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getMinScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinScale []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setMaxScale',
    'void',
    ['/V', '/PV'],
    [['double', 'maxScale', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getMaxScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setScaleStep',
    'void',
    ['/V', '/PV'],
    [['double', 'scaleStep', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getScaleStep',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setScaleThresh',
    'void',
    ['/V', '/PV'],
    [['int', 'scaleThresh', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.getScaleThresh',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>

--- Incoming ---
[   'cv.GeneralizedHoughGuil.setPosThresh',
    'void',
    ['/V', '/PV'],
    [['int', 'posThresh', '', []]],
    'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>

--- Incoming ---
['cv.GeneralizedHoughGuil.getPosThresh', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>

--- Incoming ---
['class cv.CLAHE', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CLAHE : Algorithm, name: CLAHE, base: Algorithm

--- Incoming ---
[   'cv.CLAHE.apply',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.CLAHE.setClipLimit',
    'void',
    ['/V', '/PV'],
    [['double', 'clipLimit', '', []]],
    'void']
ok: FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>

--- Incoming ---
['cv.CLAHE.getClipLimit', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.CLAHE.getClipLimit []>

--- Incoming ---
[   'cv.CLAHE.setTilesGridSize',
    'void',
    ['/V', '/PV'],
    [['Size', 'tileGridSize', '', []]],
    'void']
ok: FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>

--- Incoming ---
['cv.CLAHE.getTilesGridSize', 'Size', ['/C', '/V', '/PV'], [], 'Size']
ok: FUNC <Size cv.CLAHE.getTilesGridSize []>

--- Incoming ---
['cv.CLAHE.collectGarbage', 'void', ['/V', '/PV'], [], 'void']
ok: FUNC <void cv.CLAHE.collectGarbage []>

--- Incoming ---
['class cv.Subdiv2D', '', [], [], None]
ok: class CLASS cv::.Subdiv2D : , name: Subdiv2D, base: 

--- Incoming ---
[   'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   ['const cv.Subdiv2D.PTLOC_ERROR', '-2', [], [], None, ''],
        ['const cv.Subdiv2D.PTLOC_OUTSIDE_RECT', '-1', [], [], None, ''],
        ['const cv.Subdiv2D.PTLOC_INSIDE', '0', [], [], None, ''],
        ['const cv.Subdiv2D.PTLOC_VERTEX', '1', [], [], None, ''],
        ['const cv.Subdiv2D.PTLOC_ON_EDGE', '2', [], [], None, '']],
    None]
ok: CONST PTLOC_ERROR=-2
ok: CONST PTLOC_OUTSIDE_RECT=-1
ok: CONST PTLOC_INSIDE=0
ok: CONST PTLOC_VERTEX=1
ok: CONST PTLOC_ON_EDGE=2

--- Incoming ---
[   'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   ['const cv.Subdiv2D.NEXT_AROUND_ORG', '0x00', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_DST', '0x22', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_ORG', '0x11', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_DST', '0x33', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_LEFT', '0x13', [], [], None, ''],
        ['const cv.Subdiv2D.NEXT_AROUND_RIGHT', '0x31', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_LEFT', '0x20', [], [], None, ''],
        ['const cv.Subdiv2D.PREV_AROUND_RIGHT', '0x02', [], [], None, '']],
    None]
ok: CONST NEXT_AROUND_ORG=0x00
ok: CONST NEXT_AROUND_DST=0x22
ok: CONST PREV_AROUND_ORG=0x11
ok: CONST PREV_AROUND_DST=0x33
ok: CONST NEXT_AROUND_LEFT=0x13
ok: CONST NEXT_AROUND_RIGHT=0x31
ok: CONST PREV_AROUND_LEFT=0x20
ok: CONST PREV_AROUND_RIGHT=0x02

--- Incoming ---
['cv.Subdiv2D.Subdiv2D', '', [], [], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D []>

--- Incoming ---
['cv.Subdiv2D.Subdiv2D', '', [], [['Rect', 'rect', '', []]], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>

--- Incoming ---
['cv.Subdiv2D.initDelaunay', 'void', [], [['Rect', 'rect', '', []]], 'void']
ok: FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>

--- Incoming ---
['cv.Subdiv2D.insert', 'int', [], [['Point2f', 'pt', '', []]], 'int']
ok: FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>

--- Incoming ---
[   'cv.Subdiv2D.insert',
    'void',
    [],
    [['vector_Point2f', 'ptvec', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>

--- Incoming ---
[   'cv.Subdiv2D.locate',
    'int',
    [],
    [   ['Point2f', 'pt', '', []],
        ['int', 'edge', '', ['/O', '/Ref']],
        ['int', 'vertex', '', ['/O', '/Ref']]],
    'int']
ok: FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>

--- Incoming ---
[   'cv.Subdiv2D.findNearest',
    'int',
    [],
    [['Point2f', 'pt', '', []], ['Point2f*', 'nearestPt', '0', ['/O']]],
    'int']
ok: FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>

--- Incoming ---
[   'cv.Subdiv2D.getEdgeList',
    'void',
    ['/C'],
    [['vector_Vec4f', 'edgeList', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>

--- Incoming ---
[   'cv.Subdiv2D.getLeadingEdgeList',
    'void',
    ['/C'],
    [['vector_int', 'leadingEdgeList', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>

--- Incoming ---
[   'cv.Subdiv2D.getTriangleList',
    'void',
    ['/C'],
    [['vector_Vec6f', 'triangleList', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>

--- Incoming ---
[   'cv.Subdiv2D.getVoronoiFacetList',
    'void',
    [],
    [   ['vector_int', 'idx', '', ['/C', '/Ref']],
        ['vector_vector_Point2f', 'facetList', '', ['/O', '/Ref']],
        ['vector_Point2f', 'facetCenters', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>

--- Incoming ---
[   'cv.Subdiv2D.getVertex',
    'Point2f',
    ['/C'],
    [['int', 'vertex', '', []], ['int*', 'firstEdge', '0', ['/O']]],
    'Point2f']
ok: FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>

--- Incoming ---
[   'cv.Subdiv2D.getEdge',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['int', 'nextEdgeType', '', []]],
    'int']
ok: FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>

--- Incoming ---
['cv.Subdiv2D.nextEdge', 'int', ['/C'], [['int', 'edge', '', []]], 'int']
ok: FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>

--- Incoming ---
[   'cv.Subdiv2D.rotateEdge',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['int', 'rotate', '', []]],
    'int']
ok: FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>

--- Incoming ---
['cv.Subdiv2D.symEdge', 'int', ['/C'], [['int', 'edge', '', []]], 'int']
ok: FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>

--- Incoming ---
[   'cv.Subdiv2D.edgeOrg',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['Point2f*', 'orgpt', '0', ['/O']]],
    'int']
ok: FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>

--- Incoming ---
[   'cv.Subdiv2D.edgeDst',
    'int',
    ['/C'],
    [['int', 'edge', '', []], ['Point2f*', 'dstpt', '0', ['/O']]],
    'int']
ok: FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>

--- Incoming ---
['class cv.LineSegmentDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.LineSegmentDetector : Algorithm, name: LineSegmentDetector, base: Algorithm

--- Incoming ---
[   'cv.LineSegmentDetector.detect',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'lines', '', ['/O']],
        ['Mat', 'width', 'Mat()', ['/O']],
        ['Mat', 'prec', 'Mat()', ['/O']],
        ['Mat', 'nfa', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.LineSegmentDetector.detect [ARG Mat image=, ARG Mat lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>

--- Incoming ---
[   'cv.LineSegmentDetector.drawSegments',
    'void',
    ['/V', '/PV'],
    [['Mat', 'image', '', ['/IO']], ['Mat', 'lines', '', []]],
    'void']
ok: FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat image=, ARG Mat lines=]>

--- Incoming ---
[   'cv.LineSegmentDetector.compareSegments',
    'int',
    ['/V', '/PV'],
    [   ['Size', 'size', '', ['/C', '/Ref']],
        ['Mat', 'lines1', '', []],
        ['Mat', 'lines2', '', []],
        ['Mat', 'image', 'Mat()', ['/IO']]],
    'int']
ok: FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat image=Mat()]>

--- Incoming ---
[   'cv.createLineSegmentDetector',
    'Ptr_LineSegmentDetector',
    [],
    [   ['int', 'refine', 'LSD_REFINE_STD', []],
        ['double', 'scale', '0.8', []],
        ['double', 'sigma_scale', '0.6', []],
        ['double', 'quant', '2.0', []],
        ['double', 'ang_th', '22.5', []],
        ['double', 'log_eps', '0', []],
        ['double', 'density_th', '0.7', []],
        ['int', 'n_bins', '1024', []]],
    'Ptr<LineSegmentDetector>']
ok: FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int refine=LSD_REFINE_STD, ARG double scale=0.8, ARG double sigma_scale=0.6, ARG double quant=2.0, ARG double ang_th=22.5, ARG double log_eps=0, ARG double density_th=0.7, ARG int n_bins=1024]>

--- Incoming ---
[   'cv.getGaussianKernel',
    'Mat',
    [],
    [   ['int', 'ksize', '', []],
        ['double', 'sigma', '', []],
        ['int', 'ktype', 'CV_64F', []]],
    'Mat']
ok: FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>

--- Incoming ---
[   'cv.getDerivKernels',
    'void',
    [],
    [   ['Mat', 'kx', '', ['/O']],
        ['Mat', 'ky', '', ['/O']],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['int', 'ksize', '', []],
        ['bool', 'normalize', 'false', []],
        ['int', 'ktype', 'CV_32F', []]],
    'void']
ok: FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>

--- Incoming ---
[   'cv.getGaborKernel',
    'Mat',
    [],
    [   ['Size', 'ksize', '', []],
        ['double', 'sigma', '', []],
        ['double', 'theta', '', []],
        ['double', 'lambd', '', []],
        ['double', 'gamma', '', []],
        ['double', 'psi', 'CV_PI*0.5', []],
        ['int', 'ktype', 'CV_64F', []]],
    'Mat']
ok: FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>

--- Incoming ---
[   'cv.getStructuringElement',
    'Mat',
    [],
    [   ['int', 'shape', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []]],
    'Mat']
ok: FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>

--- Incoming ---
[   'cv.medianBlur',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ksize', '', []]],
    'void']
ok: FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>

--- Incoming ---
[   'cv.GaussianBlur',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'ksize', '', []],
        ['double', 'sigmaX', '', []],
        ['double', 'sigmaY', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.bilateralFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'd', '', []],
        ['double', 'sigmaColor', '', []],
        ['double', 'sigmaSpace', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.boxFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['bool', 'normalize', 'true', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.sqrBoxFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1, -1)', []],
        ['bool', 'normalize', 'true', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.blur',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'ksize', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.stackBlur',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'ksize', '', []]],
    'void']
ok: FUNC <void cv..stackBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=]>

--- Incoming ---
[   'cv.filter2D',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['Mat', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.sepFilter2D',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['Mat', 'kernelX', '', []],
        ['Mat', 'kernelY', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.Sobel',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['int', 'ksize', '3', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.spatialGradient',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dx', '', ['/O']],
        ['Mat', 'dy', '', ['/O']],
        ['int', 'ksize', '3', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.Scharr',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['int', 'dx', '', []],
        ['int', 'dy', '', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.Laplacian',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ddepth', '', []],
        ['int', 'ksize', '1', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.Canny',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'edges', '', ['/O']],
        ['double', 'threshold1', '', []],
        ['double', 'threshold2', '', []],
        ['int', 'apertureSize', '3', []],
        ['bool', 'L2gradient', 'false', []]],
    'void']
ok: FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>

--- Incoming ---
[   'cv.Canny',
    'void',
    [],
    [   ['Mat', 'dx', '', []],
        ['Mat', 'dy', '', []],
        ['Mat', 'edges', '', ['/O']],
        ['double', 'threshold1', '', []],
        ['double', 'threshold2', '', []],
        ['bool', 'L2gradient', 'false', []]],
    'void']
ok: FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>

--- Incoming ---
[   'cv.cornerMinEigenVal',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '3', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.cornerHarris',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '', []],
        ['double', 'k', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.cornerEigenValsAndVecs',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'blockSize', '', []],
        ['int', 'ksize', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.preCornerDetect',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'ksize', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.cornerSubPix',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'corners', '', ['/IO']],
        ['Size', 'winSize', '', []],
        ['Size', 'zeroZone', '', []],
        ['TermCriteria', 'criteria', '', []]],
    'void']
ok: FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>

--- Incoming ---
[   'cv.goodFeaturesToTrack',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'corners', '', ['/O']],
        ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['Mat', 'mask', 'Mat()', []],
        ['int', 'blockSize', '3', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   'cv.goodFeaturesToTrack',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'corners', '', ['/O']],
        ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['Mat', 'mask', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'gradientSize', '', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   'cv.goodFeaturesToTrack',
    'void',
    ['=goodFeaturesToTrackWithQuality'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'corners', '', ['/O']],
        ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['Mat', 'mask', '', []],
        ['Mat', 'cornersQuality', '', ['/O']],
        ['int', 'blockSize', '3', []],
        ['int', 'gradientSize', '3', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG Mat corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG Mat cornersQuality=, ARG int blockSize=3, ARG int gradientSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   'cv.HoughLines',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'lines', '', ['/O']],
        ['double', 'rho', '', []],
        ['double', 'theta', '', []],
        ['int', 'threshold', '', []],
        ['double', 'srn', '0', []],
        ['double', 'stn', '0', []],
        ['double', 'min_theta', '0', []],
        ['double', 'max_theta', 'CV_PI', []]],
    'void']
ok: FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>

--- Incoming ---
[   'cv.HoughLinesP',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'lines', '', ['/O']],
        ['double', 'rho', '', []],
        ['double', 'theta', '', []],
        ['int', 'threshold', '', []],
        ['double', 'minLineLength', '0', []],
        ['double', 'maxLineGap', '0', []]],
    'void']
ok: FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>

--- Incoming ---
[   'cv.HoughLinesPointSet',
    'void',
    [],
    [   ['Mat', 'point', '', []],
        ['Mat', 'lines', '', ['/O']],
        ['int', 'lines_max', '', []],
        ['int', 'threshold', '', []],
        ['double', 'min_rho', '', []],
        ['double', 'max_rho', '', []],
        ['double', 'rho_step', '', []],
        ['double', 'min_theta', '', []],
        ['double', 'max_theta', '', []],
        ['double', 'theta_step', '', []]],
    'void']
ok: FUNC <void cv..HoughLinesPointSet [ARG Mat point=, ARG Mat lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>

--- Incoming ---
[   'cv.HoughCircles',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'circles', '', ['/O']],
        ['int', 'method', '', []],
        ['double', 'dp', '', []],
        ['double', 'minDist', '', []],
        ['double', 'param1', '100', []],
        ['double', 'param2', '100', []],
        ['int', 'minRadius', '0', []],
        ['int', 'maxRadius', '0', []]],
    'void']
ok: FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>

--- Incoming ---
[   'cv.erode',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        [   'Scalar',
            'borderValue',
            'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   'cv.dilate',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        [   'Scalar',
            'borderValue',
            'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   'cv.morphologyEx',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'op', '', []],
        ['Mat', 'kernel', '', []],
        ['Point', 'anchor', 'Point(-1,-1)', []],
        ['int', 'iterations', '1', []],
        ['int', 'borderType', 'BORDER_CONSTANT', []],
        [   'Scalar',
            'borderValue',
            'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   'cv.resize',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'dsize', '', []],
        ['double', 'fx', '0', []],
        ['double', 'fy', '0', []],
        ['int', 'interpolation', 'INTER_LINEAR', []]],
    'void']
ok: FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>

--- Incoming ---
[   'cv.warpAffine',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'M', '', []],
        ['Size', 'dsize', '', []],
        ['int', 'flags', 'INTER_LINEAR', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['Scalar', 'borderValue', 'Scalar()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   'cv.warpPerspective',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'M', '', []],
        ['Size', 'dsize', '', []],
        ['int', 'flags', 'INTER_LINEAR', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['Scalar', 'borderValue', 'Scalar()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   'cv.remap',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'map1', '', []],
        ['Mat', 'map2', '', []],
        ['int', 'interpolation', '', []],
        ['int', 'borderMode', 'BORDER_CONSTANT', []],
        ['Scalar', 'borderValue', 'Scalar()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   'cv.convertMaps',
    'void',
    [],
    [   ['Mat', 'map1', '', []],
        ['Mat', 'map2', '', []],
        ['Mat', 'dstmap1', '', ['/O']],
        ['Mat', 'dstmap2', '', ['/O']],
        ['int', 'dstmap1type', '', []],
        ['bool', 'nninterpolation', 'false', []]],
    'void']
ok: FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>

--- Incoming ---
[   'cv.getRotationMatrix2D',
    'Mat',
    [],
    [   ['Point2f', 'center', '', []],
        ['double', 'angle', '', []],
        ['double', 'scale', '', []]],
    'Mat']
ok: FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>

--- Incoming ---
[   'cv.invertAffineTransform',
    'void',
    [],
    [['Mat', 'M', '', []], ['Mat', 'iM', '', ['/O']]],
    'void']
ok: FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>

--- Incoming ---
[   'cv.getPerspectiveTransform',
    'Mat',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['int', 'solveMethod', 'DECOMP_LU', []]],
    'Mat']
ok: FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>

--- Incoming ---
[   'cv.getAffineTransform',
    'Mat',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', []]],
    'Mat']
ok: FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>

--- Incoming ---
[   'cv.getRectSubPix',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patchSize', '', []],
        ['Point2f', 'center', '', []],
        ['Mat', 'patch', '', ['/O']],
        ['int', 'patchType', '-1', []]],
    'void']
ok: FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>

--- Incoming ---
[   'cv.logPolar',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Point2f', 'center', '', []],
        ['double', 'M', '', []],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>

--- Incoming ---
[   'cv.linearPolar',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Point2f', 'center', '', []],
        ['double', 'maxRadius', '', []],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   'cv.warpPolar',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'dsize', '', []],
        ['Point2f', 'center', '', []],
        ['double', 'maxRadius', '', []],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   'cv.integral',
    'void',
    ['=integral3'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'sum', '', ['/O']],
        ['Mat', 'sqsum', '', ['/O']],
        ['Mat', 'tilted', '', ['/O']],
        ['int', 'sdepth', '-1', []],
        ['int', 'sqdepth', '-1', []]],
    'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   'cv.integral',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'sum', '', ['/O']],
        ['int', 'sdepth', '-1', []]],
    'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>

--- Incoming ---
[   'cv.integral',
    'void',
    ['=integral2'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'sum', '', ['/O']],
        ['Mat', 'sqsum', '', ['/O']],
        ['int', 'sdepth', '-1', []],
        ['int', 'sqdepth', '-1', []]],
    'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   'cv.accumulate',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.accumulateSquare',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.accumulateProduct',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.accumulateWeighted',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/IO']],
        ['double', 'alpha', '', []],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.phaseCorrelate',
    'Point2d',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'window', 'Mat()', []],
        ['double*', 'response', '0', ['/O']]],
    'Point2d']
ok: FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>

--- Incoming ---
[   'cv.createHanningWindow',
    'void',
    [],
    [   ['Mat', 'dst', '', ['/O']],
        ['Size', 'winSize', '', []],
        ['int', 'type', '', []]],
    'void']
ok: FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>

--- Incoming ---
[   'cv.divSpectrums',
    'void',
    [],
    [   ['Mat', 'a', '', []],
        ['Mat', 'b', '', []],
        ['Mat', 'c', '', ['/O']],
        ['int', 'flags', '', []],
        ['bool', 'conjB', 'false', []]],
    'void']
ok: FUNC <void cv..divSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>

--- Incoming ---
[   'cv.threshold',
    'double',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'thresh', '', []],
        ['double', 'maxval', '', []],
        ['int', 'type', '', []]],
    'double']
ok: FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>

--- Incoming ---
[   'cv.adaptiveThreshold',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'maxValue', '', []],
        ['int', 'adaptiveMethod', '', []],
        ['int', 'thresholdType', '', []],
        ['int', 'blockSize', '', []],
        ['double', 'C', '', []]],
    'void']
ok: FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>

--- Incoming ---
[   'cv.pyrDown',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'dstsize', 'Size()', ['/C', '/Ref']],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.pyrUp',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Size', 'dstsize', 'Size()', ['/C', '/Ref']],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.calcHist',
    'void',
    [],
    [   ['vector_Mat', 'images', '', []],
        ['vector_int', 'channels', '', ['/C', '/Ref']],
        ['Mat', 'mask', '', []],
        ['Mat', 'hist', '', ['/O']],
        ['vector_int', 'histSize', '', ['/C', '/Ref']],
        ['vector_float', 'ranges', '', ['/C', '/Ref']],
        ['bool', 'accumulate', 'false', []]],
    'void']
ok: FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>

--- Incoming ---
[   'cv.calcBackProject',
    'void',
    [],
    [   ['vector_Mat', 'images', '', []],
        ['vector_int', 'channels', '', ['/C', '/Ref']],
        ['Mat', 'hist', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['vector_float', 'ranges', '', ['/C', '/Ref']],
        ['double', 'scale', '', []]],
    'void']
ok: FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>

--- Incoming ---
[   'cv.compareHist',
    'double',
    [],
    [['Mat', 'H1', '', []], ['Mat', 'H2', '', []], ['int', 'method', '', []]],
    'double']
ok: FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>

--- Incoming ---
[   'cv.equalizeHist',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.createCLAHE',
    'Ptr_CLAHE',
    [],
    [   ['double', 'clipLimit', '40.0', []],
        ['Size', 'tileGridSize', 'Size(8, 8)', []]],
    'Ptr<CLAHE>']
ok: FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>

--- Incoming ---
[   'cv.wrapperEMD',
    'float',
    ['=EMD'],
    [   ['Mat', 'signature1', '', []],
        ['Mat', 'signature2', '', []],
        ['int', 'distType', '', []],
        ['Mat', 'cost', 'Mat()', []],
        ['Ptr_float', 'lowerBound', 'Ptr<float>()', ['/IO']],
        ['Mat', 'flow', 'Mat()', ['/O']]],
    'float']
ok: FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>

--- Incoming ---
[   'cv.watershed',
    'void',
    [],
    [['Mat', 'image', '', []], ['Mat', 'markers', '', ['/IO']]],
    'void']
ok: FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>

--- Incoming ---
[   'cv.pyrMeanShiftFiltering',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'sp', '', []],
        ['double', 'sr', '', []],
        ['int', 'maxLevel', '1', []],
        [   'TermCriteria',
            'termcrit',
            'TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)',
            []]],
    'void']
ok: FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>

--- Incoming ---
[   'cv.grabCut',
    'void',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'mask', '', ['/IO']],
        ['Rect', 'rect', '', []],
        ['Mat', 'bgdModel', '', ['/IO']],
        ['Mat', 'fgdModel', '', ['/IO']],
        ['int', 'iterCount', '', []],
        ['int', 'mode', 'GC_EVAL', []]],
    'void']
ok: FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>

--- Incoming ---
[   'cv.distanceTransform',
    'void',
    ['=distanceTransformWithLabels'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'labels', '', ['/O']],
        ['int', 'distanceType', '', []],
        ['int', 'maskSize', '', []],
        ['int', 'labelType', 'DIST_LABEL_CCOMP', []]],
    'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>

--- Incoming ---
[   'cv.distanceTransform',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'distanceType', '', []],
        ['int', 'maskSize', '', []],
        ['int', 'dstType', 'CV_32F', []]],
    'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>

--- Incoming ---
[   'cv.floodFill',
    'int',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Mat', 'mask', '', ['/IO']],
        ['Point', 'seedPoint', '', []],
        ['Scalar', 'newVal', '', []],
        ['Rect*', 'rect', '0', ['/O']],
        ['Scalar', 'loDiff', 'Scalar()', []],
        ['Scalar', 'upDiff', 'Scalar()', []],
        ['int', 'flags', '4', []]],
    'int']
ok: FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>

--- Incoming ---
[   'cv.blendLinear',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'weights1', '', []],
        ['Mat', 'weights2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..blendLinear [ARG Mat src1=, ARG Mat src2=, ARG Mat weights1=, ARG Mat weights2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.cvtColor',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'code', '', []],
        ['int', 'dstCn', '0', []]],
    'void']
ok: FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   'cv.cvtColorTwoPlane',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'code', '', []]],
    'void']
ok: FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>

--- Incoming ---
[   'cv.demosaicing',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'code', '', []],
        ['int', 'dstCn', '0', []]],
    'void']
ok: FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   'cv.moments',
    'Moments',
    [],
    [['Mat', 'array', '', []], ['bool', 'binaryImage', 'false', []]],
    'Moments']
ok: FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>

--- Incoming ---
[   'cv.HuMoments',
    'void',
    [],
    [['Moments', 'm', '', ['/C', '/Ref']], ['Mat', 'hu', '', ['/O']]],
    'void']
ok: FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>

--- Incoming ---
[   'enum cv.TemplateMatchModes',
    '',
    [],
    [   ['const cv.TM_SQDIFF', '0', [], [], None, ''],
        ['const cv.TM_SQDIFF_NORMED', '1', [], [], None, ''],
        ['const cv.TM_CCORR', '2', [], [], None, ''],
        ['const cv.TM_CCORR_NORMED', '3', [], [], None, ''],
        ['const cv.TM_CCOEFF', '4', [], [], None, ''],
        ['const cv.TM_CCOEFF_NORMED', '5', [], [], None, '']],
    None]
ok: CONST TM_SQDIFF=0
ok: CONST TM_SQDIFF_NORMED=1
ok: CONST TM_CCORR=2
ok: CONST TM_CCORR_NORMED=3
ok: CONST TM_CCOEFF=4
ok: CONST TM_CCOEFF_NORMED=5

--- Incoming ---
[   'cv.matchTemplate',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'templ', '', []],
        ['Mat', 'result', '', ['/O']],
        ['int', 'method', '', []],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.connectedComponents',
    'int',
    ['=connectedComponentsWithAlgorithm'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'labels', '', ['/O']],
        ['int', 'connectivity', '', []],
        ['int', 'ltype', '', []],
        ['int', 'ccltype', '', []]],
    'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   'cv.connectedComponents',
    'int',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'labels', '', ['/O']],
        ['int', 'connectivity', '8', []],
        ['int', 'ltype', 'CV_32S', []]],
    'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   'cv.connectedComponentsWithStats',
    'int',
    ['=connectedComponentsWithStatsWithAlgorithm'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'labels', '', ['/O']],
        ['Mat', 'stats', '', ['/O']],
        ['Mat', 'centroids', '', ['/O']],
        ['int', 'connectivity', '', []],
        ['int', 'ltype', '', []],
        ['int', 'ccltype', '', []]],
    'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   'cv.connectedComponentsWithStats',
    'int',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'labels', '', ['/O']],
        ['Mat', 'stats', '', ['/O']],
        ['Mat', 'centroids', '', ['/O']],
        ['int', 'connectivity', '8', []],
        ['int', 'ltype', 'CV_32S', []]],
    'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   'cv.findContours',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['vector_Mat', 'contours', '', ['/O']],
        ['Mat', 'hierarchy', '', ['/O']],
        ['int', 'mode', '', []],
        ['int', 'method', '', []],
        ['Point', 'offset', 'Point()', []]],
    'void']
ok: FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>

--- Incoming ---
[   'cv.approxPolyDP',
    'void',
    [],
    [   ['Mat', 'curve', '', []],
        ['Mat', 'approxCurve', '', ['/O']],
        ['double', 'epsilon', '', []],
        ['bool', 'closed', '', []]],
    'void']
ok: FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>

--- Incoming ---
[   'cv.arcLength',
    'double',
    [],
    [['Mat', 'curve', '', []], ['bool', 'closed', '', []]],
    'double']
ok: FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>

--- Incoming ---
['cv.boundingRect', 'Rect', [], [['Mat', 'array', '', []]], 'Rect']
ok: FUNC <Rect cv..boundingRect [ARG Mat array=]>

--- Incoming ---
[   'cv.contourArea',
    'double',
    [],
    [['Mat', 'contour', '', []], ['bool', 'oriented', 'false', []]],
    'double']
ok: FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>

--- Incoming ---
[   'cv.minAreaRect',
    'RotatedRect',
    [],
    [['Mat', 'points', '', []]],
    'RotatedRect']
ok: FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>

--- Incoming ---
[   'cv.boxPoints',
    'void',
    [],
    [['RotatedRect', 'box', '', []], ['Mat', 'points', '', ['/O']]],
    'void']
ok: FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>

--- Incoming ---
[   'cv.minEnclosingCircle',
    'void',
    [],
    [   ['Mat', 'points', '', []],
        ['Point2f', 'center', '', ['/O', '/Ref']],
        ['float', 'radius', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>

--- Incoming ---
[   'cv.minEnclosingTriangle',
    'double',
    [],
    [['Mat', 'points', '', []], ['Mat', 'triangle', '', ['/O', '/O']]],
    'double']
ok: FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>

--- Incoming ---
[   'cv.matchShapes',
    'double',
    [],
    [   ['Mat', 'contour1', '', []],
        ['Mat', 'contour2', '', []],
        ['int', 'method', '', []],
        ['double', 'parameter', '', []]],
    'double']
ok: FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>

--- Incoming ---
[   'cv.convexHull',
    'void',
    [],
    [   ['Mat', 'points', '', []],
        ['Mat', 'hull', '', ['/O']],
        ['bool', 'clockwise', 'false', []],
        ['bool', 'returnPoints', 'true', []]],
    'void']
ok: FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>

--- Incoming ---
[   'cv.convexityDefects',
    'void',
    [],
    [   ['Mat', 'contour', '', []],
        ['Mat', 'convexhull', '', []],
        ['Mat', 'convexityDefects', '', ['/O']]],
    'void']
ok: FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>

--- Incoming ---
['cv.isContourConvex', 'bool', [], [['Mat', 'contour', '', []]], 'bool']
ok: FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>

--- Incoming ---
[   'cv.intersectConvexConvex',
    'float',
    [],
    [   ['Mat', 'p1', '', []],
        ['Mat', 'p2', '', []],
        ['Mat', 'p12', '', ['/O']],
        ['bool', 'handleNested', 'true', []]],
    'float']
ok: FUNC <float cv..intersectConvexConvex [ARG Mat p1=, ARG Mat p2=, ARG Mat p12=, ARG bool handleNested=true]>

--- Incoming ---
['cv.fitEllipse', 'RotatedRect', [], [['Mat', 'points', '', []]], 'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>

--- Incoming ---
[   'cv.fitEllipseAMS',
    'RotatedRect',
    [],
    [['Mat', 'points', '', []]],
    'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>

--- Incoming ---
[   'cv.fitEllipseDirect',
    'RotatedRect',
    [],
    [['Mat', 'points', '', []]],
    'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>

--- Incoming ---
[   'cv.fitLine',
    'void',
    [],
    [   ['Mat', 'points', '', []],
        ['Mat', 'line', '', ['/O']],
        ['int', 'distType', '', []],
        ['double', 'param', '', []],
        ['double', 'reps', '', []],
        ['double', 'aeps', '', []]],
    'void']
ok: FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>

--- Incoming ---
[   'cv.pointPolygonTest',
    'double',
    [],
    [   ['Mat', 'contour', '', []],
        ['Point2f', 'pt', '', []],
        ['bool', 'measureDist', '', []]],
    'double']
ok: FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>

--- Incoming ---
[   'cv.rotatedRectangleIntersection',
    'int',
    [],
    [   ['RotatedRect', 'rect1', '', ['/C', '/Ref']],
        ['RotatedRect', 'rect2', '', ['/C', '/Ref']],
        ['Mat', 'intersectingRegion', '', ['/O']]],
    'int']
ok: FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>

--- Incoming ---
[   'cv.createGeneralizedHoughBallard',
    'Ptr_GeneralizedHoughBallard',
    [],
    [],
    'Ptr<GeneralizedHoughBallard>']
ok: FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>

--- Incoming ---
[   'cv.createGeneralizedHoughGuil',
    'Ptr_GeneralizedHoughGuil',
    [],
    [],
    'Ptr<GeneralizedHoughGuil>']
ok: FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>

--- Incoming ---
[   'enum cv.ColormapTypes',
    '',
    [],
    [   ['const cv.COLORMAP_AUTUMN', '0', [], [], None, ''],
        ['const cv.COLORMAP_BONE', '1', [], [], None, ''],
        ['const cv.COLORMAP_JET', '2', [], [], None, ''],
        ['const cv.COLORMAP_WINTER', '3', [], [], None, ''],
        ['const cv.COLORMAP_RAINBOW', '4', [], [], None, ''],
        ['const cv.COLORMAP_OCEAN', '5', [], [], None, ''],
        ['const cv.COLORMAP_SUMMER', '6', [], [], None, ''],
        ['const cv.COLORMAP_SPRING', '7', [], [], None, ''],
        ['const cv.COLORMAP_COOL', '8', [], [], None, ''],
        ['const cv.COLORMAP_HSV', '9', [], [], None, ''],
        ['const cv.COLORMAP_PINK', '10', [], [], None, ''],
        ['const cv.COLORMAP_HOT', '11', [], [], None, ''],
        ['const cv.COLORMAP_PARULA', '12', [], [], None, ''],
        ['const cv.COLORMAP_MAGMA', '13', [], [], None, ''],
        ['const cv.COLORMAP_INFERNO', '14', [], [], None, ''],
        ['const cv.COLORMAP_PLASMA', '15', [], [], None, ''],
        ['const cv.COLORMAP_VIRIDIS', '16', [], [], None, ''],
        ['const cv.COLORMAP_CIVIDIS', '17', [], [], None, ''],
        ['const cv.COLORMAP_TWILIGHT', '18', [], [], None, ''],
        ['const cv.COLORMAP_TWILIGHT_SHIFTED', '19', [], [], None, ''],
        ['const cv.COLORMAP_TURBO', '20', [], [], None, ''],
        ['const cv.COLORMAP_DEEPGREEN', '21', [], [], None, '']],
    None]
ok: CONST COLORMAP_AUTUMN=0
ok: CONST COLORMAP_BONE=1
ok: CONST COLORMAP_JET=2
ok: CONST COLORMAP_WINTER=3
ok: CONST COLORMAP_RAINBOW=4
ok: CONST COLORMAP_OCEAN=5
ok: CONST COLORMAP_SUMMER=6
ok: CONST COLORMAP_SPRING=7
ok: CONST COLORMAP_COOL=8
ok: CONST COLORMAP_HSV=9
ok: CONST COLORMAP_PINK=10
ok: CONST COLORMAP_HOT=11
ok: CONST COLORMAP_PARULA=12
ok: CONST COLORMAP_MAGMA=13
ok: CONST COLORMAP_INFERNO=14
ok: CONST COLORMAP_PLASMA=15
ok: CONST COLORMAP_VIRIDIS=16
ok: CONST COLORMAP_CIVIDIS=17
ok: CONST COLORMAP_TWILIGHT=18
ok: CONST COLORMAP_TWILIGHT_SHIFTED=19
ok: CONST COLORMAP_TURBO=20
ok: CONST COLORMAP_DEEPGREEN=21

--- Incoming ---
[   'cv.applyColorMap',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'colormap', '', []]],
    'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>

--- Incoming ---
[   'cv.applyColorMap',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'userColor', '', []]],
    'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>

--- Incoming ---
[   'cv.line',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.arrowedLine',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'line_type', '8', []],
        ['int', 'shift', '0', []],
        ['double', 'tipLength', '0.1', []]],
    'void']
ok: FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>

--- Incoming ---
[   'cv.rectangle',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'pt1', '', []],
        ['Point', 'pt2', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.rectangle',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Rect', 'rec', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.circle',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'center', '', []],
        ['int', 'radius', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.ellipse',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'center', '', []],
        ['Size', 'axes', '', []],
        ['double', 'angle', '', []],
        ['double', 'startAngle', '', []],
        ['double', 'endAngle', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.ellipse',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['RotatedRect', 'box', '', ['/C', '/Ref']],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []]],
    'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>

--- Incoming ---
[   'cv.drawMarker',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Point', 'position', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'markerType', 'MARKER_CROSS', []],
        ['int', 'markerSize', '20', []],
        ['int', 'thickness', '1', []],
        ['int', 'line_type', '8', []]],
    'void']
ok: FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>

--- Incoming ---
[   'cv.fillConvexPoly',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['Mat', 'points', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.fillPoly',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['vector_Mat', 'pts', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []],
        ['Point', 'offset', 'Point()', []]],
    'void']
ok: FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>

--- Incoming ---
[   'cv.polylines',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['vector_Mat', 'pts', '', []],
        ['bool', 'isClosed', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['int', 'shift', '0', []]],
    'void']
ok: FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   'cv.drawContours',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['vector_Mat', 'contours', '', []],
        ['int', 'contourIdx', '', []],
        ['Scalar', 'color', '', ['/C', '/Ref']],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['Mat', 'hierarchy', 'Mat()', []],
        ['int', 'maxLevel', 'INT_MAX', []],
        ['Point', 'offset', 'Point()', []]],
    'void']
ok: FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>

--- Incoming ---
[   'cv.clipLine',
    'bool',
    [],
    [   ['Rect', 'imgRect', '', []],
        ['Point', 'pt1', '', ['/O', '/IO', '/Ref']],
        ['Point', 'pt2', '', ['/O', '/IO', '/Ref']]],
    'bool']
ok: FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>

--- Incoming ---
[   'cv.ellipse2Poly',
    'void',
    [],
    [   ['Point', 'center', '', []],
        ['Size', 'axes', '', []],
        ['int', 'angle', '', []],
        ['int', 'arcStart', '', []],
        ['int', 'arcEnd', '', []],
        ['int', 'delta', '', []],
        ['vector_Point', 'pts', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>

--- Incoming ---
[   'cv.putText',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['String', 'text', '', ['/C', '/Ref']],
        ['Point', 'org', '', []],
        ['int', 'fontFace', '', []],
        ['double', 'fontScale', '', []],
        ['Scalar', 'color', '', []],
        ['int', 'thickness', '1', []],
        ['int', 'lineType', 'LINE_8', []],
        ['bool', 'bottomLeftOrigin', 'false', []]],
    'void']
ok: FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>

--- Incoming ---
[   'cv.getTextSize',
    'Size',
    [],
    [   ['String', 'text', '', ['/C', '/Ref']],
        ['int', 'fontFace', '', []],
        ['double', 'fontScale', '', []],
        ['int', 'thickness', '', []],
        ['int*', 'baseLine', '', ['/O']]],
    'Size']
manual: FUNC <Size cv..getTextSize [ARG String text=, ARG int fontFace=, ARG double fontScale=, ARG int thickness=, ARG int * baseLine=]>

--- Incoming ---
[   'cv.getFontScaleFromHeight',
    'double',
    [],
    [   ['int', 'fontFace', '', ['/C']],
        ['int', 'pixelHeight', '', ['/C']],
        ['int', 'thickness', '1', ['/C']]],
    'double']
ok: FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc.hpp =====
Namespaces: ['', 'cv']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/imgproc.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/bindings.hpp =====
Namespaces: ['', 'cv']

--- Incoming ---
[   'cv.HoughLinesWithAccumulator',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'lines', '', ['/O']],
        ['double', 'rho', '', []],
        ['double', 'theta', '', []],
        ['int', 'threshold', '', []],
        ['double', 'srn', '0', []],
        ['double', 'stn', '0', []],
        ['double', 'min_theta', '0', []],
        ['double', 'max_theta', 'CV_PI', []]],
    'void']
ok: FUNC <void cv..HoughLinesWithAccumulator [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/segmentation.hpp =====
Namespaces: ['', 'cv', 'cv.segmentation']

--- Incoming ---
['class cv.segmentation.IntelligentScissorsMB', '', ['/Simple'], [], None]
ok: class CLASS cv.segmentation::.IntelligentScissorsMB : , name: IntelligentScissorsMB, base: 

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.IntelligentScissorsMB',
    '',
    [],
    [],
    None]
ok: FUNC < cv.segmentation.IntelligentScissorsMB.IntelligentScissorsMB []>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.setWeights',
    'IntelligentScissorsMB',
    [],
    [   ['float', 'weight_non_edge', '', []],
        ['float', 'weight_gradient_direction', '', []],
        ['float', 'weight_gradient_magnitude', '', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setWeights [ARG float weight_non_edge=, ARG float weight_gradient_direction=, ARG float weight_gradient_magnitude=]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit',
    'IntelligentScissorsMB',
    [],
    [['float', 'gradient_magnitude_threshold_max', '0.0f', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit [ARG float gradient_magnitude_threshold_max=0.0f]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters',
    'IntelligentScissorsMB',
    [],
    [['float', 'gradient_magnitude_min_value', '0.0f', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters [ARG float gradient_magnitude_min_value=0.0f]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters',
    'IntelligentScissorsMB',
    [],
    [   ['double', 'threshold1', '', []],
        ['double', 'threshold2', '', []],
        ['int', 'apertureSize', '3', []],
        ['bool', 'L2gradient', 'false', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters [ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.applyImage',
    'IntelligentScissorsMB',
    [],
    [['Mat', 'image', '', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.applyImage [ARG Mat image=]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.applyImageFeatures',
    'IntelligentScissorsMB',
    [],
    [   ['Mat', 'non_edge', '', []],
        ['Mat', 'gradient_direction', '', []],
        ['Mat', 'gradient_magnitude', '', []],
        ['Mat', 'image', 'Mat()', []]],
    'IntelligentScissorsMB']
ok: FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.applyImageFeatures [ARG Mat non_edge=, ARG Mat gradient_direction=, ARG Mat gradient_magnitude=, ARG Mat image=Mat()]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.buildMap',
    'void',
    [],
    [['Point', 'sourcePt', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.segmentation.IntelligentScissorsMB.buildMap [ARG Point sourcePt=]>

--- Incoming ---
[   'cv.segmentation.IntelligentScissorsMB.getContour',
    'void',
    ['/C'],
    [   ['Point', 'targetPt', '', ['/C', '/Ref']],
        ['Mat', 'contour', '', ['/O']],
        ['bool', 'backward', 'false', []]],
    'void']
ok: FUNC <void cv.segmentation.IntelligentScissorsMB.getContour [ARG Point targetPt=, ARG Mat contour=, ARG bool backward=false]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp =====
Namespaces: ['', 'cv', 'cv.hal', 'cv.segmentation']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp =====
Namespaces: ['', 'cv', 'cv.detail', 'cv.hal', 'cv.segmentation']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp


===== Generating... =====
CLASS cv::.CLAHE : Algorithm
FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>
java: void apply(Mat src, Mat dst)
FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>
java: void setClipLimit(double clipLimit)
FUNC <double cv.CLAHE.getClipLimit []>
java: double getClipLimit()
FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>
java: void setTilesGridSize(Size tileGridSize)
FUNC <Size cv.CLAHE.getTilesGridSize []>
java: Size getTilesGridSize()
FUNC <void cv.CLAHE.collectGarbage []>
java: void collectGarbage()
CLASS cv::.GeneralizedHough : Algorithm
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat templ, Point templCenter)
java: void setTemplate(Mat templ)
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat edges, Mat dx, Mat dy, Point templCenter)
java: void setTemplate(Mat edges, Mat dx, Mat dy)
FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat image, Mat positions, Mat votes)
java: void detect(Mat image, Mat positions)
FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions, Mat votes)
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions)
FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>
java: void setCannyLowThresh(int cannyLowThresh)
FUNC <int cv.GeneralizedHough.getCannyLowThresh []>
java: int getCannyLowThresh()
FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>
java: void setCannyHighThresh(int cannyHighThresh)
FUNC <int cv.GeneralizedHough.getCannyHighThresh []>
java: int getCannyHighThresh()
FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>
java: void setMinDist(double minDist)
FUNC <double cv.GeneralizedHough.getMinDist []>
java: double getMinDist()
FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>
java: void setDp(double dp)
FUNC <double cv.GeneralizedHough.getDp []>
java: double getDp()
FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>
java: void setMaxBufferSize(int maxBufferSize)
FUNC <int cv.GeneralizedHough.getMaxBufferSize []>
java: int getMaxBufferSize()
CLASS cv::.GeneralizedHoughBallard : GeneralizedHough
FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <int cv.GeneralizedHoughBallard.getLevels []>
java: int getLevels()
FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>
java: void setVotesThreshold(int votesThreshold)
FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>
java: int getVotesThreshold()
CLASS cv::.GeneralizedHoughGuil : GeneralizedHough
FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>
java: void setXi(double xi)
FUNC <double cv.GeneralizedHoughGuil.getXi []>
java: double getXi()
FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <int cv.GeneralizedHoughGuil.getLevels []>
java: int getLevels()
FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>
java: void setAngleEpsilon(double angleEpsilon)
FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>
java: double getAngleEpsilon()
FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>
java: void setMinAngle(double minAngle)
FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>
java: double getMinAngle()
FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>
java: void setMaxAngle(double maxAngle)
FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>
java: double getMaxAngle()
FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>
java: void setAngleStep(double angleStep)
FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>
java: double getAngleStep()
FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>
java: void setAngleThresh(int angleThresh)
FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>
java: int getAngleThresh()
FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>
java: void setMinScale(double minScale)
FUNC <double cv.GeneralizedHoughGuil.getMinScale []>
java: double getMinScale()
FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>
java: void setMaxScale(double maxScale)
FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>
java: double getMaxScale()
FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>
java: void setScaleStep(double scaleStep)
FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>
java: double getScaleStep()
FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>
java: void setScaleThresh(int scaleThresh)
FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>
java: int getScaleThresh()
FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>
java: void setPosThresh(int posThresh)
FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>
java: int getPosThresh()
CLASS cv::.Imgproc : 
[CONST IPL_BORDER_CONSTANT=0(manual), CONST IPL_BORDER_REPLICATE=1(manual), CONST IPL_BORDER_REFLECT=2(manual), CONST IPL_BORDER_WRAP=3(manual), CONST IPL_BORDER_REFLECT_101=4(manual), CONST IPL_BORDER_TRANSPARENT=5(manual), CONST CV_INTER_NN=0, CONST CV_INTER_LINEAR=1, CONST CV_INTER_CUBIC=2, CONST CV_INTER_AREA=3, CONST CV_INTER_LANCZOS4=4, CONST CV_MOP_ERODE=0, CONST CV_MOP_DILATE=1, CONST CV_MOP_OPEN=2, CONST CV_MOP_CLOSE=3, CONST CV_MOP_GRADIENT=4, CONST CV_MOP_TOPHAT=5, CONST CV_MOP_BLACKHAT=6, CONST CV_RETR_EXTERNAL=0, CONST CV_RETR_LIST=1, CONST CV_RETR_CCOMP=2, CONST CV_RETR_TREE=3, CONST CV_RETR_FLOODFILL=4, CONST CV_CHAIN_APPROX_NONE=1, CONST CV_CHAIN_APPROX_SIMPLE=2, CONST CV_CHAIN_APPROX_TC89_L1=3, CONST CV_CHAIN_APPROX_TC89_KCOS=4, CONST CV_THRESH_BINARY=0, CONST CV_THRESH_BINARY_INV=1, CONST CV_THRESH_TRUNC=2, CONST CV_THRESH_TOZERO=3, CONST CV_THRESH_TOZERO_INV=4, CONST CV_THRESH_MASK=7, CONST CV_THRESH_OTSU=8, CONST CV_THRESH_TRIANGLE=16]
[CONST CV_GAUSSIAN_5x5=7, CONST CV_SCHARR=-1, CONST CV_MAX_SOBEL_KSIZE=7, CONST CV_RGBA2mRGBA=125, CONST CV_mRGBA2RGBA=126, CONST CV_WARP_FILL_OUTLIERS=8, CONST CV_WARP_INVERSE_MAP=16, CONST CV_CHAIN_CODE=0, CONST CV_LINK_RUNS=5, CONST CV_POLY_APPROX_DP=0, CONST CV_CONTOURS_MATCH_I1=1, CONST CV_CONTOURS_MATCH_I2=2, CONST CV_CONTOURS_MATCH_I3=3, CONST CV_CLOCKWISE=1, CONST CV_COUNTER_CLOCKWISE=2, CONST CV_COMP_CORREL=0, CONST CV_COMP_CHISQR=1, CONST CV_COMP_INTERSECT=2, CONST CV_COMP_BHATTACHARYYA=3, CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA, CONST CV_COMP_CHISQR_ALT=4, CONST CV_COMP_KL_DIV=5, CONST CV_DIST_MASK_3=3, CONST CV_DIST_MASK_5=5, CONST CV_DIST_MASK_PRECISE=0, CONST CV_DIST_LABEL_CCOMP=0, CONST CV_DIST_LABEL_PIXEL=1, CONST CV_DIST_USER=-1, CONST CV_DIST_L1=1, CONST CV_DIST_L2=2, CONST CV_DIST_C=3, CONST CV_DIST_L12=4, CONST CV_DIST_FAIR=5, CONST CV_DIST_WELSCH=6, CONST CV_DIST_HUBER=7, CONST CV_CANNY_L2_GRADIENT=(1 << 31), CONST CV_HOUGH_STANDARD=0, CONST CV_HOUGH_PROBABILISTIC=1, CONST CV_HOUGH_MULTI_SCALE=2, CONST CV_HOUGH_GRADIENT=3]
[CONST CV_SHAPE_RECT=0, CONST CV_SHAPE_CROSS=1, CONST CV_SHAPE_ELLIPSE=2, CONST CV_SHAPE_CUSTOM=100]
[CONST CV_BLUR_NO_SCALE=0, CONST CV_BLUR=1, CONST CV_GAUSSIAN=2, CONST CV_MEDIAN=3, CONST CV_BILATERAL=4]
[CONST ADAPTIVE_THRESH_MEAN_C=0, CONST ADAPTIVE_THRESH_GAUSSIAN_C=1]
[CONST COLOR_BGR2BGRA=0, CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA, CONST COLOR_BGRA2BGR=1, CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR, CONST COLOR_BGR2RGBA=2, CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA, CONST COLOR_RGBA2BGR=3, CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR, CONST COLOR_BGR2RGB=4, CONST COLOR_RGB2BGR=COLOR_BGR2RGB, CONST COLOR_BGRA2RGBA=5, CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA, CONST COLOR_BGR2GRAY=6, CONST COLOR_RGB2GRAY=7, CONST COLOR_GRAY2BGR=8, CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR, CONST COLOR_GRAY2BGRA=9, CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA, CONST COLOR_BGRA2GRAY=10, CONST COLOR_RGBA2GRAY=11, CONST COLOR_BGR2BGR565=12, CONST COLOR_RGB2BGR565=13, CONST COLOR_BGR5652BGR=14, CONST COLOR_BGR5652RGB=15, CONST COLOR_BGRA2BGR565=16, CONST COLOR_RGBA2BGR565=17, CONST COLOR_BGR5652BGRA=18, CONST COLOR_BGR5652RGBA=19, CONST COLOR_GRAY2BGR565=20, CONST COLOR_BGR5652GRAY=21, CONST COLOR_BGR2BGR555=22, CONST COLOR_RGB2BGR555=23, CONST COLOR_BGR5552BGR=24, CONST COLOR_BGR5552RGB=25, CONST COLOR_BGRA2BGR555=26, CONST COLOR_RGBA2BGR555=27, CONST COLOR_BGR5552BGRA=28, CONST COLOR_BGR5552RGBA=29, CONST COLOR_GRAY2BGR555=30, CONST COLOR_BGR5552GRAY=31, CONST COLOR_BGR2XYZ=32, CONST COLOR_RGB2XYZ=33, CONST COLOR_XYZ2BGR=34, CONST COLOR_XYZ2RGB=35, CONST COLOR_BGR2YCrCb=36, CONST COLOR_RGB2YCrCb=37, CONST COLOR_YCrCb2BGR=38, CONST COLOR_YCrCb2RGB=39, CONST COLOR_BGR2HSV=40, CONST COLOR_RGB2HSV=41, CONST COLOR_BGR2Lab=44, CONST COLOR_RGB2Lab=45, CONST COLOR_BGR2Luv=50, CONST COLOR_RGB2Luv=51, CONST COLOR_BGR2HLS=52, CONST COLOR_RGB2HLS=53, CONST COLOR_HSV2BGR=54, CONST COLOR_HSV2RGB=55, CONST COLOR_Lab2BGR=56, CONST COLOR_Lab2RGB=57, CONST COLOR_Luv2BGR=58, CONST COLOR_Luv2RGB=59, CONST COLOR_HLS2BGR=60, CONST COLOR_HLS2RGB=61, CONST COLOR_BGR2HSV_FULL=66, CONST COLOR_RGB2HSV_FULL=67, CONST COLOR_BGR2HLS_FULL=68, CONST COLOR_RGB2HLS_FULL=69, CONST COLOR_HSV2BGR_FULL=70, CONST COLOR_HSV2RGB_FULL=71, CONST COLOR_HLS2BGR_FULL=72, CONST COLOR_HLS2RGB_FULL=73, CONST COLOR_LBGR2Lab=74, CONST COLOR_LRGB2Lab=75, CONST COLOR_LBGR2Luv=76, CONST COLOR_LRGB2Luv=77, CONST COLOR_Lab2LBGR=78, CONST COLOR_Lab2LRGB=79, CONST COLOR_Luv2LBGR=80, CONST COLOR_Luv2LRGB=81, CONST COLOR_BGR2YUV=82, CONST COLOR_RGB2YUV=83, CONST COLOR_YUV2BGR=84, CONST COLOR_YUV2RGB=85, CONST COLOR_YUV2RGB_NV12=90, CONST COLOR_YUV2BGR_NV12=91, CONST COLOR_YUV2RGB_NV21=92, CONST COLOR_YUV2BGR_NV21=93, CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21, CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21, CONST COLOR_YUV2RGBA_NV12=94, CONST COLOR_YUV2BGRA_NV12=95, CONST COLOR_YUV2RGBA_NV21=96, CONST COLOR_YUV2BGRA_NV21=97, CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21, CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21, CONST COLOR_YUV2RGB_YV12=98, CONST COLOR_YUV2BGR_YV12=99, CONST COLOR_YUV2RGB_IYUV=100, CONST COLOR_YUV2BGR_IYUV=101, CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV, CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV, CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12, CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12, CONST COLOR_YUV2RGBA_YV12=102, CONST COLOR_YUV2BGRA_YV12=103, CONST COLOR_YUV2RGBA_IYUV=104, CONST COLOR_YUV2BGRA_IYUV=105, CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV, CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV, CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12, CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12, CONST COLOR_YUV2GRAY_420=106, CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420, CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV2RGB_UYVY=107, CONST COLOR_YUV2BGR_UYVY=108, CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGBA_UYVY=111, CONST COLOR_YUV2BGRA_UYVY=112, CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGB_YUY2=115, CONST COLOR_YUV2BGR_YUY2=116, CONST COLOR_YUV2RGB_YVYU=117, CONST COLOR_YUV2BGR_YVYU=118, CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGBA_YUY2=119, CONST COLOR_YUV2BGRA_YUY2=120, CONST COLOR_YUV2RGBA_YVYU=121, CONST COLOR_YUV2BGRA_YVYU=122, CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2GRAY_UYVY=123, CONST COLOR_YUV2GRAY_YUY2=124, CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2, CONST COLOR_RGBA2mRGBA=125, CONST COLOR_mRGBA2RGBA=126, CONST COLOR_RGB2YUV_I420=127, CONST COLOR_BGR2YUV_I420=128, CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420, CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420, CONST COLOR_RGBA2YUV_I420=129, CONST COLOR_BGRA2YUV_I420=130, CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420, CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420, CONST COLOR_RGB2YUV_YV12=131, CONST COLOR_BGR2YUV_YV12=132, CONST COLOR_RGBA2YUV_YV12=133, CONST COLOR_BGRA2YUV_YV12=134, CONST COLOR_BayerBG2BGR=46, CONST COLOR_BayerGB2BGR=47, CONST COLOR_BayerRG2BGR=48, CONST COLOR_BayerGR2BGR=49, CONST COLOR_BayerRGGB2BGR=COLOR_BayerBG2BGR, CONST COLOR_BayerGRBG2BGR=COLOR_BayerGB2BGR, CONST COLOR_BayerBGGR2BGR=COLOR_BayerRG2BGR, CONST COLOR_BayerGBRG2BGR=COLOR_BayerGR2BGR, CONST COLOR_BayerRGGB2RGB=COLOR_BayerBGGR2BGR, CONST COLOR_BayerGRBG2RGB=COLOR_BayerGBRG2BGR, CONST COLOR_BayerBGGR2RGB=COLOR_BayerRGGB2BGR, CONST COLOR_BayerGBRG2RGB=COLOR_BayerGRBG2BGR, CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR, CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR, CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR, CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR, CONST COLOR_BayerBG2GRAY=86, CONST COLOR_BayerGB2GRAY=87, CONST COLOR_BayerRG2GRAY=88, CONST COLOR_BayerGR2GRAY=89, CONST COLOR_BayerRGGB2GRAY=COLOR_BayerBG2GRAY, CONST COLOR_BayerGRBG2GRAY=COLOR_BayerGB2GRAY, CONST COLOR_BayerBGGR2GRAY=COLOR_BayerRG2GRAY, CONST COLOR_BayerGBRG2GRAY=COLOR_BayerGR2GRAY, CONST COLOR_BayerBG2BGR_VNG=62, CONST COLOR_BayerGB2BGR_VNG=63, CONST COLOR_BayerRG2BGR_VNG=64, CONST COLOR_BayerGR2BGR_VNG=65, CONST COLOR_BayerRGGB2BGR_VNG=COLOR_BayerBG2BGR_VNG, CONST COLOR_BayerGRBG2BGR_VNG=COLOR_BayerGB2BGR_VNG, CONST COLOR_BayerBGGR2BGR_VNG=COLOR_BayerRG2BGR_VNG, CONST COLOR_BayerGBRG2BGR_VNG=COLOR_BayerGR2BGR_VNG, CONST COLOR_BayerRGGB2RGB_VNG=COLOR_BayerBGGR2BGR_VNG, CONST COLOR_BayerGRBG2RGB_VNG=COLOR_BayerGBRG2BGR_VNG, CONST COLOR_BayerBGGR2RGB_VNG=COLOR_BayerRGGB2BGR_VNG, CONST COLOR_BayerGBRG2RGB_VNG=COLOR_BayerGRBG2BGR_VNG, CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG, CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG, CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG, CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG, CONST COLOR_BayerBG2BGR_EA=135, CONST COLOR_BayerGB2BGR_EA=136, CONST COLOR_BayerRG2BGR_EA=137, CONST COLOR_BayerGR2BGR_EA=138, CONST COLOR_BayerRGGB2BGR_EA=COLOR_BayerBG2BGR_EA, CONST COLOR_BayerGRBG2BGR_EA=COLOR_BayerGB2BGR_EA, CONST COLOR_BayerBGGR2BGR_EA=COLOR_BayerRG2BGR_EA, CONST COLOR_BayerGBRG2BGR_EA=COLOR_BayerGR2BGR_EA, CONST COLOR_BayerRGGB2RGB_EA=COLOR_BayerBGGR2BGR_EA, CONST COLOR_BayerGRBG2RGB_EA=COLOR_BayerGBRG2BGR_EA, CONST COLOR_BayerBGGR2RGB_EA=COLOR_BayerRGGB2BGR_EA, CONST COLOR_BayerGBRG2RGB_EA=COLOR_BayerGRBG2BGR_EA, CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA, CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA, CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA, CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA, CONST COLOR_BayerBG2BGRA=139, CONST COLOR_BayerGB2BGRA=140, CONST COLOR_BayerRG2BGRA=141, CONST COLOR_BayerGR2BGRA=142, CONST COLOR_BayerRGGB2BGRA=COLOR_BayerBG2BGRA, CONST COLOR_BayerGRBG2BGRA=COLOR_BayerGB2BGRA, CONST COLOR_BayerBGGR2BGRA=COLOR_BayerRG2BGRA, CONST COLOR_BayerGBRG2BGRA=COLOR_BayerGR2BGRA, CONST COLOR_BayerRGGB2RGBA=COLOR_BayerBGGR2BGRA, CONST COLOR_BayerGRBG2RGBA=COLOR_BayerGBRG2BGRA, CONST COLOR_BayerBGGR2RGBA=COLOR_BayerRGGB2BGRA, CONST COLOR_BayerGBRG2RGBA=COLOR_BayerGRBG2BGRA, CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA, CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA, CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA, CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA, CONST COLOR_COLORCVT_MAX=143]
[CONST COLORMAP_AUTUMN=0, CONST COLORMAP_BONE=1, CONST COLORMAP_JET=2, CONST COLORMAP_WINTER=3, CONST COLORMAP_RAINBOW=4, CONST COLORMAP_OCEAN=5, CONST COLORMAP_SUMMER=6, CONST COLORMAP_SPRING=7, CONST COLORMAP_COOL=8, CONST COLORMAP_HSV=9, CONST COLORMAP_PINK=10, CONST COLORMAP_HOT=11, CONST COLORMAP_PARULA=12, CONST COLORMAP_MAGMA=13, CONST COLORMAP_INFERNO=14, CONST COLORMAP_PLASMA=15, CONST COLORMAP_VIRIDIS=16, CONST COLORMAP_CIVIDIS=17, CONST COLORMAP_TWILIGHT=18, CONST COLORMAP_TWILIGHT_SHIFTED=19, CONST COLORMAP_TURBO=20, CONST COLORMAP_DEEPGREEN=21]
[CONST CCL_DEFAULT=-1, CONST CCL_WU=0, CONST CCL_GRANA=1, CONST CCL_BOLELLI=2, CONST CCL_SAUF=3, CONST CCL_BBDT=4, CONST CCL_SPAGHETTI=5]
[CONST CC_STAT_LEFT=0, CONST CC_STAT_TOP=1, CONST CC_STAT_WIDTH=2, CONST CC_STAT_HEIGHT=3, CONST CC_STAT_AREA=4, CONST CC_STAT_MAX=5]
[CONST CHAIN_APPROX_NONE=1, CONST CHAIN_APPROX_SIMPLE=2, CONST CHAIN_APPROX_TC89_L1=3, CONST CHAIN_APPROX_TC89_KCOS=4]
[CONST DIST_LABEL_CCOMP=0, CONST DIST_LABEL_PIXEL=1]
[CONST DIST_MASK_3=3, CONST DIST_MASK_5=5, CONST DIST_MASK_PRECISE=0]
[CONST DIST_USER=-1, CONST DIST_L1=1, CONST DIST_L2=2, CONST DIST_C=3, CONST DIST_L12=4, CONST DIST_FAIR=5, CONST DIST_WELSCH=6, CONST DIST_HUBER=7]
[CONST FLOODFILL_FIXED_RANGE=1 << 16, CONST FLOODFILL_MASK_ONLY=1 << 17]
[CONST GC_BGD=0, CONST GC_FGD=1, CONST GC_PR_BGD=2, CONST GC_PR_FGD=3]
[CONST GC_INIT_WITH_RECT=0, CONST GC_INIT_WITH_MASK=1, CONST GC_EVAL=2, CONST GC_EVAL_FREEZE_MODEL=3]
[CONST FONT_HERSHEY_SIMPLEX=0, CONST FONT_HERSHEY_PLAIN=1, CONST FONT_HERSHEY_DUPLEX=2, CONST FONT_HERSHEY_COMPLEX=3, CONST FONT_HERSHEY_TRIPLEX=4, CONST FONT_HERSHEY_COMPLEX_SMALL=5, CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6, CONST FONT_HERSHEY_SCRIPT_COMPLEX=7, CONST FONT_ITALIC=16]
[CONST HISTCMP_CORREL=0, CONST HISTCMP_CHISQR=1, CONST HISTCMP_INTERSECT=2, CONST HISTCMP_BHATTACHARYYA=3, CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA, CONST HISTCMP_CHISQR_ALT=4, CONST HISTCMP_KL_DIV=5]
[CONST HOUGH_STANDARD=0, CONST HOUGH_PROBABILISTIC=1, CONST HOUGH_MULTI_SCALE=2, CONST HOUGH_GRADIENT=3, CONST HOUGH_GRADIENT_ALT=4]
[CONST INTER_NEAREST=0, CONST INTER_LINEAR=1, CONST INTER_CUBIC=2, CONST INTER_AREA=3, CONST INTER_LANCZOS4=4, CONST INTER_LINEAR_EXACT=5, CONST INTER_NEAREST_EXACT=6, CONST INTER_MAX=7, CONST WARP_FILL_OUTLIERS=8, CONST WARP_INVERSE_MAP=16]
[CONST INTER_BITS=5, CONST INTER_BITS2=INTER_BITS * 2, CONST INTER_TAB_SIZE=1 << INTER_BITS, CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE]
[CONST LSD_REFINE_NONE=0, CONST LSD_REFINE_STD=1, CONST LSD_REFINE_ADV=2]
[CONST FILLED=-1, CONST LINE_4=4, CONST LINE_8=8, CONST LINE_AA=16]
[CONST MARKER_CROSS=0, CONST MARKER_TILTED_CROSS=1, CONST MARKER_STAR=2, CONST MARKER_DIAMOND=3, CONST MARKER_SQUARE=4, CONST MARKER_TRIANGLE_UP=5, CONST MARKER_TRIANGLE_DOWN=6]
[CONST MORPH_RECT=0, CONST MORPH_CROSS=1, CONST MORPH_ELLIPSE=2]
[CONST MORPH_ERODE=0, CONST MORPH_DILATE=1, CONST MORPH_OPEN=2, CONST MORPH_CLOSE=3, CONST MORPH_GRADIENT=4, CONST MORPH_TOPHAT=5, CONST MORPH_BLACKHAT=6, CONST MORPH_HITMISS=7]
[CONST INTERSECT_NONE=0, CONST INTERSECT_PARTIAL=1, CONST INTERSECT_FULL=2]
[CONST RETR_EXTERNAL=0, CONST RETR_LIST=1, CONST RETR_CCOMP=2, CONST RETR_TREE=3, CONST RETR_FLOODFILL=4]
[CONST CONTOURS_MATCH_I1=1, CONST CONTOURS_MATCH_I2=2, CONST CONTOURS_MATCH_I3=3]
[CONST FILTER_SCHARR=-1]
[CONST TM_SQDIFF=0, CONST TM_SQDIFF_NORMED=1, CONST TM_CCORR=2, CONST TM_CCORR_NORMED=3, CONST TM_CCOEFF=4, CONST TM_CCOEFF_NORMED=5]
[CONST THRESH_BINARY=0, CONST THRESH_BINARY_INV=1, CONST THRESH_TRUNC=2, CONST THRESH_TOZERO=3, CONST THRESH_TOZERO_INV=4, CONST THRESH_MASK=7, CONST THRESH_OTSU=8, CONST THRESH_TRIANGLE=16]
[CONST WARP_POLAR_LINEAR=0, CONST WARP_POLAR_LOG=256]
FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int refine=LSD_REFINE_STD, ARG double scale=0.8, ARG double sigma_scale=0.6, ARG double quant=2.0, ARG double ang_th=22.5, ARG double log_eps=0, ARG double density_th=0.7, ARG int n_bins=1024]>
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale, double quant, double ang_th, double log_eps, double density_th, int n_bins)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale, double quant, double ang_th, double log_eps, double density_th)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale, double quant, double ang_th, double log_eps)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale, double quant, double ang_th)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale, double quant)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale, double sigma_scale)
java: LineSegmentDetector createLineSegmentDetector(int refine, double scale)
java: LineSegmentDetector createLineSegmentDetector(int refine)
java: LineSegmentDetector createLineSegmentDetector()
FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>
java: Mat getGaussianKernel(int ksize, double sigma, int ktype)
java: Mat getGaussianKernel(int ksize, double sigma)
FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize, int ktype)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize)
FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma)
FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>
java: Mat getStructuringElement(int shape, Size ksize, Point anchor)
java: Mat getStructuringElement(int shape, Size ksize)
FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>
java: void medianBlur(Mat src, Mat dst, int ksize)
FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY, int borderType)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX)
FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>
java: void blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)
java: void blur(Mat src, Mat dst, Size ksize, Point anchor)
java: void blur(Mat src, Mat dst, Size ksize)
FUNC <void cv..stackBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=]>
java: void stackBlur(Mat src, Mat dst, Size ksize)
FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta, int borderType)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel)
FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta, int borderType)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY)
FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize, int borderType)
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize)
java: void spatialGradient(Mat src, Mat dx, Mat dy)
FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta, int borderType)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize)
java: void Laplacian(Mat src, Mat dst, int ddepth)
FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize, boolean L2gradient)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2)
FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2, boolean L2gradient)
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2)
FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize)
FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k, int borderType)
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k)
FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize)
FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void preCornerDetect(Mat src, Mat dst, int ksize, int borderType)
java: void preCornerDetect(Mat src, Mat dst, int ksize)
FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>
java: void cornerSubPix(Mat image, Mat corners, Size winSize, Size zeroZone, TermCriteria criteria)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG Mat corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG Mat cornersQuality=, ARG int blockSize=3, ARG int gradientSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrackWithQuality(Mat image, Mat corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, Mat cornersQuality, int blockSize, int gradientSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrackWithQuality(Mat image, Mat corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, Mat cornersQuality, int blockSize, int gradientSize, boolean useHarrisDetector)
java: void goodFeaturesToTrackWithQuality(Mat image, Mat corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, Mat cornersQuality, int blockSize, int gradientSize)
java: void goodFeaturesToTrackWithQuality(Mat image, Mat corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, Mat cornersQuality, int blockSize)
java: void goodFeaturesToTrackWithQuality(Mat image, Mat corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, Mat cornersQuality)
FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesPointSet [ARG Mat point=, ARG Mat lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>
java: void HoughLinesPointSet(Mat point, Mat lines, int lines_max, int threshold, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step)
FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist)
FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor)
java: void erode(Mat src, Mat dst, Mat kernel)
FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor)
java: void dilate(Mat src, Mat dst, Mat kernel)
FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel)
FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy, int interpolation)
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy)
java: void resize(Mat src, Mat dst, Size dsize, double fx)
java: void resize(Mat src, Mat dst, Size dsize)
FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode, Scalar borderValue)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation)
FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type, boolean nninterpolation)
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type)
FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>
java: Mat getRotationMatrix2D(Point center, double angle, double scale)
FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>
java: void invertAffineTransform(Mat M, Mat iM)
FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>
java: Mat getPerspectiveTransform(Mat src, Mat dst, int solveMethod)
java: Mat getPerspectiveTransform(Mat src, Mat dst)
FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>
java: Mat getAffineTransform(MatOfPoint2f src, MatOfPoint2f dst)
FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch, int patchType)
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch)
FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>
java: void logPolar(Mat src, Mat dst, Point center, double M, int flags)
FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void linearPolar(Mat src, Mat dst, Point center, double maxRadius, int flags)
FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void warpPolar(Mat src, Mat dst, Size dsize, Point center, double maxRadius, int flags)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth, int sqdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>
java: void integral(Mat src, Mat sum, int sdepth)
java: void integral(Mat src, Mat sum)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth, int sqdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum)
FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulate(Mat src, Mat dst, Mat mask)
java: void accumulate(Mat src, Mat dst)
FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateSquare(Mat src, Mat dst, Mat mask)
java: void accumulateSquare(Mat src, Mat dst)
FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateProduct(Mat src1, Mat src2, Mat dst, Mat mask)
java: void accumulateProduct(Mat src1, Mat src2, Mat dst)
FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>
java: void accumulateWeighted(Mat src, Mat dst, double alpha, Mat mask)
java: void accumulateWeighted(Mat src, Mat dst, double alpha)
FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window, double[] response)
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window)
java: Point phaseCorrelate(Mat src1, Mat src2)
FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>
java: void createHanningWindow(Mat dst, Size winSize, int type)
FUNC <void cv..divSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>
java: void divSpectrums(Mat a, Mat b, Mat c, int flags, boolean conjB)
java: void divSpectrums(Mat a, Mat b, Mat c, int flags)
FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>
java: double threshold(Mat src, Mat dst, double thresh, double maxval, int type)
FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>
java: void adaptiveThreshold(Mat src, Mat dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)
FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrDown(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrDown(Mat src, Mat dst, Size dstsize)
java: void pyrDown(Mat src, Mat dst)
FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrUp(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrUp(Mat src, Mat dst, Size dstsize)
java: void pyrUp(Mat src, Mat dst)
FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges, boolean accumulate)
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges)
FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>
java: void calcBackProject(List<Mat> images, MatOfInt channels, Mat hist, Mat dst, MatOfFloat ranges, double scale)
FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>
java: double compareHist(Mat H1, Mat H2, int method)
FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>
java: void equalizeHist(Mat src, Mat dst)
FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>
java: CLAHE createCLAHE(double clipLimit, Size tileGridSize)
java: CLAHE createCLAHE(double clipLimit)
java: CLAHE createCLAHE()
FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost, Mat flow)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType)
FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>
java: void watershed(Mat image, Mat markers)
FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel, TermCriteria termcrit)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr)
FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount, int mode)
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize, int labelType)
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize, int dstType)
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize)
FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff, int flags)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)
FUNC <void cv..blendLinear [ARG Mat src1=, ARG Mat src2=, ARG Mat weights1=, ARG Mat weights2=, ARG Mat dst=]>
java: void blendLinear(Mat src1, Mat src2, Mat weights1, Mat weights2, Mat dst)
FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void cvtColor(Mat src, Mat dst, int code, int dstCn)
java: void cvtColor(Mat src, Mat dst, int code)
FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>
java: void cvtColorTwoPlane(Mat src1, Mat src2, Mat dst, int code)
FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void demosaicing(Mat src, Mat dst, int code, int dstCn)
java: void demosaicing(Mat src, Mat dst, int code)
FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>
java: Moments moments(Mat array, boolean binaryImage)
java: Moments moments(Mat array)
FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>
java: void HuMoments(Moments m, Mat hu)
FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>
java: void matchTemplate(Mat image, Mat templ, Mat result, int method, Mat mask)
java: void matchTemplate(Mat image, Mat templ, Mat result, int method)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithAlgorithm(Mat image, Mat labels, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponents(Mat image, Mat labels, int connectivity, int ltype)
java: int connectedComponents(Mat image, Mat labels, int connectivity)
java: int connectedComponents(Mat image, Mat labels)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithStatsWithAlgorithm(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids)
FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method, Point offset)
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method)
FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>
java: void approxPolyDP(MatOfPoint2f curve, MatOfPoint2f approxCurve, double epsilon, boolean closed)
FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>
java: double arcLength(MatOfPoint2f curve, boolean closed)
FUNC <Rect cv..boundingRect [ARG Mat array=]>
java: Rect boundingRect(Mat array)
FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>
java: double contourArea(Mat contour, boolean oriented)
java: double contourArea(Mat contour)
FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>
java: RotatedRect minAreaRect(MatOfPoint2f points)
FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>
java: void boxPoints(RotatedRect box, Mat points)
FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>
java: void minEnclosingCircle(MatOfPoint2f points, Point center, float[] radius)
FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>
java: double minEnclosingTriangle(Mat points, Mat triangle)
FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>
java: double matchShapes(Mat contour1, Mat contour2, int method, double parameter)
FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull)
FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>
java: void convexityDefects(MatOfPoint contour, MatOfInt convexhull, MatOfInt4 convexityDefects)
FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>
java: boolean isContourConvex(MatOfPoint contour)
FUNC <float cv..intersectConvexConvex [ARG Mat p1=, ARG Mat p2=, ARG Mat p12=, ARG bool handleNested=true]>
java: float intersectConvexConvex(Mat p1, Mat p2, Mat p12, boolean handleNested)
java: float intersectConvexConvex(Mat p1, Mat p2, Mat p12)
FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>
java: RotatedRect fitEllipse(MatOfPoint2f points)
FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>
java: RotatedRect fitEllipseAMS(Mat points)
FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>
java: RotatedRect fitEllipseDirect(Mat points)
FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>
java: void fitLine(Mat points, Mat line, int distType, double param, double reps, double aeps)
FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>
java: double pointPolygonTest(MatOfPoint2f contour, Point pt, boolean measureDist)
FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>
java: int rotatedRectangleIntersection(RotatedRect rect1, RotatedRect rect2, Mat intersectingRegion)
FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>
java: GeneralizedHoughBallard createGeneralizedHoughBallard()
FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>
java: GeneralizedHoughGuil createGeneralizedHoughGuil()
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>
java: void applyColorMap(Mat src, Mat dst, int colormap)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>
java: void applyColorMap(Mat src, Mat dst, Mat userColor)
FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void line(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift, double tipLength)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness)
java: void rectangle(Mat img, Rect rec, Scalar color)
FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType, int shift)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness)
java: void circle(Mat img, Point center, int radius, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType, int shift)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness)
java: void ellipse(Mat img, RotatedRect box, Scalar color)
FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness, int line_type)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType)
java: void drawMarker(Mat img, Point position, Scalar color)
FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType, int shift)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color)
FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift, Point offset)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color)
FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType, int shift)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color)
FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel, Point offset)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color)
FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>
java: boolean clipLine(Rect imgRect, Point pt1, Point pt2)
FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>
java: void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, MatOfPoint pts)
FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, boolean bottomLeftOrigin)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color)
FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>
java: double getFontScaleFromHeight(int fontFace, int pixelHeight, int thickness)
java: double getFontScaleFromHeight(int fontFace, int pixelHeight)
FUNC <void cv..HoughLinesWithAccumulator [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>
java: void HoughLinesWithAccumulator(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)
java: void HoughLinesWithAccumulator(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta)
java: void HoughLinesWithAccumulator(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn)
java: void HoughLinesWithAccumulator(Mat image, Mat lines, double rho, double theta, int threshold, double srn)
java: void HoughLinesWithAccumulator(Mat image, Mat lines, double rho, double theta, int threshold)
manual function: getTextSize
CLASS cv::.LineSegmentDetector : Algorithm
FUNC <void cv.LineSegmentDetector.detect [ARG Mat image=, ARG Mat lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>
java: void detect(Mat image, Mat lines, Mat width, Mat prec, Mat nfa)
java: void detect(Mat image, Mat lines, Mat width, Mat prec)
java: void detect(Mat image, Mat lines, Mat width)
java: void detect(Mat image, Mat lines)
FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat image=, ARG Mat lines=]>
java: void drawSegments(Mat image, Mat lines)
FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat image=Mat()]>
java: int compareSegments(Size size, Mat lines1, Mat lines2, Mat image)
java: int compareSegments(Size size, Mat lines1, Mat lines2)
CLASS cv::.Subdiv2D : 
[CONST PTLOC_ERROR=-2, CONST PTLOC_OUTSIDE_RECT=-1, CONST PTLOC_INSIDE=0, CONST PTLOC_VERTEX=1, CONST PTLOC_ON_EDGE=2, CONST NEXT_AROUND_ORG=0x00, CONST NEXT_AROUND_DST=0x22, CONST PREV_AROUND_ORG=0x11, CONST PREV_AROUND_DST=0x33, CONST NEXT_AROUND_LEFT=0x13, CONST NEXT_AROUND_RIGHT=0x31, CONST PREV_AROUND_LEFT=0x20, CONST PREV_AROUND_RIGHT=0x02]
FUNC < cv.Subdiv2D.Subdiv2D []>
java:  Subdiv2D()
FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>
java:  Subdiv2D(Rect rect)
FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>
java: void initDelaunay(Rect rect)
FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>
java: int insert(Point pt)
FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>
java: void insert(MatOfPoint2f ptvec)
FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>
java: int locate(Point pt, int[] edge, int[] vertex)
FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>
java: int findNearest(Point pt, Point nearestPt)
java: int findNearest(Point pt)
FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>
java: void getEdgeList(MatOfFloat4 edgeList)
FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>
java: void getLeadingEdgeList(MatOfInt leadingEdgeList)
FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>
java: void getTriangleList(MatOfFloat6 triangleList)
FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>
java: void getVoronoiFacetList(MatOfInt idx, List<MatOfPoint2f> facetList, MatOfPoint2f facetCenters)
FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>
java: Point getVertex(int vertex, int[] firstEdge)
java: Point getVertex(int vertex)
FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>
java: int getEdge(int edge, int nextEdgeType)
FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>
java: int nextEdge(int edge)
FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>
java: int rotateEdge(int edge, int rotate)
FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>
java: int symEdge(int edge)
FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>
java: int edgeOrg(int edge, Point orgpt)
java: int edgeOrg(int edge)
FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>
java: int edgeDst(int edge, Point dstpt)
java: int edgeDst(int edge)
CLASS cv.segmentation::.IntelligentScissorsMB : 
FUNC < cv.segmentation.IntelligentScissorsMB.IntelligentScissorsMB []>
java:  IntelligentScissorsMB()
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setWeights [ARG float weight_non_edge=, ARG float weight_gradient_direction=, ARG float weight_gradient_magnitude=]>
java: IntelligentScissorsMB setWeights(float weight_non_edge, float weight_gradient_direction, float weight_gradient_magnitude)
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setGradientMagnitudeMaxLimit [ARG float gradient_magnitude_threshold_max=0.0f]>
java: IntelligentScissorsMB setGradientMagnitudeMaxLimit(float gradient_magnitude_threshold_max)
java: IntelligentScissorsMB setGradientMagnitudeMaxLimit()
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setEdgeFeatureZeroCrossingParameters [ARG float gradient_magnitude_min_value=0.0f]>
java: IntelligentScissorsMB setEdgeFeatureZeroCrossingParameters(float gradient_magnitude_min_value)
java: IntelligentScissorsMB setEdgeFeatureZeroCrossingParameters()
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.setEdgeFeatureCannyParameters [ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>
java: IntelligentScissorsMB setEdgeFeatureCannyParameters(double threshold1, double threshold2, int apertureSize, boolean L2gradient)
java: IntelligentScissorsMB setEdgeFeatureCannyParameters(double threshold1, double threshold2, int apertureSize)
java: IntelligentScissorsMB setEdgeFeatureCannyParameters(double threshold1, double threshold2)
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.applyImage [ARG Mat image=]>
java: IntelligentScissorsMB applyImage(Mat image)
FUNC <IntelligentScissorsMB cv.segmentation.IntelligentScissorsMB.applyImageFeatures [ARG Mat non_edge=, ARG Mat gradient_direction=, ARG Mat gradient_magnitude=, ARG Mat image=Mat()]>
java: IntelligentScissorsMB applyImageFeatures(Mat non_edge, Mat gradient_direction, Mat gradient_magnitude, Mat image)
java: IntelligentScissorsMB applyImageFeatures(Mat non_edge, Mat gradient_direction, Mat gradient_magnitude)
FUNC <void cv.segmentation.IntelligentScissorsMB.buildMap [ARG Point sourcePt=]>
java: void buildMap(Point sourcePt)
FUNC <void cv.segmentation.IntelligentScissorsMB.getContour [ARG Point targetPt=, ARG Mat contour=, ARG bool backward=false]>
java: void getContour(Point targetPt, Mat contour, boolean backward)
java: void getContour(Point targetPt, Mat contour)

=== MODULE: ml (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml) ===


Files (2):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml/include/opencv2/ml.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml/include/opencv2/ml/ml.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Ml : , name: Ml, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml/include/opencv2/ml.hpp =====
Namespaces: ['cv', 'cv.ml']

--- Incoming ---
[   'enum cv.ml.VariableTypes',
    '',
    [],
    [   ['const cv.ml.VAR_NUMERICAL', '0', [], [], None, ''],
        ['const cv.ml.VAR_ORDERED', '0', [], [], None, ''],
        ['const cv.ml.VAR_CATEGORICAL', '1', [], [], None, '']],
    None]
ok: CONST VAR_NUMERICAL=0
ok: CONST VAR_ORDERED=0
ok: CONST VAR_CATEGORICAL=1

--- Incoming ---
[   'enum cv.ml.ErrorTypes',
    '',
    [],
    [   ['const cv.ml.TEST_ERROR', '0', [], [], None, ''],
        ['const cv.ml.TRAIN_ERROR', '1', [], [], None, '']],
    None]
ok: CONST TEST_ERROR=0
ok: CONST TRAIN_ERROR=1

--- Incoming ---
[   'enum cv.ml.SampleTypes',
    '',
    [],
    [   ['const cv.ml.ROW_SAMPLE', '0', [], [], None, ''],
        ['const cv.ml.COL_SAMPLE', '1', [], [], None, '']],
    None]
ok: CONST ROW_SAMPLE=0
ok: CONST COL_SAMPLE=1

--- Incoming ---
[   'class cv.ml.ParamGrid',
    '',
    [],
    [   ['double', 'minVal', '', ['/RW']],
        ['double', 'maxVal', '', ['/RW']],
        ['double', 'logStep', '', ['/RW']]],
    None]
ok: class CLASS cv.ml::.ParamGrid : , name: ParamGrid, base: 

--- Incoming ---
[   'cv.ml.ParamGrid.create',
    'Ptr_ParamGrid',
    ['/S'],
    [   ['double', 'minVal', '0.', []],
        ['double', 'maxVal', '0.', []],
        ['double', 'logstep', '1.', []]],
    'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>

--- Incoming ---
['class cv.ml.TrainData', '', [], [], None]
ok: class CLASS cv.ml::.TrainData : , name: TrainData, base: 

--- Incoming ---
['cv.ml.TrainData.getLayout', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getLayout []>

--- Incoming ---
['cv.ml.TrainData.getNTrainSamples', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getNTrainSamples []>

--- Incoming ---
['cv.ml.TrainData.getNTestSamples', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getNTestSamples []>

--- Incoming ---
['cv.ml.TrainData.getNSamples', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getNSamples []>

--- Incoming ---
['cv.ml.TrainData.getNVars', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getNVars []>

--- Incoming ---
['cv.ml.TrainData.getNAllVars', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getNAllVars []>

--- Incoming ---
[   'cv.ml.TrainData.getSample',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'varIdx', '', []],
        ['int', 'sidx', '', []],
        ['float*', 'buf', '', []]],
    'void']
ok: FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>

--- Incoming ---
['cv.ml.TrainData.getSamples', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSamples []>

--- Incoming ---
['cv.ml.TrainData.getMissing', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getMissing []>

--- Incoming ---
[   'cv.ml.TrainData.getTrainSamples',
    'Mat',
    ['/C', '/V', '/PV'],
    [   ['int', 'layout', 'ROW_SAMPLE', []],
        ['bool', 'compressSamples', 'true', []],
        ['bool', 'compressVars', 'true', []]],
    'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>

--- Incoming ---
['cv.ml.TrainData.getTrainResponses', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainResponses []>

--- Incoming ---
[   'cv.ml.TrainData.getTrainNormCatResponses',
    'Mat',
    ['/C', '/V', '/PV'],
    [],
    'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>

--- Incoming ---
['cv.ml.TrainData.getTestResponses', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestResponses []>

--- Incoming ---
[   'cv.ml.TrainData.getTestNormCatResponses',
    'Mat',
    ['/C', '/V', '/PV'],
    [],
    'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>

--- Incoming ---
['cv.ml.TrainData.getResponses', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getResponses []>

--- Incoming ---
['cv.ml.TrainData.getNormCatResponses', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getNormCatResponses []>

--- Incoming ---
['cv.ml.TrainData.getSampleWeights', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSampleWeights []>

--- Incoming ---
['cv.ml.TrainData.getTrainSampleWeights', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>

--- Incoming ---
['cv.ml.TrainData.getTestSampleWeights', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>

--- Incoming ---
['cv.ml.TrainData.getVarIdx', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarIdx []>

--- Incoming ---
['cv.ml.TrainData.getVarType', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarType []>

--- Incoming ---
['cv.ml.TrainData.getVarSymbolFlags', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>

--- Incoming ---
['cv.ml.TrainData.getResponseType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.TrainData.getResponseType []>

--- Incoming ---
['cv.ml.TrainData.getTrainSampleIdx', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>

--- Incoming ---
['cv.ml.TrainData.getTestSampleIdx', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>

--- Incoming ---
[   'cv.ml.TrainData.getValues',
    'void',
    ['/C', '/V', '/PV'],
    [   ['int', 'vi', '', []],
        ['Mat', 'sidx', '', []],
        ['float*', 'values', '', []]],
    'void']
ok: FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>

--- Incoming ---
['cv.ml.TrainData.getDefaultSubstValues', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>

--- Incoming ---
[   'cv.ml.TrainData.getCatCount',
    'int',
    ['/C', '/V', '/PV'],
    [['int', 'vi', '', []]],
    'int']
ok: FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>

--- Incoming ---
['cv.ml.TrainData.getClassLabels', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getClassLabels []>

--- Incoming ---
['cv.ml.TrainData.getCatOfs', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatOfs []>

--- Incoming ---
['cv.ml.TrainData.getCatMap', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatMap []>

--- Incoming ---
[   'cv.ml.TrainData.setTrainTestSplit',
    'void',
    ['/V', '/PV'],
    [['int', 'count', '', []], ['bool', 'shuffle', 'true', []]],
    'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>

--- Incoming ---
[   'cv.ml.TrainData.setTrainTestSplitRatio',
    'void',
    ['/V', '/PV'],
    [['double', 'ratio', '', []], ['bool', 'shuffle', 'true', []]],
    'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>

--- Incoming ---
['cv.ml.TrainData.shuffleTrainTest', 'void', ['/V', '/PV'], [], 'void']
ok: FUNC <void cv.ml.TrainData.shuffleTrainTest []>

--- Incoming ---
['cv.ml.TrainData.getTestSamples', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSamples []>

--- Incoming ---
[   'cv.ml.TrainData.getNames',
    'void',
    ['/C', '/V', '/PV'],
    [['vector_String', 'names', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>

--- Incoming ---
[   'cv.ml.TrainData.getSubVector',
    'Mat',
    ['/S'],
    [['Mat', 'vec', '', ['/C', '/Ref']], ['Mat', 'idx', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>

--- Incoming ---
[   'cv.ml.TrainData.getSubMatrix',
    'Mat',
    ['/S'],
    [   ['Mat', 'matrix', '', ['/C', '/Ref']],
        ['Mat', 'idx', '', ['/C', '/Ref']],
        ['int', 'layout', '', []]],
    'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>

--- Incoming ---
[   'cv.ml.TrainData.create',
    'Ptr_TrainData',
    ['/S'],
    [   ['Mat', 'samples', '', []],
        ['int', 'layout', '', []],
        ['Mat', 'responses', '', []],
        ['Mat', 'varIdx', 'Mat()', []],
        ['Mat', 'sampleIdx', 'Mat()', []],
        ['Mat', 'sampleWeights', 'Mat()', []],
        ['Mat', 'varType', 'Mat()', []]],
    'Ptr<TrainData>']
ok: FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>

--- Incoming ---
['class cv.ml.StatModel', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ml::.StatModel : Algorithm, name: StatModel, base: Algorithm

--- Incoming ---
[   'enum cv.ml.StatModel.Flags',
    '',
    [],
    [   ['const cv.ml.StatModel.UPDATE_MODEL', '1', [], [], None, ''],
        ['const cv.ml.StatModel.RAW_OUTPUT', '1', [], [], None, ''],
        ['const cv.ml.StatModel.COMPRESSED_INPUT', '2', [], [], None, ''],
        ['const cv.ml.StatModel.PREPROCESSED_INPUT', '4', [], [], None, '']],
    None]
ok: CONST UPDATE_MODEL=1
ok: CONST RAW_OUTPUT=1
ok: CONST COMPRESSED_INPUT=2
ok: CONST PREPROCESSED_INPUT=4

--- Incoming ---
['cv.ml.StatModel.getVarCount', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.StatModel.getVarCount []>

--- Incoming ---
['cv.ml.StatModel.empty', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.ml.StatModel.empty []>

--- Incoming ---
['cv.ml.StatModel.isTrained', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.StatModel.isTrained []>

--- Incoming ---
['cv.ml.StatModel.isClassifier', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.StatModel.isClassifier []>

--- Incoming ---
[   'cv.ml.StatModel.train',
    'bool',
    ['/V'],
    [   ['Ptr_TrainData', 'trainData', '', ['/C', '/Ref']],
        ['int', 'flags', '0', []]],
    'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>

--- Incoming ---
[   'cv.ml.StatModel.train',
    'bool',
    ['/V'],
    [   ['Mat', 'samples', '', []],
        ['int', 'layout', '', []],
        ['Mat', 'responses', '', []]],
    'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>

--- Incoming ---
[   'cv.ml.StatModel.calcError',
    'float',
    ['/C', '/V'],
    [   ['Ptr_TrainData', 'data', '', ['/C', '/Ref']],
        ['bool', 'test', '', []],
        ['Mat', 'resp', '', ['/O']]],
    'float']
ok: FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>

--- Incoming ---
[   'cv.ml.StatModel.predict',
    'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'results', 'Mat()', ['/O']],
        ['int', 'flags', '0', []]],
    'float']
ok: FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
['class cv.ml.NormalBayesClassifier', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.NormalBayesClassifier : StatModel, name: NormalBayesClassifier, base: StatModel

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.predictProb',
    'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'inputs', '', []],
        ['Mat', 'outputs', '', ['/O']],
        ['Mat', 'outputProbs', '', ['/O']],
        ['int', 'flags', '0', []]],
    'float']
ok: FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.create',
    'Ptr_NormalBayesClassifier',
    ['/S'],
    [],
    'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>

--- Incoming ---
[   'cv.ml.NormalBayesClassifier.load',
    'Ptr_NormalBayesClassifier',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.KNearest', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.KNearest : StatModel, name: KNearest, base: StatModel

--- Incoming ---
['cv.ml.KNearest.getDefaultK', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.KNearest.getDefaultK []>

--- Incoming ---
[   'cv.ml.KNearest.setDefaultK',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>

--- Incoming ---
['cv.ml.KNearest.getIsClassifier', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.KNearest.getIsClassifier []>

--- Incoming ---
[   'cv.ml.KNearest.setIsClassifier',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>

--- Incoming ---
['cv.ml.KNearest.getEmax', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.KNearest.getEmax []>

--- Incoming ---
[   'cv.ml.KNearest.setEmax',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>

--- Incoming ---
['cv.ml.KNearest.getAlgorithmType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.KNearest.getAlgorithmType []>

--- Incoming ---
[   'cv.ml.KNearest.setAlgorithmType',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>

--- Incoming ---
[   'cv.ml.KNearest.findNearest',
    'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['int', 'k', '', []],
        ['Mat', 'results', '', ['/O']],
        ['Mat', 'neighborResponses', 'Mat()', ['/O']],
        ['Mat', 'dist', 'Mat()', ['/O']]],
    'float']
ok: FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>

--- Incoming ---
[   'enum cv.ml.KNearest.Types',
    '',
    [],
    [   ['const cv.ml.KNearest.BRUTE_FORCE', '1', [], [], None, ''],
        ['const cv.ml.KNearest.KDTREE', '2', [], [], None, '']],
    None]
ok: CONST BRUTE_FORCE=1
ok: CONST KDTREE=2

--- Incoming ---
['cv.ml.KNearest.create', 'Ptr_KNearest', ['/S'], [], 'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.create []>

--- Incoming ---
[   'cv.ml.KNearest.load',
    'Ptr_KNearest',
    ['/S'],
    [['String', 'filepath', '', ['/C', '/Ref']]],
    'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>

--- Incoming ---
['class cv.ml.SVM', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVM : StatModel, name: SVM, base: StatModel

--- Incoming ---
['cv.ml.SVM.getType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.SVM.getType []>

--- Incoming ---
['cv.ml.SVM.setType', 'void', ['/V', '/PV'], [['int', 'val', '', []]], 'void']
ok: FUNC <void cv.ml.SVM.setType [ARG int val=]>

--- Incoming ---
['cv.ml.SVM.getGamma', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getGamma []>

--- Incoming ---
[   'cv.ml.SVM.setGamma',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.SVM.setGamma [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getCoef0', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getCoef0 []>

--- Incoming ---
[   'cv.ml.SVM.setCoef0',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getDegree', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getDegree []>

--- Incoming ---
[   'cv.ml.SVM.setDegree',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.SVM.setDegree [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getC', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getC []>

--- Incoming ---
['cv.ml.SVM.setC', 'void', ['/V', '/PV'], [['double', 'val', '', []]], 'void']
ok: FUNC <void cv.ml.SVM.setC [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getNu', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getNu []>

--- Incoming ---
['cv.ml.SVM.setNu', 'void', ['/V', '/PV'], [['double', 'val', '', []]], 'void']
ok: FUNC <void cv.ml.SVM.setNu [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getP', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.SVM.getP []>

--- Incoming ---
['cv.ml.SVM.setP', 'void', ['/V', '/PV'], [['double', 'val', '', []]], 'void']
ok: FUNC <void cv.ml.SVM.setP [ARG double val=]>

--- Incoming ---
['cv.ml.SVM.getClassWeights', 'Mat', ['/C', '/V', '/PV'], [], 'cv::Mat']
ok: FUNC <Mat cv.ml.SVM.getClassWeights []>

--- Incoming ---
[   'cv.ml.SVM.setClassWeights',
    'void',
    ['/V', '/PV'],
    [['Mat', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>

--- Incoming ---
[   'cv.ml.SVM.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'cv::TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>

--- Incoming ---
[   'cv.ml.SVM.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
['cv.ml.SVM.getKernelType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.SVM.getKernelType []>

--- Incoming ---
[   'cv.ml.SVM.setKernel',
    'void',
    ['/V', '/PV'],
    [['int', 'kernelType', '', []]],
    'void']
ok: FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>

--- Incoming ---
[   'enum cv.ml.SVM.Types',
    '',
    [],
    [   ['const cv.ml.SVM.C_SVC', '100', [], [], None, ''],
        ['const cv.ml.SVM.NU_SVC', '101', [], [], None, ''],
        ['const cv.ml.SVM.ONE_CLASS', '102', [], [], None, ''],
        ['const cv.ml.SVM.EPS_SVR', '103', [], [], None, ''],
        ['const cv.ml.SVM.NU_SVR', '104', [], [], None, '']],
    None]
ok: CONST C_SVC=100
ok: CONST NU_SVC=101
ok: CONST ONE_CLASS=102
ok: CONST EPS_SVR=103
ok: CONST NU_SVR=104

--- Incoming ---
[   'enum cv.ml.SVM.KernelTypes',
    '',
    [],
    [   ['const cv.ml.SVM.CUSTOM', '-1', [], [], None, ''],
        ['const cv.ml.SVM.LINEAR', '0', [], [], None, ''],
        ['const cv.ml.SVM.POLY', '1', [], [], None, ''],
        ['const cv.ml.SVM.RBF', '2', [], [], None, ''],
        ['const cv.ml.SVM.SIGMOID', '3', [], [], None, ''],
        ['const cv.ml.SVM.CHI2', '4', [], [], None, ''],
        ['const cv.ml.SVM.INTER', '5', [], [], None, '']],
    None]
ok: CONST CUSTOM=-1
ok: CONST LINEAR=0
ok: CONST POLY=1
ok: CONST RBF=2
ok: CONST SIGMOID=3
ok: CONST CHI2=4
ok: CONST INTER=5

--- Incoming ---
[   'enum cv.ml.SVM.ParamTypes',
    '',
    [],
    [   ['const cv.ml.SVM.C', '0', [], [], None, ''],
        ['const cv.ml.SVM.GAMMA', '1', [], [], None, ''],
        ['const cv.ml.SVM.P', '2', [], [], None, ''],
        ['const cv.ml.SVM.NU', '3', [], [], None, ''],
        ['const cv.ml.SVM.COEF', '4', [], [], None, ''],
        ['const cv.ml.SVM.DEGREE', '5', [], [], None, '']],
    None]
ok: CONST C=0
ok: CONST GAMMA=1
ok: CONST P=2
ok: CONST NU=3
ok: CONST COEF=4
ok: CONST DEGREE=5

--- Incoming ---
[   'cv.ml.SVM.trainAuto',
    'bool',
    ['/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['int', 'layout', '', []],
        ['Mat', 'responses', '', []],
        ['int', 'kFold', '10', []],
        ['Ptr_ParamGrid', 'Cgrid', 'SVM::getDefaultGridPtr(SVM::C)', []],
        [   'Ptr_ParamGrid',
            'gammaGrid',
            'SVM::getDefaultGridPtr(SVM::GAMMA)',
            []],
        ['Ptr_ParamGrid', 'pGrid', 'SVM::getDefaultGridPtr(SVM::P)', []],
        ['Ptr_ParamGrid', 'nuGrid', 'SVM::getDefaultGridPtr(SVM::NU)', []],
        ['Ptr_ParamGrid', 'coeffGrid', 'SVM::getDefaultGridPtr(SVM::COEF)', []],
        [   'Ptr_ParamGrid',
            'degreeGrid',
            'SVM::getDefaultGridPtr(SVM::DEGREE)',
            []],
        ['bool', 'balanced', 'false', []]],
    'bool']
ok: FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>

--- Incoming ---
['cv.ml.SVM.getSupportVectors', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.SVM.getSupportVectors []>

--- Incoming ---
[   'cv.ml.SVM.getUncompressedSupportVectors',
    'Mat',
    ['/C', '/V', '/PV'],
    [],
    'Mat']
ok: FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>

--- Incoming ---
[   'cv.ml.SVM.getDecisionFunction',
    'double',
    ['/C', '/V', '/PV'],
    [   ['int', 'i', '', []],
        ['Mat', 'alpha', '', ['/O']],
        ['Mat', 'svidx', '', ['/O']]],
    'double']
ok: FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>

--- Incoming ---
[   'cv.ml.SVM.getDefaultGridPtr',
    'Ptr_ParamGrid',
    ['/S'],
    [['int', 'param_id', '', []]],
    'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>

--- Incoming ---
['cv.ml.SVM.create', 'Ptr_SVM', ['/S'], [], 'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.create []>

--- Incoming ---
[   'cv.ml.SVM.load',
    'Ptr_SVM',
    ['/S'],
    [['String', 'filepath', '', ['/C', '/Ref']]],
    'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>

--- Incoming ---
['class cv.ml.EM', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.EM : StatModel, name: EM, base: StatModel

--- Incoming ---
[   'enum cv.ml.EM.Types',
    '',
    [],
    [   ['const cv.ml.EM.COV_MAT_SPHERICAL', '0', [], [], None, ''],
        ['const cv.ml.EM.COV_MAT_DIAGONAL', '1', [], [], None, ''],
        ['const cv.ml.EM.COV_MAT_GENERIC', '2', [], [], None, ''],
        [   'const cv.ml.EM.COV_MAT_DEFAULT',
            'COV_MAT_DIAGONAL',
            [],
            [],
            None,
            '']],
    None]
ok: CONST COV_MAT_SPHERICAL=0
ok: CONST COV_MAT_DIAGONAL=1
ok: CONST COV_MAT_GENERIC=2
ok: CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL

--- Incoming ---
[   'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   ['const cv.ml.EM.DEFAULT_NCLUSTERS', '5', [], [], None, ''],
        ['const cv.ml.EM.DEFAULT_MAX_ITERS', '100', [], [], None, '']],
    None]
ok: CONST DEFAULT_NCLUSTERS=5
ok: CONST DEFAULT_MAX_ITERS=100

--- Incoming ---
[   'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   ['const cv.ml.EM.START_E_STEP', '1', [], [], None, ''],
        ['const cv.ml.EM.START_M_STEP', '2', [], [], None, ''],
        ['const cv.ml.EM.START_AUTO_STEP', '0', [], [], None, '']],
    None]
ok: CONST START_E_STEP=1
ok: CONST START_M_STEP=2
ok: CONST START_AUTO_STEP=0

--- Incoming ---
['cv.ml.EM.getClustersNumber', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.EM.getClustersNumber []>

--- Incoming ---
[   'cv.ml.EM.setClustersNumber',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>

--- Incoming ---
['cv.ml.EM.getCovarianceMatrixType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.EM.getCovarianceMatrixType []>

--- Incoming ---
[   'cv.ml.EM.setCovarianceMatrixType',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>

--- Incoming ---
[   'cv.ml.EM.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.ml.EM.getTermCriteria []>

--- Incoming ---
[   'cv.ml.EM.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
['cv.ml.EM.getWeights', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.EM.getWeights []>

--- Incoming ---
['cv.ml.EM.getMeans', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.EM.getMeans []>

--- Incoming ---
[   'cv.ml.EM.getCovs',
    'void',
    ['/C', '/V', '/PV'],
    [['vector_Mat', 'covs', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>

--- Incoming ---
[   'cv.ml.EM.predict',
    'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'results', 'Mat()', ['/O']],
        ['int', 'flags', '0', []]],
    'float']
ok: FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   'cv.ml.EM.predict2',
    'Vec2d',
    ['/C', '/V', '/PV'],
    [['Mat', 'sample', '', []], ['Mat', 'probs', '', ['/O']]],
    'Vec2d']
ok: FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>

--- Incoming ---
[   'cv.ml.EM.trainEM',
    'bool',
    ['/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'logLikelihoods', 'Mat()', ['/O']],
        ['Mat', 'labels', 'Mat()', ['/O']],
        ['Mat', 'probs', 'Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   'cv.ml.EM.trainE',
    'bool',
    ['/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'means0', '', []],
        ['Mat', 'covs0', 'Mat()', []],
        ['Mat', 'weights0', 'Mat()', []],
        ['Mat', 'logLikelihoods', 'Mat()', ['/O']],
        ['Mat', 'labels', 'Mat()', ['/O']],
        ['Mat', 'probs', 'Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   'cv.ml.EM.trainM',
    'bool',
    ['/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'probs0', '', []],
        ['Mat', 'logLikelihoods', 'Mat()', ['/O']],
        ['Mat', 'labels', 'Mat()', ['/O']],
        ['Mat', 'probs', 'Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
['cv.ml.EM.create', 'Ptr_EM', ['/S'], [], 'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.create []>

--- Incoming ---
[   'cv.ml.EM.load',
    'Ptr_EM',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.DTrees', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.DTrees : StatModel, name: DTrees, base: StatModel

--- Incoming ---
[   'enum cv.ml.DTrees.Flags',
    '',
    [],
    [   ['const cv.ml.DTrees.PREDICT_AUTO', '0', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_SUM', '(1<<8)', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_MAX_VOTE', '(2<<8)', [], [], None, ''],
        ['const cv.ml.DTrees.PREDICT_MASK', '(3<<8)', [], [], None, '']],
    None]
ok: CONST PREDICT_AUTO=0
ok: CONST PREDICT_SUM=(1<<8)
ok: CONST PREDICT_MAX_VOTE=(2<<8)
ok: CONST PREDICT_MASK=(3<<8)

--- Incoming ---
['cv.ml.DTrees.getMaxCategories', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.DTrees.getMaxCategories []>

--- Incoming ---
[   'cv.ml.DTrees.setMaxCategories',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>

--- Incoming ---
['cv.ml.DTrees.getMaxDepth', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.DTrees.getMaxDepth []>

--- Incoming ---
[   'cv.ml.DTrees.setMaxDepth',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>

--- Incoming ---
['cv.ml.DTrees.getMinSampleCount', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.DTrees.getMinSampleCount []>

--- Incoming ---
[   'cv.ml.DTrees.setMinSampleCount',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>

--- Incoming ---
['cv.ml.DTrees.getCVFolds', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.DTrees.getCVFolds []>

--- Incoming ---
[   'cv.ml.DTrees.setCVFolds',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>

--- Incoming ---
['cv.ml.DTrees.getUseSurrogates', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.DTrees.getUseSurrogates []>

--- Incoming ---
[   'cv.ml.DTrees.setUseSurrogates',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>

--- Incoming ---
['cv.ml.DTrees.getUse1SERule', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.DTrees.getUse1SERule []>

--- Incoming ---
[   'cv.ml.DTrees.setUse1SERule',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>

--- Incoming ---
['cv.ml.DTrees.getTruncatePrunedTree', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>

--- Incoming ---
[   'cv.ml.DTrees.setTruncatePrunedTree',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>

--- Incoming ---
[   'cv.ml.DTrees.getRegressionAccuracy',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ml.DTrees.getRegressionAccuracy []>

--- Incoming ---
[   'cv.ml.DTrees.setRegressionAccuracy',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>

--- Incoming ---
['cv.ml.DTrees.getPriors', 'Mat', ['/C', '/V', '/PV'], [], 'cv::Mat']
ok: FUNC <Mat cv.ml.DTrees.getPriors []>

--- Incoming ---
[   'cv.ml.DTrees.setPriors',
    'void',
    ['/V', '/PV'],
    [['Mat', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>

--- Incoming ---
['cv.ml.DTrees.create', 'Ptr_DTrees', ['/S'], [], 'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.create []>

--- Incoming ---
[   'cv.ml.DTrees.load',
    'Ptr_DTrees',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.RTrees', ': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.RTrees : DTrees, name: RTrees, base: DTrees

--- Incoming ---
[   'cv.ml.RTrees.getCalculateVarImportance',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>

--- Incoming ---
[   'cv.ml.RTrees.setCalculateVarImportance',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>

--- Incoming ---
['cv.ml.RTrees.getActiveVarCount', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.RTrees.getActiveVarCount []>

--- Incoming ---
[   'cv.ml.RTrees.setActiveVarCount',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>

--- Incoming ---
[   'cv.ml.RTrees.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>

--- Incoming ---
[   'cv.ml.RTrees.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
['cv.ml.RTrees.getVarImportance', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.RTrees.getVarImportance []>

--- Incoming ---
[   'cv.ml.RTrees.getVotes',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'results', '', ['/O']],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>

--- Incoming ---
['cv.ml.RTrees.getOOBError', 'double', ['/C', '/V'], [], 'double']
ok: FUNC <double cv.ml.RTrees.getOOBError []>

--- Incoming ---
['cv.ml.RTrees.create', 'Ptr_RTrees', ['/S'], [], 'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.create []>

--- Incoming ---
[   'cv.ml.RTrees.load',
    'Ptr_RTrees',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.Boost', ': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.Boost : DTrees, name: Boost, base: DTrees

--- Incoming ---
['cv.ml.Boost.getBoostType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.Boost.getBoostType []>

--- Incoming ---
[   'cv.ml.Boost.setBoostType',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>

--- Incoming ---
['cv.ml.Boost.getWeakCount', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.Boost.getWeakCount []>

--- Incoming ---
[   'cv.ml.Boost.setWeakCount',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>

--- Incoming ---
['cv.ml.Boost.getWeightTrimRate', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.Boost.getWeightTrimRate []>

--- Incoming ---
[   'cv.ml.Boost.setWeightTrimRate',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>

--- Incoming ---
[   'enum cv.ml.Boost.Types',
    '',
    [],
    [   ['const cv.ml.Boost.DISCRETE', '0', [], [], None, ''],
        ['const cv.ml.Boost.REAL', '1', [], [], None, ''],
        ['const cv.ml.Boost.LOGIT', '2', [], [], None, ''],
        ['const cv.ml.Boost.GENTLE', '3', [], [], None, '']],
    None]
ok: CONST DISCRETE=0
ok: CONST REAL=1
ok: CONST LOGIT=2
ok: CONST GENTLE=3

--- Incoming ---
['cv.ml.Boost.create', 'Ptr_Boost', ['/S'], [], 'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.create []>

--- Incoming ---
[   'cv.ml.Boost.load',
    'Ptr_Boost',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.ANN_MLP', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.ANN_MLP : StatModel, name: ANN_MLP, base: StatModel

--- Incoming ---
[   'enum cv.ml.ANN_MLP.TrainingMethods',
    '',
    [],
    [   ['const cv.ml.ANN_MLP.BACKPROP', '0', [], [], None, ''],
        ['const cv.ml.ANN_MLP.RPROP', '1', [], [], None, ''],
        ['const cv.ml.ANN_MLP.ANNEAL', '2', [], [], None, '']],
    None]
ok: CONST BACKPROP=0
ok: CONST RPROP=1
ok: CONST ANNEAL=2

--- Incoming ---
[   'cv.ml.ANN_MLP.setTrainMethod',
    'void',
    ['/V', '/PV'],
    [   ['int', 'method', '', []],
        ['double', 'param1', '0', []],
        ['double', 'param2', '0', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
['cv.ml.ANN_MLP.getTrainMethod', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.ANN_MLP.getTrainMethod []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setActivationFunction',
    'void',
    ['/V', '/PV'],
    [   ['int', 'type', '', []],
        ['double', 'param1', '0', []],
        ['double', 'param2', '0', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[   'cv.ml.ANN_MLP.setLayerSizes',
    'void',
    ['/V', '/PV'],
    [['Mat', '_layer_sizes', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>

--- Incoming ---
['cv.ml.ANN_MLP.getLayerSizes', 'Mat', ['/C', '/V', '/PV'], [], 'cv::Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>

--- Incoming ---
[   'cv.ml.ANN_MLP.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   'cv.ml.ANN_MLP.getBackpropWeightScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setBackpropWeightScale',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>

--- Incoming ---
[   'cv.ml.ANN_MLP.getBackpropMomentumScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setBackpropMomentumScale',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getRpropDW0', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDW0',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getRpropDWPlus', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWPlus',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getRpropDWMinus', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMinus',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getRpropDWMin', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMin',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getRpropDWMax', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setRpropDWMax',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getAnnealInitialT', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealInitialT',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getAnnealFinalT', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealFinalT',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>

--- Incoming ---
[   'cv.ml.ANN_MLP.getAnnealCoolingRatio',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealCoolingRatio',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>

--- Incoming ---
['cv.ml.ANN_MLP.getAnnealItePerStep', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>

--- Incoming ---
[   'cv.ml.ANN_MLP.setAnnealItePerStep',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>

--- Incoming ---
[   'enum cv.ml.ANN_MLP.ActivationFunctions',
    '',
    [],
    [   ['const cv.ml.ANN_MLP.IDENTITY', '0', [], [], None, ''],
        ['const cv.ml.ANN_MLP.SIGMOID_SYM', '1', [], [], None, ''],
        ['const cv.ml.ANN_MLP.GAUSSIAN', '2', [], [], None, ''],
        ['const cv.ml.ANN_MLP.RELU', '3', [], [], None, ''],
        ['const cv.ml.ANN_MLP.LEAKYRELU', '4', [], [], None, '']],
    None]
ok: CONST IDENTITY=0
ok: CONST SIGMOID_SYM=1
ok: CONST GAUSSIAN=2
ok: CONST RELU=3
ok: CONST LEAKYRELU=4

--- Incoming ---
[   'enum cv.ml.ANN_MLP.TrainFlags',
    '',
    [],
    [   ['const cv.ml.ANN_MLP.UPDATE_WEIGHTS', '1', [], [], None, ''],
        ['const cv.ml.ANN_MLP.NO_INPUT_SCALE', '2', [], [], None, ''],
        ['const cv.ml.ANN_MLP.NO_OUTPUT_SCALE', '4', [], [], None, '']],
    None]
ok: CONST UPDATE_WEIGHTS=1
ok: CONST NO_INPUT_SCALE=2
ok: CONST NO_OUTPUT_SCALE=4

--- Incoming ---
[   'cv.ml.ANN_MLP.getWeights',
    'Mat',
    ['/C', '/V', '/PV'],
    [['int', 'layerIdx', '', []]],
    'Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>

--- Incoming ---
['cv.ml.ANN_MLP.create', 'Ptr_ANN_MLP', ['/S'], [], 'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>

--- Incoming ---
[   'cv.ml.ANN_MLP.load',
    'Ptr_ANN_MLP',
    ['/S'],
    [['String', 'filepath', '', ['/C', '/Ref']]],
    'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>

--- Incoming ---
['class cv.ml.LogisticRegression', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.LogisticRegression : StatModel, name: LogisticRegression, base: StatModel

--- Incoming ---
[   'cv.ml.LogisticRegression.getLearningRate',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ml.LogisticRegression.getLearningRate []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setLearningRate',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>

--- Incoming ---
[   'cv.ml.LogisticRegression.getIterations',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ml.LogisticRegression.getIterations []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setIterations',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>

--- Incoming ---
[   'cv.ml.LogisticRegression.getRegularization',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ml.LogisticRegression.getRegularization []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setRegularization',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>

--- Incoming ---
[   'cv.ml.LogisticRegression.getTrainMethod',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ml.LogisticRegression.getTrainMethod []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setTrainMethod',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>

--- Incoming ---
[   'cv.ml.LogisticRegression.getMiniBatchSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setMiniBatchSize',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>

--- Incoming ---
[   'cv.ml.LogisticRegression.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>

--- Incoming ---
[   'cv.ml.LogisticRegression.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', []]],
    'void']
ok: FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   'enum cv.ml.LogisticRegression.RegKinds',
    '',
    [],
    [   ['const cv.ml.LogisticRegression.REG_DISABLE', '-1', [], [], None, ''],
        ['const cv.ml.LogisticRegression.REG_L1', '0', [], [], None, ''],
        ['const cv.ml.LogisticRegression.REG_L2', '1', [], [], None, '']],
    None]
ok: CONST REG_DISABLE=-1
ok: CONST REG_L1=0
ok: CONST REG_L2=1

--- Incoming ---
[   'enum cv.ml.LogisticRegression.Methods',
    '',
    [],
    [   ['const cv.ml.LogisticRegression.BATCH', '0', [], [], None, ''],
        ['const cv.ml.LogisticRegression.MINI_BATCH', '1', [], [], None, '']],
    None]
ok: CONST BATCH=0
ok: CONST MINI_BATCH=1

--- Incoming ---
[   'cv.ml.LogisticRegression.predict',
    'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'samples', '', []],
        ['Mat', 'results', 'Mat()', ['/O']],
        ['int', 'flags', '0', []]],
    'float']
ok: FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   'cv.ml.LogisticRegression.get_learnt_thetas',
    'Mat',
    ['/C', '/V', '/PV'],
    [],
    'Mat']
ok: FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>

--- Incoming ---
[   'cv.ml.LogisticRegression.create',
    'Ptr_LogisticRegression',
    ['/S'],
    [],
    'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>

--- Incoming ---
[   'cv.ml.LogisticRegression.load',
    'Ptr_LogisticRegression',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
['class cv.ml.SVMSGD', ': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVMSGD : StatModel, name: SVMSGD, base: StatModel

--- Incoming ---
[   'enum cv.ml.SVMSGD.SvmsgdType',
    '',
    [],
    [   ['const cv.ml.SVMSGD.SGD', '0', [], [], None, ''],
        ['const cv.ml.SVMSGD.ASGD', '1', [], [], None, '']],
    None]
ok: CONST SGD=0
ok: CONST ASGD=1

--- Incoming ---
[   'enum cv.ml.SVMSGD.MarginType',
    '',
    [],
    [   ['const cv.ml.SVMSGD.SOFT_MARGIN', '0', [], [], None, ''],
        ['const cv.ml.SVMSGD.HARD_MARGIN', '1', [], [], None, '']],
    None]
ok: CONST SOFT_MARGIN=0
ok: CONST HARD_MARGIN=1

--- Incoming ---
['cv.ml.SVMSGD.getWeights', 'Mat', ['/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.ml.SVMSGD.getWeights []>

--- Incoming ---
['cv.ml.SVMSGD.getShift', 'float', ['/V', '/PV'], [], 'float']
ok: FUNC <float cv.ml.SVMSGD.getShift []>

--- Incoming ---
['cv.ml.SVMSGD.create', 'Ptr_SVMSGD', ['/S'], [], 'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>

--- Incoming ---
[   'cv.ml.SVMSGD.load',
    'Ptr_SVMSGD',
    ['/S'],
    [   ['String', 'filepath', '', ['/C', '/Ref']],
        ['String', 'nodeName', 'String()', ['/C', '/Ref']]],
    'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[   'cv.ml.SVMSGD.setOptimalParameters',
    'void',
    ['/V', '/PV'],
    [   ['int', 'svmsgdType', 'SVMSGD::ASGD', []],
        ['int', 'marginType', 'SVMSGD::SOFT_MARGIN', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>

--- Incoming ---
['cv.ml.SVMSGD.getSvmsgdType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.SVMSGD.getSvmsgdType []>

--- Incoming ---
[   'cv.ml.SVMSGD.setSvmsgdType',
    'void',
    ['/V', '/PV'],
    [['int', 'svmsgdType', '', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>

--- Incoming ---
['cv.ml.SVMSGD.getMarginType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ml.SVMSGD.getMarginType []>

--- Incoming ---
[   'cv.ml.SVMSGD.setMarginType',
    'void',
    ['/V', '/PV'],
    [['int', 'marginType', '', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>

--- Incoming ---
[   'cv.ml.SVMSGD.getMarginRegularization',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ml.SVMSGD.getMarginRegularization []>

--- Incoming ---
[   'cv.ml.SVMSGD.setMarginRegularization',
    'void',
    ['/V', '/PV'],
    [['float', 'marginRegularization', '', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>

--- Incoming ---
['cv.ml.SVMSGD.getInitialStepSize', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ml.SVMSGD.getInitialStepSize []>

--- Incoming ---
[   'cv.ml.SVMSGD.setInitialStepSize',
    'void',
    ['/V', '/PV'],
    [['float', 'InitialStepSize', '', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>

--- Incoming ---
[   'cv.ml.SVMSGD.getStepDecreasingPower',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>

--- Incoming ---
[   'cv.ml.SVMSGD.setStepDecreasingPower',
    'void',
    ['/V', '/PV'],
    [['float', 'stepDecreasingPower', '', []]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>

--- Incoming ---
[   'cv.ml.SVMSGD.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>

--- Incoming ---
[   'cv.ml.SVMSGD.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'val', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml/include/opencv2/ml/ml.hpp =====
Namespaces: ['cv', 'cv.ml']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/ml/include/opencv2/ml/ml.hpp


===== Generating... =====
CLASS cv::.Ml : 
[CONST TEST_ERROR=0, CONST TRAIN_ERROR=1]
[CONST ROW_SAMPLE=0, CONST COL_SAMPLE=1]
[CONST VAR_NUMERICAL=0, CONST VAR_ORDERED=0, CONST VAR_CATEGORICAL=1]
CLASS cv.ml::.ANN_MLP : StatModel
[CONST IDENTITY=0, CONST SIGMOID_SYM=1, CONST GAUSSIAN=2, CONST RELU=3, CONST LEAKYRELU=4]
[CONST UPDATE_WEIGHTS=1, CONST NO_INPUT_SCALE=2, CONST NO_OUTPUT_SCALE=4]
[CONST BACKPROP=0, CONST RPROP=1, CONST ANNEAL=2]
FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>
java: void setTrainMethod(int method, double param1, double param2)
java: void setTrainMethod(int method, double param1)
java: void setTrainMethod(int method)
FUNC <int cv.ml.ANN_MLP.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>
java: void setActivationFunction(int type, double param1, double param2)
java: void setActivationFunction(int type, double param1)
java: void setActivationFunction(int type)
FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>
java: void setLayerSizes(Mat _layer_sizes)
FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>
java: Mat getLayerSizes()
FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>
java: double getBackpropWeightScale()
FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>
java: void setBackpropWeightScale(double val)
FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>
java: double getBackpropMomentumScale()
FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>
java: void setBackpropMomentumScale(double val)
FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>
java: double getRpropDW0()
FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>
java: void setRpropDW0(double val)
FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>
java: double getRpropDWPlus()
FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>
java: void setRpropDWPlus(double val)
FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>
java: double getRpropDWMinus()
FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>
java: void setRpropDWMinus(double val)
FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>
java: double getRpropDWMin()
FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>
java: void setRpropDWMin(double val)
FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>
java: double getRpropDWMax()
FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>
java: void setRpropDWMax(double val)
FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>
java: double getAnnealInitialT()
FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>
java: void setAnnealInitialT(double val)
FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>
java: double getAnnealFinalT()
FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>
java: void setAnnealFinalT(double val)
FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>
java: double getAnnealCoolingRatio()
FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>
java: void setAnnealCoolingRatio(double val)
FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>
java: int getAnnealItePerStep()
FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>
java: void setAnnealItePerStep(int val)
FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>
java: Mat getWeights(int layerIdx)
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>
java: ANN_MLP create()
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>
java: ANN_MLP load(String filepath)
CLASS cv.ml::.Boost : DTrees
[CONST DISCRETE=0, CONST REAL=1, CONST LOGIT=2, CONST GENTLE=3]
FUNC <int cv.ml.Boost.getBoostType []>
java: int getBoostType()
FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>
java: void setBoostType(int val)
FUNC <int cv.ml.Boost.getWeakCount []>
java: int getWeakCount()
FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>
java: void setWeakCount(int val)
FUNC <double cv.ml.Boost.getWeightTrimRate []>
java: double getWeightTrimRate()
FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>
java: void setWeightTrimRate(double val)
FUNC <Ptr_Boost cv.ml.Boost.create []>
java: Boost create()
FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>
java: Boost load(String filepath, String nodeName)
java: Boost load(String filepath)
CLASS cv.ml::.DTrees : StatModel
[CONST PREDICT_AUTO=0, CONST PREDICT_SUM=(1<<8), CONST PREDICT_MAX_VOTE=(2<<8), CONST PREDICT_MASK=(3<<8)]
FUNC <int cv.ml.DTrees.getMaxCategories []>
java: int getMaxCategories()
FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>
java: void setMaxCategories(int val)
FUNC <int cv.ml.DTrees.getMaxDepth []>
java: int getMaxDepth()
FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>
java: void setMaxDepth(int val)
FUNC <int cv.ml.DTrees.getMinSampleCount []>
java: int getMinSampleCount()
FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>
java: void setMinSampleCount(int val)
FUNC <int cv.ml.DTrees.getCVFolds []>
java: int getCVFolds()
FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>
java: void setCVFolds(int val)
FUNC <bool cv.ml.DTrees.getUseSurrogates []>
java: boolean getUseSurrogates()
FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>
java: void setUseSurrogates(boolean val)
FUNC <bool cv.ml.DTrees.getUse1SERule []>
java: boolean getUse1SERule()
FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>
java: void setUse1SERule(boolean val)
FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>
java: boolean getTruncatePrunedTree()
FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>
java: void setTruncatePrunedTree(boolean val)
FUNC <float cv.ml.DTrees.getRegressionAccuracy []>
java: float getRegressionAccuracy()
FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>
java: void setRegressionAccuracy(float val)
FUNC <Mat cv.ml.DTrees.getPriors []>
java: Mat getPriors()
FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>
java: void setPriors(Mat val)
FUNC <Ptr_DTrees cv.ml.DTrees.create []>
java: DTrees create()
FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: DTrees load(String filepath, String nodeName)
java: DTrees load(String filepath)
CLASS cv.ml::.EM : StatModel
[CONST DEFAULT_NCLUSTERS=5, CONST DEFAULT_MAX_ITERS=100, CONST START_E_STEP=1, CONST START_M_STEP=2, CONST START_AUTO_STEP=0]
[CONST COV_MAT_SPHERICAL=0, CONST COV_MAT_DIAGONAL=1, CONST COV_MAT_GENERIC=2, CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL]
FUNC <int cv.ml.EM.getClustersNumber []>
java: int getClustersNumber()
FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>
java: void setClustersNumber(int val)
FUNC <int cv.ml.EM.getCovarianceMatrixType []>
java: int getCovarianceMatrixType()
FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>
java: void setCovarianceMatrixType(int val)
FUNC <TermCriteria cv.ml.EM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <Mat cv.ml.EM.getWeights []>
java: Mat getWeights()
FUNC <Mat cv.ml.EM.getMeans []>
java: Mat getMeans()
FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>
java: void getCovs(List<Mat> covs)
FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>
java: double[] predict2(Mat sample, Mat probs)
FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels)
java: boolean trainEM(Mat samples, Mat logLikelihoods)
java: boolean trainEM(Mat samples)
FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0)
java: boolean trainE(Mat samples, Mat means0, Mat covs0)
java: boolean trainE(Mat samples, Mat means0)
FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods)
java: boolean trainM(Mat samples, Mat probs0)
FUNC <Ptr_EM cv.ml.EM.create []>
java: EM create()
FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>
java: EM load(String filepath, String nodeName)
java: EM load(String filepath)
CLASS cv.ml::.KNearest : StatModel
[CONST BRUTE_FORCE=1, CONST KDTREE=2]
FUNC <int cv.ml.KNearest.getDefaultK []>
java: int getDefaultK()
FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>
java: void setDefaultK(int val)
FUNC <bool cv.ml.KNearest.getIsClassifier []>
java: boolean getIsClassifier()
FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>
java: void setIsClassifier(boolean val)
FUNC <int cv.ml.KNearest.getEmax []>
java: int getEmax()
FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>
java: void setEmax(int val)
FUNC <int cv.ml.KNearest.getAlgorithmType []>
java: int getAlgorithmType()
FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>
java: void setAlgorithmType(int val)
FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses, Mat dist)
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses)
java: float findNearest(Mat samples, int k, Mat results)
FUNC <Ptr_KNearest cv.ml.KNearest.create []>
java: KNearest create()
FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>
java: KNearest load(String filepath)
CLASS cv.ml::.LogisticRegression : StatModel
[CONST BATCH=0, CONST MINI_BATCH=1]
[CONST REG_DISABLE=-1, CONST REG_L1=0, CONST REG_L2=1]
FUNC <double cv.ml.LogisticRegression.getLearningRate []>
java: double getLearningRate()
FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>
java: void setLearningRate(double val)
FUNC <int cv.ml.LogisticRegression.getIterations []>
java: int getIterations()
FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>
java: void setIterations(int val)
FUNC <int cv.ml.LogisticRegression.getRegularization []>
java: int getRegularization()
FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>
java: void setRegularization(int val)
FUNC <int cv.ml.LogisticRegression.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>
java: void setTrainMethod(int val)
FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>
java: int getMiniBatchSize()
FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>
java: void setMiniBatchSize(int val)
FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>
java: Mat get_learnt_thetas()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>
java: LogisticRegression create()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>
java: LogisticRegression load(String filepath, String nodeName)
java: LogisticRegression load(String filepath)
CLASS cv.ml::.NormalBayesClassifier : StatModel
FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs, int flags)
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs)
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>
java: NormalBayesClassifier create()
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>
java: NormalBayesClassifier load(String filepath, String nodeName)
java: NormalBayesClassifier load(String filepath)
CLASS cv.ml::.ParamGrid : 
FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>
java: ParamGrid create(double minVal, double maxVal, double logstep)
java: ParamGrid create(double minVal, double maxVal)
java: ParamGrid create(double minVal)
java: ParamGrid create()
FUNC <double cv.ml.ParamGrid.get_minVal []>
java: double get_minVal()
FUNC <void cv.ml.ParamGrid.set_minVal [ARG double minVal=]>
java: void set_minVal(double minVal)
FUNC <double cv.ml.ParamGrid.get_maxVal []>
java: double get_maxVal()
FUNC <void cv.ml.ParamGrid.set_maxVal [ARG double maxVal=]>
java: void set_maxVal(double maxVal)
FUNC <double cv.ml.ParamGrid.get_logStep []>
java: double get_logStep()
FUNC <void cv.ml.ParamGrid.set_logStep [ARG double logStep=]>
java: void set_logStep(double logStep)
CLASS cv.ml::.RTrees : DTrees
FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>
java: boolean getCalculateVarImportance()
FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>
java: void setCalculateVarImportance(boolean val)
FUNC <int cv.ml.RTrees.getActiveVarCount []>
java: int getActiveVarCount()
FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>
java: void setActiveVarCount(int val)
FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <Mat cv.ml.RTrees.getVarImportance []>
java: Mat getVarImportance()
FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>
java: void getVotes(Mat samples, Mat results, int flags)
FUNC <double cv.ml.RTrees.getOOBError []>
java: double getOOBError()
FUNC <Ptr_RTrees cv.ml.RTrees.create []>
java: RTrees create()
FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: RTrees load(String filepath, String nodeName)
java: RTrees load(String filepath)
CLASS cv.ml::.SVM : StatModel
[CONST CUSTOM=-1, CONST LINEAR=0, CONST POLY=1, CONST RBF=2, CONST SIGMOID=3, CONST CHI2=4, CONST INTER=5]
[CONST C=0, CONST GAMMA=1, CONST P=2, CONST NU=3, CONST COEF=4, CONST DEGREE=5]
[CONST C_SVC=100, CONST NU_SVC=101, CONST ONE_CLASS=102, CONST EPS_SVR=103, CONST NU_SVR=104]
FUNC <int cv.ml.SVM.getType []>
java: int getType()
FUNC <void cv.ml.SVM.setType [ARG int val=]>
java: void setType(int val)
FUNC <double cv.ml.SVM.getGamma []>
java: double getGamma()
FUNC <void cv.ml.SVM.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <double cv.ml.SVM.getCoef0 []>
java: double getCoef0()
FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>
java: void setCoef0(double val)
FUNC <double cv.ml.SVM.getDegree []>
java: double getDegree()
FUNC <void cv.ml.SVM.setDegree [ARG double val=]>
java: void setDegree(double val)
FUNC <double cv.ml.SVM.getC []>
java: double getC()
FUNC <void cv.ml.SVM.setC [ARG double val=]>
java: void setC(double val)
FUNC <double cv.ml.SVM.getNu []>
java: double getNu()
FUNC <void cv.ml.SVM.setNu [ARG double val=]>
java: void setNu(double val)
FUNC <double cv.ml.SVM.getP []>
java: double getP()
FUNC <void cv.ml.SVM.setP [ARG double val=]>
java: void setP(double val)
FUNC <Mat cv.ml.SVM.getClassWeights []>
java: Mat getClassWeights()
FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>
java: void setClassWeights(Mat val)
FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <int cv.ml.SVM.getKernelType []>
java: int getKernelType()
FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>
java: void setKernel(int kernelType)
FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid, boolean balanced)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold)
java: boolean trainAuto(Mat samples, int layout, Mat responses)
FUNC <Mat cv.ml.SVM.getSupportVectors []>
java: Mat getSupportVectors()
FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>
java: Mat getUncompressedSupportVectors()
FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>
java: double getDecisionFunction(int i, Mat alpha, Mat svidx)
FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>
java: ParamGrid getDefaultGridPtr(int param_id)
FUNC <Ptr_SVM cv.ml.SVM.create []>
java: SVM create()
FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>
java: SVM load(String filepath)
CLASS cv.ml::.SVMSGD : StatModel
[CONST SOFT_MARGIN=0, CONST HARD_MARGIN=1]
[CONST SGD=0, CONST ASGD=1]
FUNC <Mat cv.ml.SVMSGD.getWeights []>
java: Mat getWeights()
FUNC <float cv.ml.SVMSGD.getShift []>
java: float getShift()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>
java: SVMSGD create()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>
java: SVMSGD load(String filepath, String nodeName)
java: SVMSGD load(String filepath)
FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>
java: void setOptimalParameters(int svmsgdType, int marginType)
java: void setOptimalParameters(int svmsgdType)
java: void setOptimalParameters()
FUNC <int cv.ml.SVMSGD.getSvmsgdType []>
java: int getSvmsgdType()
FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>
java: void setSvmsgdType(int svmsgdType)
FUNC <int cv.ml.SVMSGD.getMarginType []>
java: int getMarginType()
FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>
java: void setMarginType(int marginType)
FUNC <float cv.ml.SVMSGD.getMarginRegularization []>
java: float getMarginRegularization()
FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>
java: void setMarginRegularization(float marginRegularization)
FUNC <float cv.ml.SVMSGD.getInitialStepSize []>
java: float getInitialStepSize()
FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>
java: void setInitialStepSize(float InitialStepSize)
FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>
java: float getStepDecreasingPower()
FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>
java: void setStepDecreasingPower(float stepDecreasingPower)
FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.StatModel : Algorithm
[CONST UPDATE_MODEL=1, CONST RAW_OUTPUT=1, CONST COMPRESSED_INPUT=2, CONST PREPROCESSED_INPUT=4]
FUNC <int cv.ml.StatModel.getVarCount []>
java: int getVarCount()
FUNC <bool cv.ml.StatModel.empty []>
java: boolean empty()
FUNC <bool cv.ml.StatModel.isTrained []>
java: boolean isTrained()
FUNC <bool cv.ml.StatModel.isClassifier []>
java: boolean isClassifier()
FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>
java: boolean train(TrainData trainData, int flags)
java: boolean train(TrainData trainData)
FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>
java: boolean train(Mat samples, int layout, Mat responses)
FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>
java: float calcError(TrainData data, boolean test, Mat resp)
FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
CLASS cv.ml::.TrainData : 
FUNC <int cv.ml.TrainData.getLayout []>
java: int getLayout()
FUNC <int cv.ml.TrainData.getNTrainSamples []>
java: int getNTrainSamples()
FUNC <int cv.ml.TrainData.getNTestSamples []>
java: int getNTestSamples()
FUNC <int cv.ml.TrainData.getNSamples []>
java: int getNSamples()
FUNC <int cv.ml.TrainData.getNVars []>
java: int getNVars()
FUNC <int cv.ml.TrainData.getNAllVars []>
java: int getNAllVars()
FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>
java: void getSample(Mat varIdx, int sidx, float buf)
FUNC <Mat cv.ml.TrainData.getSamples []>
java: Mat getSamples()
FUNC <Mat cv.ml.TrainData.getMissing []>
java: Mat getMissing()
FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>
java: Mat getTrainSamples(int layout, boolean compressSamples, boolean compressVars)
java: Mat getTrainSamples(int layout, boolean compressSamples)
java: Mat getTrainSamples(int layout)
java: Mat getTrainSamples()
FUNC <Mat cv.ml.TrainData.getTrainResponses []>
java: Mat getTrainResponses()
FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>
java: Mat getTrainNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTestResponses []>
java: Mat getTestResponses()
FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>
java: Mat getTestNormCatResponses()
FUNC <Mat cv.ml.TrainData.getResponses []>
java: Mat getResponses()
FUNC <Mat cv.ml.TrainData.getNormCatResponses []>
java: Mat getNormCatResponses()
FUNC <Mat cv.ml.TrainData.getSampleWeights []>
java: Mat getSampleWeights()
FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>
java: Mat getTrainSampleWeights()
FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>
java: Mat getTestSampleWeights()
FUNC <Mat cv.ml.TrainData.getVarIdx []>
java: Mat getVarIdx()
FUNC <Mat cv.ml.TrainData.getVarType []>
java: Mat getVarType()
FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>
java: Mat getVarSymbolFlags()
FUNC <int cv.ml.TrainData.getResponseType []>
java: int getResponseType()
FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>
java: Mat getTrainSampleIdx()
FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>
java: Mat getTestSampleIdx()
FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>
java: void getValues(int vi, Mat sidx, float values)
FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>
java: Mat getDefaultSubstValues()
FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>
java: int getCatCount(int vi)
FUNC <Mat cv.ml.TrainData.getClassLabels []>
java: Mat getClassLabels()
FUNC <Mat cv.ml.TrainData.getCatOfs []>
java: Mat getCatOfs()
FUNC <Mat cv.ml.TrainData.getCatMap []>
java: Mat getCatMap()
FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>
java: void setTrainTestSplit(int count, boolean shuffle)
java: void setTrainTestSplit(int count)
FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>
java: void setTrainTestSplitRatio(double ratio, boolean shuffle)
java: void setTrainTestSplitRatio(double ratio)
FUNC <void cv.ml.TrainData.shuffleTrainTest []>
java: void shuffleTrainTest()
FUNC <Mat cv.ml.TrainData.getTestSamples []>
java: Mat getTestSamples()
FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>
java: void getNames(List<String> names)
FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>
java: Mat getSubVector(Mat vec, Mat idx)
FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>
java: Mat getSubMatrix(Mat matrix, Mat idx, int layout)
FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights, Mat varType)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx)
java: TrainData create(Mat samples, int layout, Mat responses)

=== MODULE: phase_unwrapping (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping) ===


Files (3):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/phase_unwrapping.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/histogramphaseunwrapping.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Phase_unwrapping : , name: Phase_unwrapping, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/phase_unwrapping.hpp =====
Namespaces: ['cv', 'cv.phase_unwrapping']

--- Incoming ---
['class cv.phase_unwrapping.PhaseUnwrapping', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.phase_unwrapping::.PhaseUnwrapping : Algorithm, name: PhaseUnwrapping, base: Algorithm

--- Incoming ---
[   'cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'wrappedPhaseMap', '', []],
        ['Mat', 'unwrappedPhaseMap', '', ['/O']],
        ['Mat', 'shadowMask', 'Mat()', []]],
    'void']
ok: FUNC <void cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Mat shadowMask=Mat()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/phase_unwrapping/include/opencv2/phase_unwrapping/histogramphaseunwrapping.hpp =====
Namespaces: ['cv', 'cv.phase_unwrapping']

--- Incoming ---
[   'class cv.phase_unwrapping.HistogramPhaseUnwrapping',
    ': cv::phase_unwrapping::PhaseUnwrapping',
    [],
    [],
    None]
ok: class CLASS cv.phase_unwrapping::.HistogramPhaseUnwrapping : PhaseUnwrapping, name: HistogramPhaseUnwrapping, base: PhaseUnwrapping

--- Incoming ---
[   'struct cv.phase_unwrapping.HistogramPhaseUnwrapping.Params',
    '',
    ['/Simple'],
    [   ['int', 'width', '', ['/RW']],
        ['int', 'height', '', ['/RW']],
        ['float', 'histThresh', '', ['/RW']],
        ['int', 'nbrOfSmallBins', '', ['/RW']],
        ['int', 'nbrOfLargeBins', '', ['/RW']]],
    None]
ok: class CLASS cv.phase_unwrapping::HistogramPhaseUnwrapping.HistogramPhaseUnwrapping_Params : , name: HistogramPhaseUnwrapping_Params, base: 

--- Incoming ---
['cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.Params', '', [], [], None]
ok: FUNC < cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.HistogramPhaseUnwrapping_Params []>

--- Incoming ---
[   'cv.phase_unwrapping.HistogramPhaseUnwrapping.create',
    'Ptr_HistogramPhaseUnwrapping',
    ['/S'],
    [   [   'HistogramPhaseUnwrapping_Params',
            'parameters',
            'HistogramPhaseUnwrapping::Params()',
            ['/C', '/Ref']]],
    'Ptr<HistogramPhaseUnwrapping>']
ok: FUNC <Ptr_HistogramPhaseUnwrapping cv.phase_unwrapping.HistogramPhaseUnwrapping.create [ARG HistogramPhaseUnwrapping_Params parameters=HistogramPhaseUnwrapping::Params()]>

--- Incoming ---
[   'cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap',
    'void',
    ['/V', '/PV'],
    [['Mat', 'reliabilityMap', '', ['/O']]],
    'void']
ok: FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap [ARG Mat reliabilityMap=]>


===== Generating... =====
CLASS cv::.Phase_unwrapping : 
CLASS cv.phase_unwrapping::.HistogramPhaseUnwrapping : PhaseUnwrapping
FUNC <Ptr_HistogramPhaseUnwrapping cv.phase_unwrapping.HistogramPhaseUnwrapping.create [ARG HistogramPhaseUnwrapping_Params parameters=HistogramPhaseUnwrapping::Params()]>
java: HistogramPhaseUnwrapping create(HistogramPhaseUnwrapping_Params parameters)
java: HistogramPhaseUnwrapping create()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.getInverseReliabilityMap [ARG Mat reliabilityMap=]>
java: void getInverseReliabilityMap(Mat reliabilityMap)
CLASS cv.phase_unwrapping::HistogramPhaseUnwrapping.HistogramPhaseUnwrapping_Params : 
FUNC < cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.HistogramPhaseUnwrapping_Params []>
java:  HistogramPhaseUnwrapping_Params()
FUNC <int cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.get_width []>
java: int get_width()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.set_width [ARG int width=]>
java: void set_width(int width)
FUNC <int cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.get_height []>
java: int get_height()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.set_height [ARG int height=]>
java: void set_height(int height)
FUNC <float cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.get_histThresh []>
java: float get_histThresh()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.set_histThresh [ARG float histThresh=]>
java: void set_histThresh(float histThresh)
FUNC <int cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.get_nbrOfSmallBins []>
java: int get_nbrOfSmallBins()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.set_nbrOfSmallBins [ARG int nbrOfSmallBins=]>
java: void set_nbrOfSmallBins(int nbrOfSmallBins)
FUNC <int cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.get_nbrOfLargeBins []>
java: int get_nbrOfLargeBins()
FUNC <void cv.phase_unwrapping.HistogramPhaseUnwrapping.Params.set_nbrOfLargeBins [ARG int nbrOfLargeBins=]>
java: void set_nbrOfLargeBins(int nbrOfLargeBins)
CLASS cv.phase_unwrapping::.PhaseUnwrapping : Algorithm
FUNC <void cv.phase_unwrapping.PhaseUnwrapping.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Mat shadowMask=Mat()]>
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap, Mat shadowMask)
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap)

=== MODULE: photo (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo) ===


Files (3):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo/photo.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo/cuda.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Photo : , name: Photo, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo.hpp =====
Namespaces: ['cv']

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.INPAINT_NS', '0', [], [], None, ''],
        ['const cv.INPAINT_TELEA', '1', [], [], None, '']],
    None]
ok: CONST INPAINT_NS=0
ok: CONST INPAINT_TELEA=1

--- Incoming ---
[   'cv.inpaint',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'inpaintMask', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'inpaintRadius', '', []],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>

--- Incoming ---
[   'cv.fastNlMeansDenoising',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'h', '3', []],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   'cv.fastNlMeansDenoising',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['vector_float', 'h', '', ['/C', '/Ref']],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []],
        ['int', 'normType', 'NORM_L2', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   'cv.fastNlMeansDenoisingColored',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'h', '3', []],
        ['float', 'hColor', '3', []],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   'cv.fastNlMeansDenoisingMulti',
    'void',
    [],
    [   ['vector_Mat', 'srcImgs', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'imgToDenoiseIndex', '', []],
        ['int', 'temporalWindowSize', '', []],
        ['float', 'h', '3', []],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   'cv.fastNlMeansDenoisingMulti',
    'void',
    [],
    [   ['vector_Mat', 'srcImgs', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'imgToDenoiseIndex', '', []],
        ['int', 'temporalWindowSize', '', []],
        ['vector_float', 'h', '', ['/C', '/Ref']],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []],
        ['int', 'normType', 'NORM_L2', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   'cv.fastNlMeansDenoisingColoredMulti',
    'void',
    [],
    [   ['vector_Mat', 'srcImgs', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'imgToDenoiseIndex', '', []],
        ['int', 'temporalWindowSize', '', []],
        ['float', 'h', '3', []],
        ['float', 'hColor', '3', []],
        ['int', 'templateWindowSize', '7', []],
        ['int', 'searchWindowSize', '21', []]],
    'void']
ok: FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   'cv.denoise_TVL1',
    'void',
    [],
    [   ['vector_Mat', 'observations', '', ['/C', '/Ref']],
        ['Mat', 'result', '', ['/Ref']],
        ['double', 'lambda', '1.0', []],
        ['int', 'niters', '30', []]],
    'void']
ok: FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [['const cv.LDR_SIZE', '256', [], [], None, '']],
    None]
ok: CONST LDR_SIZE=256

--- Incoming ---
['class cv.Tonemap', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.Tonemap : Algorithm, name: Tonemap, base: Algorithm

--- Incoming ---
[   'cv.Tonemap.process',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
['cv.Tonemap.getGamma', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.Tonemap.getGamma []>

--- Incoming ---
[   'cv.Tonemap.setGamma',
    'void',
    ['/V', '/PV'],
    [['float', 'gamma', '', []]],
    'void']
ok: FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>

--- Incoming ---
[   'cv.createTonemap',
    'Ptr_Tonemap',
    [],
    [['float', 'gamma', '1.0f', []]],
    'Ptr<Tonemap>']
ok: FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>

--- Incoming ---
['class cv.TonemapDrago', ': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapDrago : Tonemap, name: TonemapDrago, base: Tonemap

--- Incoming ---
['cv.TonemapDrago.getSaturation', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.TonemapDrago.getSaturation []>

--- Incoming ---
[   'cv.TonemapDrago.setSaturation',
    'void',
    ['/V', '/PV'],
    [['float', 'saturation', '', []]],
    'void']
ok: FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>

--- Incoming ---
['cv.TonemapDrago.getBias', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.TonemapDrago.getBias []>

--- Incoming ---
[   'cv.TonemapDrago.setBias',
    'void',
    ['/V', '/PV'],
    [['float', 'bias', '', []]],
    'void']
ok: FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>

--- Incoming ---
[   'cv.createTonemapDrago',
    'Ptr_TonemapDrago',
    [],
    [   ['float', 'gamma', '1.0f', []],
        ['float', 'saturation', '1.0f', []],
        ['float', 'bias', '0.85f', []]],
    'Ptr<TonemapDrago>']
ok: FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>

--- Incoming ---
['class cv.TonemapReinhard', ': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapReinhard : Tonemap, name: TonemapReinhard, base: Tonemap

--- Incoming ---
['cv.TonemapReinhard.getIntensity', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.TonemapReinhard.getIntensity []>

--- Incoming ---
[   'cv.TonemapReinhard.setIntensity',
    'void',
    ['/V', '/PV'],
    [['float', 'intensity', '', []]],
    'void']
ok: FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>

--- Incoming ---
[   'cv.TonemapReinhard.getLightAdaptation',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.TonemapReinhard.getLightAdaptation []>

--- Incoming ---
[   'cv.TonemapReinhard.setLightAdaptation',
    'void',
    ['/V', '/PV'],
    [['float', 'light_adapt', '', []]],
    'void']
ok: FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>

--- Incoming ---
[   'cv.TonemapReinhard.getColorAdaptation',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.TonemapReinhard.getColorAdaptation []>

--- Incoming ---
[   'cv.TonemapReinhard.setColorAdaptation',
    'void',
    ['/V', '/PV'],
    [['float', 'color_adapt', '', []]],
    'void']
ok: FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>

--- Incoming ---
[   'cv.createTonemapReinhard',
    'Ptr_TonemapReinhard',
    [],
    [   ['float', 'gamma', '1.0f', []],
        ['float', 'intensity', '0.0f', []],
        ['float', 'light_adapt', '1.0f', []],
        ['float', 'color_adapt', '0.0f', []]],
    'Ptr<TonemapReinhard>']
ok: FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>

--- Incoming ---
['class cv.TonemapMantiuk', ': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapMantiuk : Tonemap, name: TonemapMantiuk, base: Tonemap

--- Incoming ---
['cv.TonemapMantiuk.getScale', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.TonemapMantiuk.getScale []>

--- Incoming ---
[   'cv.TonemapMantiuk.setScale',
    'void',
    ['/V', '/PV'],
    [['float', 'scale', '', []]],
    'void']
ok: FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>

--- Incoming ---
['cv.TonemapMantiuk.getSaturation', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.TonemapMantiuk.getSaturation []>

--- Incoming ---
[   'cv.TonemapMantiuk.setSaturation',
    'void',
    ['/V', '/PV'],
    [['float', 'saturation', '', []]],
    'void']
ok: FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>

--- Incoming ---
[   'cv.createTonemapMantiuk',
    'Ptr_TonemapMantiuk',
    [],
    [   ['float', 'gamma', '1.0f', []],
        ['float', 'scale', '0.7f', []],
        ['float', 'saturation', '1.0f', []]],
    'Ptr<TonemapMantiuk>']
ok: FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>

--- Incoming ---
['class cv.AlignExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.AlignExposures : Algorithm, name: AlignExposures, base: Algorithm

--- Incoming ---
[   'cv.AlignExposures.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['vector_Mat', 'dst', '', ['/Ref']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
['class cv.AlignMTB', ': cv::AlignExposures', [], [], None]
ok: class CLASS cv::.AlignMTB : AlignExposures, name: AlignMTB, base: AlignExposures

--- Incoming ---
[   'cv.AlignMTB.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['vector_Mat', 'dst', '', ['/Ref']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   'cv.AlignMTB.process',
    'void',
    ['/V', '/PV'],
    [['vector_Mat', 'src', '', []], ['vector_Mat', 'dst', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>

--- Incoming ---
[   'cv.AlignMTB.calculateShift',
    'Point',
    ['/V', '/PV'],
    [['Mat', 'img0', '', []], ['Mat', 'img1', '', []]],
    'Point']
ok: FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>

--- Incoming ---
[   'cv.AlignMTB.shiftMat',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Point', 'shift', '', ['/C']]],
    'void']
ok: FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>

--- Incoming ---
[   'cv.AlignMTB.computeBitmaps',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'img', '', []],
        ['Mat', 'tb', '', ['/O']],
        ['Mat', 'eb', '', ['/O']]],
    'void']
ok: FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>

--- Incoming ---
['cv.AlignMTB.getMaxBits', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AlignMTB.getMaxBits []>

--- Incoming ---
[   'cv.AlignMTB.setMaxBits',
    'void',
    ['/V', '/PV'],
    [['int', 'max_bits', '', []]],
    'void']
ok: FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>

--- Incoming ---
['cv.AlignMTB.getExcludeRange', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AlignMTB.getExcludeRange []>

--- Incoming ---
[   'cv.AlignMTB.setExcludeRange',
    'void',
    ['/V', '/PV'],
    [['int', 'exclude_range', '', []]],
    'void']
ok: FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>

--- Incoming ---
['cv.AlignMTB.getCut', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.AlignMTB.getCut []>

--- Incoming ---
[   'cv.AlignMTB.setCut',
    'void',
    ['/V', '/PV'],
    [['bool', 'value', '', []]],
    'void']
ok: FUNC <void cv.AlignMTB.setCut [ARG bool value=]>

--- Incoming ---
[   'cv.createAlignMTB',
    'Ptr_AlignMTB',
    [],
    [   ['int', 'max_bits', '6', []],
        ['int', 'exclude_range', '4', []],
        ['bool', 'cut', 'true', []]],
    'Ptr<AlignMTB>']
ok: FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>

--- Incoming ---
['class cv.CalibrateCRF', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CalibrateCRF : Algorithm, name: CalibrateCRF, base: Algorithm

--- Incoming ---
[   'cv.CalibrateCRF.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []]],
    'void']
ok: FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
['class cv.CalibrateDebevec', ': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateDebevec : CalibrateCRF, name: CalibrateDebevec, base: CalibrateCRF

--- Incoming ---
['cv.CalibrateDebevec.getLambda', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.CalibrateDebevec.getLambda []>

--- Incoming ---
[   'cv.CalibrateDebevec.setLambda',
    'void',
    ['/V', '/PV'],
    [['float', 'lambda', '', []]],
    'void']
ok: FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>

--- Incoming ---
['cv.CalibrateDebevec.getSamples', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.CalibrateDebevec.getSamples []>

--- Incoming ---
[   'cv.CalibrateDebevec.setSamples',
    'void',
    ['/V', '/PV'],
    [['int', 'samples', '', []]],
    'void']
ok: FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>

--- Incoming ---
['cv.CalibrateDebevec.getRandom', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.CalibrateDebevec.getRandom []>

--- Incoming ---
[   'cv.CalibrateDebevec.setRandom',
    'void',
    ['/V', '/PV'],
    [['bool', 'random', '', []]],
    'void']
ok: FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>

--- Incoming ---
[   'cv.createCalibrateDebevec',
    'Ptr_CalibrateDebevec',
    [],
    [   ['int', 'samples', '70', []],
        ['float', 'lambda', '10.0f', []],
        ['bool', 'random', 'false', []]],
    'Ptr<CalibrateDebevec>']
ok: FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>

--- Incoming ---
['class cv.CalibrateRobertson', ': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateRobertson : CalibrateCRF, name: CalibrateRobertson, base: CalibrateCRF

--- Incoming ---
['cv.CalibrateRobertson.getMaxIter', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.CalibrateRobertson.getMaxIter []>

--- Incoming ---
[   'cv.CalibrateRobertson.setMaxIter',
    'void',
    ['/V', '/PV'],
    [['int', 'max_iter', '', []]],
    'void']
ok: FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>

--- Incoming ---
[   'cv.CalibrateRobertson.getThreshold',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.CalibrateRobertson.getThreshold []>

--- Incoming ---
[   'cv.CalibrateRobertson.setThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>

--- Incoming ---
['cv.CalibrateRobertson.getRadiance', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.CalibrateRobertson.getRadiance []>

--- Incoming ---
[   'cv.createCalibrateRobertson',
    'Ptr_CalibrateRobertson',
    [],
    [['int', 'max_iter', '30', []], ['float', 'threshold', '0.01f', []]],
    'Ptr<CalibrateRobertson>']
ok: FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>

--- Incoming ---
['class cv.MergeExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.MergeExposures : Algorithm, name: MergeExposures, base: Algorithm

--- Incoming ---
[   'cv.MergeExposures.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
['class cv.MergeDebevec', ': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeDebevec : MergeExposures, name: MergeDebevec, base: MergeExposures

--- Incoming ---
[   'cv.MergeDebevec.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   'cv.MergeDebevec.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []]],
    'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
['cv.createMergeDebevec', 'Ptr_MergeDebevec', [], [], 'Ptr<MergeDebevec>']
ok: FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>

--- Incoming ---
['class cv.MergeMertens', ': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeMertens : MergeExposures, name: MergeMertens, base: MergeExposures

--- Incoming ---
[   'cv.MergeMertens.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   'cv.MergeMertens.process',
    'void',
    ['/V', '/PV'],
    [['vector_Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
['cv.MergeMertens.getContrastWeight', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.MergeMertens.getContrastWeight []>

--- Incoming ---
[   'cv.MergeMertens.setContrastWeight',
    'void',
    ['/V', '/PV'],
    [['float', 'contrast_weiht', '', []]],
    'void']
ok: FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>

--- Incoming ---
[   'cv.MergeMertens.getSaturationWeight',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.MergeMertens.getSaturationWeight []>

--- Incoming ---
[   'cv.MergeMertens.setSaturationWeight',
    'void',
    ['/V', '/PV'],
    [['float', 'saturation_weight', '', []]],
    'void']
ok: FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>

--- Incoming ---
['cv.MergeMertens.getExposureWeight', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.MergeMertens.getExposureWeight []>

--- Incoming ---
[   'cv.MergeMertens.setExposureWeight',
    'void',
    ['/V', '/PV'],
    [['float', 'exposure_weight', '', []]],
    'void']
ok: FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>

--- Incoming ---
[   'cv.createMergeMertens',
    'Ptr_MergeMertens',
    [],
    [   ['float', 'contrast_weight', '1.0f', []],
        ['float', 'saturation_weight', '1.0f', []],
        ['float', 'exposure_weight', '0.0f', []]],
    'Ptr<MergeMertens>']
ok: FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>

--- Incoming ---
['class cv.MergeRobertson', ': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeRobertson : MergeExposures, name: MergeRobertson, base: MergeExposures

--- Incoming ---
[   'cv.MergeRobertson.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []],
        ['Mat', 'response', '', []]],
    'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   'cv.MergeRobertson.process',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'times', '', []]],
    'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
['cv.createMergeRobertson', 'Ptr_MergeRobertson', [], [], 'Ptr<MergeRobertson>']
ok: FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>

--- Incoming ---
[   'cv.decolor',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'grayscale', '', ['/O']],
        ['Mat', 'color_boost', '', ['/O']]],
    'void']
ok: FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.NORMAL_CLONE', '1', [], [], None, ''],
        ['const cv.MIXED_CLONE', '2', [], [], None, ''],
        ['const cv.MONOCHROME_TRANSFER', '3', [], [], None, '']],
    None]
ok: CONST NORMAL_CLONE=1
ok: CONST MIXED_CLONE=2
ok: CONST MONOCHROME_TRANSFER=3

--- Incoming ---
[   'cv.seamlessClone',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['Mat', 'mask', '', []],
        ['Point', 'p', '', []],
        ['Mat', 'blend', '', ['/O']],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>

--- Incoming ---
[   'cv.colorChange',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mask', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'red_mul', '1.0f', []],
        ['float', 'green_mul', '1.0f', []],
        ['float', 'blue_mul', '1.0f', []]],
    'void']
ok: FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>

--- Incoming ---
[   'cv.illuminationChange',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mask', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'alpha', '0.2f', []],
        ['float', 'beta', '0.4f', []]],
    'void']
ok: FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>

--- Incoming ---
[   'cv.textureFlattening',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mask', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'low_threshold', '30', []],
        ['float', 'high_threshold', '45', []],
        ['int', 'kernel_size', '3', []]],
    'void']
ok: FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.RECURS_FILTER', '1', [], [], None, ''],
        ['const cv.NORMCONV_FILTER', '2', [], [], None, '']],
    None]
ok: CONST RECURS_FILTER=1
ok: CONST NORMCONV_FILTER=2

--- Incoming ---
[   'cv.edgePreservingFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'flags', '1', []],
        ['float', 'sigma_s', '60', []],
        ['float', 'sigma_r', '0.4f', []]],
    'void']
ok: FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>

--- Incoming ---
[   'cv.detailEnhance',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'sigma_s', '10', []],
        ['float', 'sigma_r', '0.15f', []]],
    'void']
ok: FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>

--- Incoming ---
[   'cv.pencilSketch',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst1', '', ['/O']],
        ['Mat', 'dst2', '', ['/O']],
        ['float', 'sigma_s', '60', []],
        ['float', 'sigma_r', '0.07f', []],
        ['float', 'shade_factor', '0.02f', []]],
    'void']
ok: FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>

--- Incoming ---
[   'cv.stylization',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'sigma_s', '60', []],
        ['float', 'sigma_r', '0.45f', []]],
    'void']
ok: FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo/photo.hpp =====
Namespaces: ['cv']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo/photo.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/photo/include/opencv2/photo/cuda.hpp =====
Namespaces: ['cv', 'cv.cuda']

--- Incoming ---
[   'cv.cuda.nonLocalMeans',
    'void',
    [],
    [   ['GpuMat', 'src', '', ['/C', '/Ref']],
        ['GpuMat', 'dst', '', ['/O', '/Ref']],
        ['float', 'h', '', []],
        ['int', 'search_window', '21', []],
        ['int', 'block_size', '7', []],
        ['int', 'borderMode', 'BORDER_DEFAULT', []],
        ['Stream', 'stream', 'Stream::Null()', ['/Ref']]],
    'void']
ok: FUNC <void cv.cuda..nonLocalMeans [ARG GpuMat src=, ARG GpuMat dst=, ARG float h=, ARG int search_window=21, ARG int block_size=7, ARG int borderMode=BORDER_DEFAULT, ARG Stream stream=Stream::Null()]>

--- Incoming ---
[   'cv.cuda.fastNlMeansDenoising',
    'void',
    [],
    [   ['GpuMat', 'src', '', ['/C', '/Ref']],
        ['GpuMat', 'dst', '', ['/O', '/Ref']],
        ['float', 'h', '', []],
        ['int', 'search_window', '21', []],
        ['int', 'block_size', '7', []],
        ['Stream', 'stream', 'Stream::Null()', ['/Ref']]],
    'void']
ok: FUNC <void cv.cuda..fastNlMeansDenoising [ARG GpuMat src=, ARG GpuMat dst=, ARG float h=, ARG int search_window=21, ARG int block_size=7, ARG Stream stream=Stream::Null()]>

--- Incoming ---
[   'cv.cuda.fastNlMeansDenoisingColored',
    'void',
    [],
    [   ['GpuMat', 'src', '', ['/C', '/Ref']],
        ['GpuMat', 'dst', '', ['/O', '/Ref']],
        ['float', 'h_luminance', '', []],
        ['float', 'photo_render', '', []],
        ['int', 'search_window', '21', []],
        ['int', 'block_size', '7', []],
        ['Stream', 'stream', 'Stream::Null()', ['/Ref']]],
    'void']
ok: FUNC <void cv.cuda..fastNlMeansDenoisingColored [ARG GpuMat src=, ARG GpuMat dst=, ARG float h_luminance=, ARG float photo_render=, ARG int search_window=21, ARG int block_size=7, ARG Stream stream=Stream::Null()]>


===== Generating... =====
CLASS cv::.AlignExposures : Algorithm
FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
CLASS cv::.AlignMTB : AlignExposures
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>
java: void process(List<Mat> src, List<Mat> dst)
FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>
java: Point calculateShift(Mat img0, Mat img1)
FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>
java: void shiftMat(Mat src, Mat dst, Point shift)
FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>
java: void computeBitmaps(Mat img, Mat tb, Mat eb)
FUNC <int cv.AlignMTB.getMaxBits []>
java: int getMaxBits()
FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>
java: void setMaxBits(int max_bits)
FUNC <int cv.AlignMTB.getExcludeRange []>
java: int getExcludeRange()
FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>
java: void setExcludeRange(int exclude_range)
FUNC <bool cv.AlignMTB.getCut []>
java: boolean getCut()
FUNC <void cv.AlignMTB.setCut [ARG bool value=]>
java: void setCut(boolean value)
CLASS cv::.CalibrateCRF : Algorithm
FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.CalibrateDebevec : CalibrateCRF
FUNC <float cv.CalibrateDebevec.getLambda []>
java: float getLambda()
FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>
java: void setLambda(float lambda)
FUNC <int cv.CalibrateDebevec.getSamples []>
java: int getSamples()
FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>
java: void setSamples(int samples)
FUNC <bool cv.CalibrateDebevec.getRandom []>
java: boolean getRandom()
FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>
java: void setRandom(boolean random)
CLASS cv::.CalibrateRobertson : CalibrateCRF
FUNC <int cv.CalibrateRobertson.getMaxIter []>
java: int getMaxIter()
FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>
java: void setMaxIter(int max_iter)
FUNC <float cv.CalibrateRobertson.getThreshold []>
java: float getThreshold()
FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>
java: void setThreshold(float threshold)
FUNC <Mat cv.CalibrateRobertson.getRadiance []>
java: Mat getRadiance()
CLASS cv::.MergeDebevec : MergeExposures
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.MergeExposures : Algorithm
FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
CLASS cv::.MergeMertens : MergeExposures
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>
java: void process(List<Mat> src, Mat dst)
FUNC <float cv.MergeMertens.getContrastWeight []>
java: float getContrastWeight()
FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>
java: void setContrastWeight(float contrast_weiht)
FUNC <float cv.MergeMertens.getSaturationWeight []>
java: float getSaturationWeight()
FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>
java: void setSaturationWeight(float saturation_weight)
FUNC <float cv.MergeMertens.getExposureWeight []>
java: float getExposureWeight()
FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>
java: void setExposureWeight(float exposure_weight)
CLASS cv::.MergeRobertson : MergeExposures
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.Photo : 
[CONST INPAINT_NS=0, CONST INPAINT_TELEA=1, CONST LDR_SIZE=256, CONST NORMAL_CLONE=1, CONST MIXED_CLONE=2, CONST MONOCHROME_TRANSFER=3, CONST RECURS_FILTER=1, CONST NORMCONV_FILTER=2]
FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>
java: void inpaint(Mat src, Mat inpaintMask, Mat dst, double inpaintRadius, int flags)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h)
java: void fastNlMeansDenoising(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h)
FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h)
FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda, int niters)
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda)
java: void denoise_TVL1(List<Mat> observations, Mat result)
FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>
java: Tonemap createTonemap(float gamma)
java: Tonemap createTonemap()
FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>
java: TonemapDrago createTonemapDrago(float gamma, float saturation, float bias)
java: TonemapDrago createTonemapDrago(float gamma, float saturation)
java: TonemapDrago createTonemapDrago(float gamma)
java: TonemapDrago createTonemapDrago()
FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt, float color_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity)
java: TonemapReinhard createTonemapReinhard(float gamma)
java: TonemapReinhard createTonemapReinhard()
FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale, float saturation)
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale)
java: TonemapMantiuk createTonemapMantiuk(float gamma)
java: TonemapMantiuk createTonemapMantiuk()
FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>
java: AlignMTB createAlignMTB(int max_bits, int exclude_range, boolean cut)
java: AlignMTB createAlignMTB(int max_bits, int exclude_range)
java: AlignMTB createAlignMTB(int max_bits)
java: AlignMTB createAlignMTB()
FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda, boolean random)
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda)
java: CalibrateDebevec createCalibrateDebevec(int samples)
java: CalibrateDebevec createCalibrateDebevec()
FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>
java: CalibrateRobertson createCalibrateRobertson(int max_iter, float threshold)
java: CalibrateRobertson createCalibrateRobertson(int max_iter)
java: CalibrateRobertson createCalibrateRobertson()
FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>
java: MergeDebevec createMergeDebevec()
FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight, float exposure_weight)
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight)
java: MergeMertens createMergeMertens(float contrast_weight)
java: MergeMertens createMergeMertens()
FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>
java: MergeRobertson createMergeRobertson()
FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>
java: void decolor(Mat src, Mat grayscale, Mat color_boost)
FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>
java: void seamlessClone(Mat src, Mat dst, Mat mask, Point p, Mat blend, int flags)
FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul, float blue_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul)
java: void colorChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha, float beta)
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha)
java: void illuminationChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold, int kernel_size)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst)
FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s, float sigma_r)
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s)
java: void edgePreservingFilter(Mat src, Mat dst, int flags)
java: void edgePreservingFilter(Mat src, Mat dst)
FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>
java: void detailEnhance(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void detailEnhance(Mat src, Mat dst, float sigma_s)
java: void detailEnhance(Mat src, Mat dst)
FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r, float shade_factor)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2)
FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>
java: void stylization(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void stylization(Mat src, Mat dst, float sigma_s)
java: void stylization(Mat src, Mat dst)
FUNC <void cv.cuda..nonLocalMeans [ARG GpuMat src=, ARG GpuMat dst=, ARG float h=, ARG int search_window=21, ARG int block_size=7, ARG int borderMode=BORDER_DEFAULT, ARG Stream stream=Stream::Null()]>
SKIP:void cv::cuda::nonLocalMeans(GpuMat src, GpuMat& dst, float h, int search_window = 21, int block_size = 7, int borderMode = BORDER_DEFAULT, Stream stream = Stream::Null())	 due to ARG type GpuMat/I
FUNC <void cv.cuda..fastNlMeansDenoising [ARG GpuMat src=, ARG GpuMat dst=, ARG float h=, ARG int search_window=21, ARG int block_size=7, ARG Stream stream=Stream::Null()]>
SKIP:void cv::cuda::fastNlMeansDenoising(GpuMat src, GpuMat& dst, float h, int search_window = 21, int block_size = 7, Stream stream = Stream::Null())	 due to ARG type GpuMat/I
FUNC <void cv.cuda..fastNlMeansDenoisingColored [ARG GpuMat src=, ARG GpuMat dst=, ARG float h_luminance=, ARG float photo_render=, ARG int search_window=21, ARG int block_size=7, ARG Stream stream=Stream::Null()]>
SKIP:void cv::cuda::fastNlMeansDenoisingColored(GpuMat src, GpuMat& dst, float h_luminance, float photo_render, int search_window = 21, int block_size = 7, Stream stream = Stream::Null())	 due to ARG type GpuMat/I
CLASS cv::.Tonemap : Algorithm
FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>
java: void process(Mat src, Mat dst)
FUNC <float cv.Tonemap.getGamma []>
java: float getGamma()
FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>
java: void setGamma(float gamma)
CLASS cv::.TonemapDrago : Tonemap
FUNC <float cv.TonemapDrago.getSaturation []>
java: float getSaturation()
FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
FUNC <float cv.TonemapDrago.getBias []>
java: float getBias()
FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>
java: void setBias(float bias)
CLASS cv::.TonemapMantiuk : Tonemap
FUNC <float cv.TonemapMantiuk.getScale []>
java: float getScale()
FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>
java: void setScale(float scale)
FUNC <float cv.TonemapMantiuk.getSaturation []>
java: float getSaturation()
FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
CLASS cv::.TonemapReinhard : Tonemap
FUNC <float cv.TonemapReinhard.getIntensity []>
java: float getIntensity()
FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>
java: void setIntensity(float intensity)
FUNC <float cv.TonemapReinhard.getLightAdaptation []>
java: float getLightAdaptation()
FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>
java: void setLightAdaptation(float light_adapt)
FUNC <float cv.TonemapReinhard.getColorAdaptation []>
java: float getColorAdaptation()
FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>
java: void setColorAdaptation(float color_adapt)

=== MODULE: plot (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/plot) ===


Files (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/plot/include/opencv2/plot.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Plot : , name: Plot, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/plot/include/opencv2/plot.hpp =====
Namespaces: ['cv', 'cv.plot']

--- Incoming ---
['class cv.plot.Plot2d', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.plot::.Plot2d : Algorithm, name: Plot2d, base: Algorithm

--- Incoming ---
[   'cv.plot.Plot2d.setMinX',
    'void',
    ['/V', '/PV'],
    [['double', '_plotMinX', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setMinX [ARG double _plotMinX=]>

--- Incoming ---
[   'cv.plot.Plot2d.setMinY',
    'void',
    ['/V', '/PV'],
    [['double', '_plotMinY', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setMinY [ARG double _plotMinY=]>

--- Incoming ---
[   'cv.plot.Plot2d.setMaxX',
    'void',
    ['/V', '/PV'],
    [['double', '_plotMaxX', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setMaxX [ARG double _plotMaxX=]>

--- Incoming ---
[   'cv.plot.Plot2d.setMaxY',
    'void',
    ['/V', '/PV'],
    [['double', '_plotMaxY', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setMaxY [ARG double _plotMaxY=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotLineWidth',
    'void',
    ['/V', '/PV'],
    [['int', '_plotLineWidth', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotLineWidth [ARG int _plotLineWidth=]>

--- Incoming ---
[   'cv.plot.Plot2d.setNeedPlotLine',
    'void',
    ['/V', '/PV'],
    [['bool', '_needPlotLine', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setNeedPlotLine [ARG bool _needPlotLine=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotLineColor',
    'void',
    ['/V', '/PV'],
    [['Scalar', '_plotLineColor', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotLineColor [ARG Scalar _plotLineColor=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotBackgroundColor',
    'void',
    ['/V', '/PV'],
    [['Scalar', '_plotBackgroundColor', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotBackgroundColor [ARG Scalar _plotBackgroundColor=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotAxisColor',
    'void',
    ['/V', '/PV'],
    [['Scalar', '_plotAxisColor', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotAxisColor [ARG Scalar _plotAxisColor=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotGridColor',
    'void',
    ['/V', '/PV'],
    [['Scalar', '_plotGridColor', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotGridColor [ARG Scalar _plotGridColor=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotTextColor',
    'void',
    ['/V', '/PV'],
    [['Scalar', '_plotTextColor', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotTextColor [ARG Scalar _plotTextColor=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPlotSize',
    'void',
    ['/V', '/PV'],
    [['int', '_plotSizeWidth', '', []], ['int', '_plotSizeHeight', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPlotSize [ARG int _plotSizeWidth=, ARG int _plotSizeHeight=]>

--- Incoming ---
[   'cv.plot.Plot2d.setShowGrid',
    'void',
    ['/V', '/PV'],
    [['bool', 'needShowGrid', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setShowGrid [ARG bool needShowGrid=]>

--- Incoming ---
[   'cv.plot.Plot2d.setShowText',
    'void',
    ['/V', '/PV'],
    [['bool', 'needShowText', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setShowText [ARG bool needShowText=]>

--- Incoming ---
[   'cv.plot.Plot2d.setGridLinesNumber',
    'void',
    ['/V', '/PV'],
    [['int', 'gridLinesNumber', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setGridLinesNumber [ARG int gridLinesNumber=]>

--- Incoming ---
[   'cv.plot.Plot2d.setInvertOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', '_invertOrientation', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setInvertOrientation [ARG bool _invertOrientation=]>

--- Incoming ---
[   'cv.plot.Plot2d.setPointIdxToPrint',
    'void',
    ['/V', '/PV'],
    [['int', 'pointIdx', '', []]],
    'void']
ok: FUNC <void cv.plot.Plot2d.setPointIdxToPrint [ARG int pointIdx=]>

--- Incoming ---
[   'cv.plot.Plot2d.render',
    'void',
    ['/V', '/PV'],
    [['Mat', '_plotResult', '', ['/O']]],
    'void']
ok: FUNC <void cv.plot.Plot2d.render [ARG Mat _plotResult=]>

--- Incoming ---
[   'cv.plot.Plot2d.create',
    'Ptr_Plot2d',
    ['/S'],
    [['Mat', 'data', '', []]],
    'Ptr<Plot2d>']
ok: FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat data=]>

--- Incoming ---
[   'cv.plot.Plot2d.create',
    'Ptr_Plot2d',
    ['/S'],
    [['Mat', 'dataX', '', []], ['Mat', 'dataY', '', []]],
    'Ptr<Plot2d>']
ok: FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat dataX=, ARG Mat dataY=]>


===== Generating... =====
CLASS cv::.Plot : 
CLASS cv.plot::.Plot2d : Algorithm
FUNC <void cv.plot.Plot2d.setMinX [ARG double _plotMinX=]>
java: void setMinX(double _plotMinX)
FUNC <void cv.plot.Plot2d.setMinY [ARG double _plotMinY=]>
java: void setMinY(double _plotMinY)
FUNC <void cv.plot.Plot2d.setMaxX [ARG double _plotMaxX=]>
java: void setMaxX(double _plotMaxX)
FUNC <void cv.plot.Plot2d.setMaxY [ARG double _plotMaxY=]>
java: void setMaxY(double _plotMaxY)
FUNC <void cv.plot.Plot2d.setPlotLineWidth [ARG int _plotLineWidth=]>
java: void setPlotLineWidth(int _plotLineWidth)
FUNC <void cv.plot.Plot2d.setNeedPlotLine [ARG bool _needPlotLine=]>
java: void setNeedPlotLine(boolean _needPlotLine)
FUNC <void cv.plot.Plot2d.setPlotLineColor [ARG Scalar _plotLineColor=]>
java: void setPlotLineColor(Scalar _plotLineColor)
FUNC <void cv.plot.Plot2d.setPlotBackgroundColor [ARG Scalar _plotBackgroundColor=]>
java: void setPlotBackgroundColor(Scalar _plotBackgroundColor)
FUNC <void cv.plot.Plot2d.setPlotAxisColor [ARG Scalar _plotAxisColor=]>
java: void setPlotAxisColor(Scalar _plotAxisColor)
FUNC <void cv.plot.Plot2d.setPlotGridColor [ARG Scalar _plotGridColor=]>
java: void setPlotGridColor(Scalar _plotGridColor)
FUNC <void cv.plot.Plot2d.setPlotTextColor [ARG Scalar _plotTextColor=]>
java: void setPlotTextColor(Scalar _plotTextColor)
FUNC <void cv.plot.Plot2d.setPlotSize [ARG int _plotSizeWidth=, ARG int _plotSizeHeight=]>
java: void setPlotSize(int _plotSizeWidth, int _plotSizeHeight)
FUNC <void cv.plot.Plot2d.setShowGrid [ARG bool needShowGrid=]>
java: void setShowGrid(boolean needShowGrid)
FUNC <void cv.plot.Plot2d.setShowText [ARG bool needShowText=]>
java: void setShowText(boolean needShowText)
FUNC <void cv.plot.Plot2d.setGridLinesNumber [ARG int gridLinesNumber=]>
java: void setGridLinesNumber(int gridLinesNumber)
FUNC <void cv.plot.Plot2d.setInvertOrientation [ARG bool _invertOrientation=]>
java: void setInvertOrientation(boolean _invertOrientation)
FUNC <void cv.plot.Plot2d.setPointIdxToPrint [ARG int pointIdx=]>
java: void setPointIdxToPrint(int pointIdx)
FUNC <void cv.plot.Plot2d.render [ARG Mat _plotResult=]>
java: void render(Mat _plotResult)
FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat data=]>
java: Plot2d create(Mat data)
FUNC <Ptr_Plot2d cv.plot.Plot2d.create [ARG Mat dataX=, ARG Mat dataY=]>
java: Plot2d create(Mat dataX, Mat dataY)

=== MODULE: xphoto (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto) ===


Files (7):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/oilpainting.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/white_balance.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/dct_image_denoising.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/tonemap.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/inpainting.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/bm3d_image_denoising.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Xphoto : , name: Xphoto, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/oilpainting.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
[   'cv.xphoto.oilPainting',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'size', '', []],
        ['int', 'dynRatio', '', []],
        ['int', 'code', '', []]],
    'void']
ok: FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=, ARG int code=]>

--- Incoming ---
[   'cv.xphoto.oilPainting',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'size', '', []],
        ['int', 'dynRatio', '', []]],
    'void']
ok: FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/white_balance.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
['class cv.xphoto.WhiteBalancer', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xphoto::.WhiteBalancer : Algorithm, name: WhiteBalancer, base: Algorithm

--- Incoming ---
[   'cv.xphoto.WhiteBalancer.balanceWhite',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.xphoto.WhiteBalancer.balanceWhite [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
['class cv.xphoto.SimpleWB', ': cv::xphoto::WhiteBalancer', [], [], None]
ok: class CLASS cv.xphoto::.SimpleWB : WhiteBalancer, name: SimpleWB, base: WhiteBalancer

--- Incoming ---
['cv.xphoto.SimpleWB.getInputMin', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xphoto.SimpleWB.getInputMin []>

--- Incoming ---
[   'cv.xphoto.SimpleWB.setInputMin',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.SimpleWB.setInputMin [ARG float val=]>

--- Incoming ---
['cv.xphoto.SimpleWB.getInputMax', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xphoto.SimpleWB.getInputMax []>

--- Incoming ---
[   'cv.xphoto.SimpleWB.setInputMax',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.SimpleWB.setInputMax [ARG float val=]>

--- Incoming ---
['cv.xphoto.SimpleWB.getOutputMin', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xphoto.SimpleWB.getOutputMin []>

--- Incoming ---
[   'cv.xphoto.SimpleWB.setOutputMin',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.SimpleWB.setOutputMin [ARG float val=]>

--- Incoming ---
['cv.xphoto.SimpleWB.getOutputMax', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xphoto.SimpleWB.getOutputMax []>

--- Incoming ---
[   'cv.xphoto.SimpleWB.setOutputMax',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.SimpleWB.setOutputMax [ARG float val=]>

--- Incoming ---
['cv.xphoto.SimpleWB.getP', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xphoto.SimpleWB.getP []>

--- Incoming ---
[   'cv.xphoto.SimpleWB.setP',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.SimpleWB.setP [ARG float val=]>

--- Incoming ---
['cv.xphoto.createSimpleWB', 'Ptr_SimpleWB', [], [], 'Ptr<SimpleWB>']
ok: FUNC <Ptr_SimpleWB cv.xphoto..createSimpleWB []>

--- Incoming ---
['class cv.xphoto.GrayworldWB', ': cv::xphoto::WhiteBalancer', [], [], None]
ok: class CLASS cv.xphoto::.GrayworldWB : WhiteBalancer, name: GrayworldWB, base: WhiteBalancer

--- Incoming ---
[   'cv.xphoto.GrayworldWB.getSaturationThreshold',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.GrayworldWB.getSaturationThreshold []>

--- Incoming ---
[   'cv.xphoto.GrayworldWB.setSaturationThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.GrayworldWB.setSaturationThreshold [ARG float val=]>

--- Incoming ---
['cv.xphoto.createGrayworldWB', 'Ptr_GrayworldWB', [], [], 'Ptr<GrayworldWB>']
ok: FUNC <Ptr_GrayworldWB cv.xphoto..createGrayworldWB []>

--- Incoming ---
['class cv.xphoto.LearningBasedWB', ': cv::xphoto::WhiteBalancer', [], [], None]
ok: class CLASS cv.xphoto::.LearningBasedWB : WhiteBalancer, name: LearningBasedWB, base: WhiteBalancer

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.extractSimpleFeatures',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.extractSimpleFeatures [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.getRangeMaxVal',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xphoto.LearningBasedWB.getRangeMaxVal []>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.setRangeMaxVal',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setRangeMaxVal [ARG int val=]>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.getSaturationThreshold',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.LearningBasedWB.getSaturationThreshold []>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.setSaturationThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setSaturationThreshold [ARG float val=]>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.getHistBinNum',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xphoto.LearningBasedWB.getHistBinNum []>

--- Incoming ---
[   'cv.xphoto.LearningBasedWB.setHistBinNum',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.xphoto.LearningBasedWB.setHistBinNum [ARG int val=]>

--- Incoming ---
[   'cv.xphoto.createLearningBasedWB',
    'Ptr_LearningBasedWB',
    [],
    [['String', 'path_to_model', 'String()', ['/C', '/Ref']]],
    'Ptr<LearningBasedWB>']
ok: FUNC <Ptr_LearningBasedWB cv.xphoto..createLearningBasedWB [ARG String path_to_model=String()]>

--- Incoming ---
[   'cv.xphoto.applyChannelGains',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'gainB', '', []],
        ['float', 'gainG', '', []],
        ['float', 'gainR', '', []]],
    'void']
ok: FUNC <void cv.xphoto..applyChannelGains [ARG Mat src=, ARG Mat dst=, ARG float gainB=, ARG float gainG=, ARG float gainR=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/dct_image_denoising.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
[   'cv.xphoto.dctDenoising',
    'void',
    [],
    [   ['Mat', 'src', '', ['/C', '/Ref']],
        ['Mat', 'dst', '', ['/Ref']],
        ['double', 'sigma', '', ['/C']],
        ['int', 'psize', '16', ['/C']]],
    'void']
ok: FUNC <void cv.xphoto..dctDenoising [ARG Mat src=, ARG Mat dst=, ARG double sigma=, ARG int psize=16]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/tonemap.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
['class cv.xphoto.TonemapDurand', ': cv::xphoto::Tonemap', [], [], None]
ok: class CLASS cv.xphoto::.TonemapDurand : Tonemap, name: TonemapDurand, base: Tonemap

--- Incoming ---
[   'cv.xphoto.TonemapDurand.getSaturation',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSaturation []>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.setSaturation',
    'void',
    ['/V', '/PV'],
    [['float', 'saturation', '', []]],
    'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSaturation [ARG float saturation=]>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.getContrast',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getContrast []>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.setContrast',
    'void',
    ['/V', '/PV'],
    [['float', 'contrast', '', []]],
    'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setContrast [ARG float contrast=]>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.getSigmaSpace',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSigmaSpace []>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.setSigmaSpace',
    'void',
    ['/V', '/PV'],
    [['float', 'sigma_space', '', []]],
    'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSigmaSpace [ARG float sigma_space=]>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.getSigmaColor',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xphoto.TonemapDurand.getSigmaColor []>

--- Incoming ---
[   'cv.xphoto.TonemapDurand.setSigmaColor',
    'void',
    ['/V', '/PV'],
    [['float', 'sigma_color', '', []]],
    'void']
ok: FUNC <void cv.xphoto.TonemapDurand.setSigmaColor [ARG float sigma_color=]>

--- Incoming ---
[   'cv.xphoto.createTonemapDurand',
    'Ptr_TonemapDurand',
    [],
    [   ['float', 'gamma', '1.0f', []],
        ['float', 'contrast', '4.0f', []],
        ['float', 'saturation', '1.0f', []],
        ['float', 'sigma_color', '2.0f', []],
        ['float', 'sigma_space', '2.0f', []]],
    'Ptr<TonemapDurand>']
ok: FUNC <Ptr_TonemapDurand cv.xphoto..createTonemapDurand [ARG float gamma=1.0f, ARG float contrast=4.0f, ARG float saturation=1.0f, ARG float sigma_color=2.0f, ARG float sigma_space=2.0f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/inpainting.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
[   'enum cv.xphoto.InpaintTypes',
    '',
    [],
    [   ['const cv.xphoto.INPAINT_SHIFTMAP', '0', [], [], None, ''],
        ['const cv.xphoto.INPAINT_FSR_BEST', '1', [], [], None, ''],
        ['const cv.xphoto.INPAINT_FSR_FAST', '2', [], [], None, '']],
    None]
ok: CONST INPAINT_SHIFTMAP=0
ok: CONST INPAINT_FSR_BEST=1
ok: CONST INPAINT_FSR_FAST=2

--- Incoming ---
[   'cv.xphoto.inpaint',
    'void',
    [],
    [   ['Mat', 'src', '', ['/C', '/Ref']],
        ['Mat', 'mask', '', ['/C', '/Ref']],
        ['Mat', 'dst', '', ['/Ref']],
        ['int', 'algorithmType', '', ['/C']]],
    'void']
ok: FUNC <void cv.xphoto..inpaint [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG int algorithmType=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xphoto/include/opencv2/xphoto/bm3d_image_denoising.hpp =====
Namespaces: ['cv', 'cv.xphoto']

--- Incoming ---
[   'enum cv.xphoto.TransformTypes',
    '',
    [],
    [['const cv.xphoto.HAAR', '0', [], [], None, '']],
    None]
ok: CONST HAAR=0

--- Incoming ---
[   'enum cv.xphoto.Bm3dSteps',
    '',
    [],
    [   ['const cv.xphoto.BM3D_STEPALL', '0', [], [], None, ''],
        ['const cv.xphoto.BM3D_STEP1', '1', [], [], None, ''],
        ['const cv.xphoto.BM3D_STEP2', '2', [], [], None, '']],
    None]
ok: CONST BM3D_STEPALL=0
ok: CONST BM3D_STEP1=1
ok: CONST BM3D_STEP2=2

--- Incoming ---
[   'cv.xphoto.bm3dDenoising',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dstStep1', '', ['/IO']],
        ['Mat', 'dstStep2', '', ['/O']],
        ['float', 'h', '1', []],
        ['int', 'templateWindowSize', '4', []],
        ['int', 'searchWindowSize', '16', []],
        ['int', 'blockMatchingStep1', '2500', []],
        ['int', 'blockMatchingStep2', '400', []],
        ['int', 'groupSize', '8', []],
        ['int', 'slidingStep', '1', []],
        ['float', 'beta', '2.0f', []],
        ['int', 'normType', 'cv::NORM_L2', []],
        ['int', 'step', 'cv::xphoto::BM3D_STEPALL', []],
        ['int', 'transformType', 'cv::xphoto::HAAR', []]],
    'void']
ok: FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dstStep1=, ARG Mat dstStep2=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>

--- Incoming ---
[   'cv.xphoto.bm3dDenoising',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'h', '1', []],
        ['int', 'templateWindowSize', '4', []],
        ['int', 'searchWindowSize', '16', []],
        ['int', 'blockMatchingStep1', '2500', []],
        ['int', 'blockMatchingStep2', '400', []],
        ['int', 'groupSize', '8', []],
        ['int', 'slidingStep', '1', []],
        ['float', 'beta', '2.0f', []],
        ['int', 'normType', 'cv::NORM_L2', []],
        ['int', 'step', 'cv::xphoto::BM3D_STEPALL', []],
        ['int', 'transformType', 'cv::xphoto::HAAR', []]],
    'void']
ok: FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>


===== Generating... =====
CLASS cv::.Xphoto : 
[CONST BM3D_STEPALL=0, CONST BM3D_STEP1=1, CONST BM3D_STEP2=2]
[CONST INPAINT_SHIFTMAP=0, CONST INPAINT_FSR_BEST=1, CONST INPAINT_FSR_FAST=2]
[CONST HAAR=0]
FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=, ARG int code=]>
java: void oilPainting(Mat src, Mat dst, int size, int dynRatio, int code)
FUNC <void cv.xphoto..oilPainting [ARG Mat src=, ARG Mat dst=, ARG int size=, ARG int dynRatio=]>
java: void oilPainting(Mat src, Mat dst, int size, int dynRatio)
FUNC <Ptr_SimpleWB cv.xphoto..createSimpleWB []>
java: SimpleWB createSimpleWB()
FUNC <Ptr_GrayworldWB cv.xphoto..createGrayworldWB []>
java: GrayworldWB createGrayworldWB()
FUNC <Ptr_LearningBasedWB cv.xphoto..createLearningBasedWB [ARG String path_to_model=String()]>
java: LearningBasedWB createLearningBasedWB(String path_to_model)
java: LearningBasedWB createLearningBasedWB()
FUNC <void cv.xphoto..applyChannelGains [ARG Mat src=, ARG Mat dst=, ARG float gainB=, ARG float gainG=, ARG float gainR=]>
java: void applyChannelGains(Mat src, Mat dst, float gainB, float gainG, float gainR)
FUNC <void cv.xphoto..dctDenoising [ARG Mat src=, ARG Mat dst=, ARG double sigma=, ARG int psize=16]>
java: void dctDenoising(Mat src, Mat dst, double sigma, int psize)
java: void dctDenoising(Mat src, Mat dst, double sigma)
FUNC <Ptr_TonemapDurand cv.xphoto..createTonemapDurand [ARG float gamma=1.0f, ARG float contrast=4.0f, ARG float saturation=1.0f, ARG float sigma_color=2.0f, ARG float sigma_space=2.0f]>
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation, float sigma_color, float sigma_space)
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation, float sigma_color)
java: TonemapDurand createTonemapDurand(float gamma, float contrast, float saturation)
java: TonemapDurand createTonemapDurand(float gamma, float contrast)
java: TonemapDurand createTonemapDurand(float gamma)
java: TonemapDurand createTonemapDurand()
FUNC <void cv.xphoto..inpaint [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG int algorithmType=]>
java: void inpaint(Mat src, Mat mask, Mat dst, int algorithmType)
FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dstStep1=, ARG Mat dstStep2=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step, int transformType)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize, int searchWindowSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h, int templateWindowSize)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2, float h)
java: void bm3dDenoising(Mat src, Mat dstStep1, Mat dstStep2)
FUNC <void cv.xphoto..bm3dDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=1, ARG int templateWindowSize=4, ARG int searchWindowSize=16, ARG int blockMatchingStep1=2500, ARG int blockMatchingStep2=400, ARG int groupSize=8, ARG int slidingStep=1, ARG float beta=2.0f, ARG int normType=cv::NORM_L2, ARG int step=cv::xphoto::BM3D_STEPALL, ARG int transformType=cv::xphoto::HAAR]>
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step, int transformType)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType, int step)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta, int normType)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep, float beta)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize, int slidingStep)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2, int groupSize)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1, int blockMatchingStep2)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize, int blockMatchingStep1)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize)
java: void bm3dDenoising(Mat src, Mat dst, float h, int templateWindowSize)
java: void bm3dDenoising(Mat src, Mat dst, float h)
java: void bm3dDenoising(Mat src, Mat dst)
CLASS cv.xphoto::.GrayworldWB : WhiteBalancer
FUNC <float cv.xphoto.GrayworldWB.getSaturationThreshold []>
java: float getSaturationThreshold()
FUNC <void cv.xphoto.GrayworldWB.setSaturationThreshold [ARG float val=]>
java: void setSaturationThreshold(float val)
CLASS cv.xphoto::.LearningBasedWB : WhiteBalancer
FUNC <void cv.xphoto.LearningBasedWB.extractSimpleFeatures [ARG Mat src=, ARG Mat dst=]>
java: void extractSimpleFeatures(Mat src, Mat dst)
FUNC <int cv.xphoto.LearningBasedWB.getRangeMaxVal []>
java: int getRangeMaxVal()
FUNC <void cv.xphoto.LearningBasedWB.setRangeMaxVal [ARG int val=]>
java: void setRangeMaxVal(int val)
FUNC <float cv.xphoto.LearningBasedWB.getSaturationThreshold []>
java: float getSaturationThreshold()
FUNC <void cv.xphoto.LearningBasedWB.setSaturationThreshold [ARG float val=]>
java: void setSaturationThreshold(float val)
FUNC <int cv.xphoto.LearningBasedWB.getHistBinNum []>
java: int getHistBinNum()
FUNC <void cv.xphoto.LearningBasedWB.setHistBinNum [ARG int val=]>
java: void setHistBinNum(int val)
CLASS cv.xphoto::.SimpleWB : WhiteBalancer
FUNC <float cv.xphoto.SimpleWB.getInputMin []>
java: float getInputMin()
FUNC <void cv.xphoto.SimpleWB.setInputMin [ARG float val=]>
java: void setInputMin(float val)
FUNC <float cv.xphoto.SimpleWB.getInputMax []>
java: float getInputMax()
FUNC <void cv.xphoto.SimpleWB.setInputMax [ARG float val=]>
java: void setInputMax(float val)
FUNC <float cv.xphoto.SimpleWB.getOutputMin []>
java: float getOutputMin()
FUNC <void cv.xphoto.SimpleWB.setOutputMin [ARG float val=]>
java: void setOutputMin(float val)
FUNC <float cv.xphoto.SimpleWB.getOutputMax []>
java: float getOutputMax()
FUNC <void cv.xphoto.SimpleWB.setOutputMax [ARG float val=]>
java: void setOutputMax(float val)
FUNC <float cv.xphoto.SimpleWB.getP []>
java: float getP()
FUNC <void cv.xphoto.SimpleWB.setP [ARG float val=]>
java: void setP(float val)
CLASS cv.xphoto::.TonemapDurand : Tonemap
FUNC <float cv.xphoto.TonemapDurand.getSaturation []>
java: float getSaturation()
FUNC <void cv.xphoto.TonemapDurand.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
FUNC <float cv.xphoto.TonemapDurand.getContrast []>
java: float getContrast()
FUNC <void cv.xphoto.TonemapDurand.setContrast [ARG float contrast=]>
java: void setContrast(float contrast)
FUNC <float cv.xphoto.TonemapDurand.getSigmaSpace []>
java: float getSigmaSpace()
FUNC <void cv.xphoto.TonemapDurand.setSigmaSpace [ARG float sigma_space=]>
java: void setSigmaSpace(float sigma_space)
FUNC <float cv.xphoto.TonemapDurand.getSigmaColor []>
java: float getSigmaColor()
FUNC <void cv.xphoto.TonemapDurand.setSigmaColor [ARG float sigma_color=]>
java: void setSigmaColor(float sigma_color)
CLASS cv.xphoto::.WhiteBalancer : Algorithm
FUNC <void cv.xphoto.WhiteBalancer.balanceWhite [ARG Mat src=, ARG Mat dst=]>
java: void balanceWhite(Mat src, Mat dst)

=== MODULE: dnn (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn) ===


Files (9):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/version.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/layer.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/shape_utils.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/all_layers.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/dnn.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/dict.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/utils/debug_utils.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp']

Common headers (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/misc/java/src/cpp/dnn_converters.hpp']
ok: class CLASS cv::.Dnn : , name: Dnn, base: 

===== Common header : /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/misc/java/src/cpp/dnn_converters.hpp =====


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/version.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.CV__DNN_INLINE_NS']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/version.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/layer.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.CV__DNN_INLINE_NS']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/layer.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/shape_utils.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/shape_utils.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/all_layers.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/all_layers.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/dnn.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS', 'cv.dnn.accessor']

--- Incoming ---
[   'enum cv.dnn.Backend',
    '',
    [],
    [   ['const cv.dnn.DNN_BACKEND_DEFAULT', '0', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_HALIDE', '0+1', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE', '0+2', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_OPENCV', '0+3', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_VKCOM', '0+4', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_CUDA', '0+5', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_WEBNN', '0+6', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_TIMVX', '0+7', [], [], None, ''],
        ['const cv.dnn.DNN_BACKEND_CANN', '0+8', [], [], None, '']],
    None]
ok: CONST DNN_BACKEND_DEFAULT=0
ok: CONST DNN_BACKEND_HALIDE=0+1
ok: CONST DNN_BACKEND_INFERENCE_ENGINE=0+2
ok: CONST DNN_BACKEND_OPENCV=0+3
ok: CONST DNN_BACKEND_VKCOM=0+4
ok: CONST DNN_BACKEND_CUDA=0+5
ok: CONST DNN_BACKEND_WEBNN=0+6
ok: CONST DNN_BACKEND_TIMVX=0+7
ok: CONST DNN_BACKEND_CANN=0+8

--- Incoming ---
[   'enum cv.dnn.Target',
    '',
    [],
    [   ['const cv.dnn.DNN_TARGET_CPU', '0', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_OPENCL', '0+1', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_OPENCL_FP16', '0+2', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_MYRIAD', '0+3', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_VULKAN', '0+4', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_FPGA', '0+5', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_CUDA', '0+6', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_CUDA_FP16', '0+7', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_HDDL', '0+8', [], [], None, ''],
        ['const cv.dnn.DNN_TARGET_NPU', '0+9', [], [], None, '']],
    None]
ok: CONST DNN_TARGET_CPU=0
ok: CONST DNN_TARGET_OPENCL=0+1
ok: CONST DNN_TARGET_OPENCL_FP16=0+2
ok: CONST DNN_TARGET_MYRIAD=0+3
ok: CONST DNN_TARGET_VULKAN=0+4
ok: CONST DNN_TARGET_FPGA=0+5
ok: CONST DNN_TARGET_CUDA=0+6
ok: CONST DNN_TARGET_CUDA_FP16=0+7
ok: CONST DNN_TARGET_HDDL=0+8
ok: CONST DNN_TARGET_NPU=0+9

--- Incoming ---
[   'cv.dnn.getAvailableTargets',
    'vector_Target',
    [],
    [['dnn_Backend', 'be', '', []]],
    'std::vector<Target>']
ok: FUNC <vector_Target cv.dnn..getAvailableTargets [ARG dnn_Backend be=]>

--- Incoming ---
[   'class cv.dnn.Layer',
    ': cv::Algorithm',
    [],
    [   ['vector_Mat', 'blobs', '', ['/RW']],
        ['String', 'name', '', []],
        ['String', 'type', '', []],
        ['int', 'preferableTarget', '', []]],
    None]
ok: class CLASS cv.dnn::.Layer : Algorithm, name: Layer, base: Algorithm

--- Incoming ---
[   'cv.dnn.Layer.finalize',
    'void',
    ['/V'],
    [['vector_Mat', 'inputs', '', []], ['vector_Mat', 'outputs', '', ['/O']]],
    'void']
ok: FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>

--- Incoming ---
[   'cv.dnn.Layer.run',
    'void',
    [],
    [   ['vector_Mat', 'inputs', '', ['/C', '/Ref']],
        ['vector_Mat', 'outputs', '', ['/O', '/Ref']],
        ['vector_Mat', 'internals', '', ['/IO', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>

--- Incoming ---
[   'cv.dnn.Layer.outputNameToIndex',
    'int',
    ['/V'],
    [['String', 'outputName', '', ['/C', '/Ref']]],
    'int']
ok: FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>

--- Incoming ---
['class cv.dnn.Net', '', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.Net : , name: Net, base: 

--- Incoming ---
['cv.dnn.Net.Net', '', [], [], None]
ok: FUNC < cv.dnn.Net.Net []>

--- Incoming ---
[   'cv.dnn.Net.readFromModelOptimizer',
    'Net',
    ['/S'],
    [   ['String', 'xml', '', ['/C', '/Ref']],
        ['String', 'bin', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[   'cv.dnn.Net.readFromModelOptimizer',
    'Net',
    ['/S'],
    [   ['vector_uchar', 'bufferModelConfig', '', ['/C', '/Ref']],
        ['vector_uchar', 'bufferWeights', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>

--- Incoming ---
['cv.dnn.Net.empty', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.dnn.Net.empty []>

--- Incoming ---
['cv.dnn.Net.dump', 'String', [], [], 'String']
ok: FUNC <String cv.dnn.Net.dump []>

--- Incoming ---
[   'cv.dnn.Net.dumpToFile',
    'void',
    [],
    [['String', 'path', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>

--- Incoming ---
[   'cv.dnn.Net.getLayerId',
    'int',
    ['/C'],
    [['String', 'layer', '', ['/C', '/Ref']]],
    'int']
ok: FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>

--- Incoming ---
['cv.dnn.Net.getLayerNames', 'vector_String', ['/C'], [], 'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getLayerNames []>

--- Incoming ---
[   'cv.dnn.Net.getLayer',
    'Ptr_Layer',
    ['/C'],
    [['int', 'layerId', '', []]],
    'Ptr<Layer>']
ok: FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG int layerId=]>

--- Incoming ---
[   'cv.dnn.Net.getLayer',
    'Ptr_Layer',
    ['/C'],
    [['String', 'layerName', '', ['/C', '/Ref']]],
    'Ptr<Layer>']
ok: FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG String layerName=]>

--- Incoming ---
[   'cv.dnn.Net.getLayer',
    'Ptr_Layer',
    ['/C'],
    [['LayerId', 'layerId', '', ['/C', '/Ref']]],
    'Ptr<Layer>']
ok: FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>

--- Incoming ---
[   'cv.dnn.Net.connect',
    'void',
    [],
    [['String', 'outPin', '', []], ['String', 'inpPin', '', []]],
    'void']
ok: FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>

--- Incoming ---
[   'cv.dnn.Net.setInputsNames',
    'void',
    [],
    [['vector_String', 'inputBlobNames', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>

--- Incoming ---
[   'cv.dnn.Net.setInputShape',
    'void',
    [],
    [   ['String', 'inputName', '', ['/C', '/Ref']],
        ['MatShape', 'shape', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setInputShape [ARG String inputName=, ARG MatShape shape=]>

--- Incoming ---
[   'cv.dnn.Net.forward',
    'Mat',
    [],
    [['String', 'outputName', 'String()', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>

--- Incoming ---
[   'cv.dnn.Net.forwardAsync',
    'AsyncArray',
    [],
    [['String', 'outputName', 'String()', ['/C', '/Ref']]],
    'AsyncArray']
ok: FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    [],
    [   ['vector_Mat', 'outputBlobs', '', ['/O']],
        ['String', 'outputName', 'String()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    [],
    [   ['vector_Mat', 'outputBlobs', '', ['/O']],
        ['vector_String', 'outBlobNames', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   'cv.dnn.Net.forward',
    'void',
    ['=forwardAndRetrieve'],
    [   ['vector_vector_Mat', 'outputBlobs', '', ['/O', '/Ref']],
        ['vector_String', 'outBlobNames', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   'cv.dnn.Net.quantize',
    'Net',
    [],
    [   ['vector_Mat', 'calibData', '', []],
        ['int', 'inputsDtype', '', []],
        ['int', 'outputsDtype', '', []],
        ['bool', 'perChannel', 'true', []]],
    'Net']
ok: FUNC <Net cv.dnn.Net.quantize [ARG vector_Mat calibData=, ARG int inputsDtype=, ARG int outputsDtype=, ARG bool perChannel=true]>

--- Incoming ---
[   'cv.dnn.Net.getInputDetails',
    'void',
    ['/C'],
    [   ['vector_float', 'scales', '', ['/O', '/Ref']],
        ['vector_int', 'zeropoints', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getInputDetails [ARG vector_float scales=, ARG vector_int zeropoints=]>

--- Incoming ---
[   'cv.dnn.Net.getOutputDetails',
    'void',
    ['/C'],
    [   ['vector_float', 'scales', '', ['/O', '/Ref']],
        ['vector_int', 'zeropoints', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getOutputDetails [ARG vector_float scales=, ARG vector_int zeropoints=]>

--- Incoming ---
[   'cv.dnn.Net.setHalideScheduler',
    'void',
    [],
    [['String', 'scheduler', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>

--- Incoming ---
[   'cv.dnn.Net.setPreferableBackend',
    'void',
    [],
    [['int', 'backendId', '', []]],
    'void']
ok: FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>

--- Incoming ---
[   'cv.dnn.Net.setPreferableTarget',
    'void',
    [],
    [['int', 'targetId', '', []]],
    'void']
ok: FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>

--- Incoming ---
[   'cv.dnn.Net.setInput',
    'void',
    [],
    [   ['Mat', 'blob', '', []],
        ['String', 'name', '""', ['/C', '/Ref']],
        ['double', 'scalefactor', '1.0', []],
        ['Scalar', 'mean', 'Scalar()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>

--- Incoming ---
[   'cv.dnn.Net.setParam',
    'void',
    [],
    [   ['int', 'layer', '', []],
        ['int', 'numParam', '', []],
        ['Mat', 'blob', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setParam [ARG int layer=, ARG int numParam=, ARG Mat blob=]>

--- Incoming ---
[   'cv.dnn.Net.setParam',
    'void',
    [],
    [   ['String', 'layerName', '', ['/C', '/Ref']],
        ['int', 'numParam', '', []],
        ['Mat', 'blob', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.setParam [ARG String layerName=, ARG int numParam=, ARG Mat blob=]>

--- Incoming ---
[   'cv.dnn.Net.getParam',
    'Mat',
    ['/C'],
    [['int', 'layer', '', []], ['int', 'numParam', '0', []]],
    'Mat']
ok: FUNC <Mat cv.dnn.Net.getParam [ARG int layer=, ARG int numParam=0]>

--- Incoming ---
[   'cv.dnn.Net.getParam',
    'Mat',
    ['/C'],
    [['String', 'layerName', '', ['/C', '/Ref']], ['int', 'numParam', '0', []]],
    'Mat']
ok: FUNC <Mat cv.dnn.Net.getParam [ARG String layerName=, ARG int numParam=0]>

--- Incoming ---
[   'cv.dnn.Net.getUnconnectedOutLayers',
    'vector_int',
    ['/C'],
    [],
    'std::vector<int>']
ok: FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>

--- Incoming ---
[   'cv.dnn.Net.getUnconnectedOutLayersNames',
    'vector_String',
    ['/C'],
    [],
    'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>

--- Incoming ---
[   'cv.dnn.Net.getLayersShapes',
    'void',
    ['/C'],
    [   ['vector_MatShape', 'netInputShapes', '', ['/C', '/Ref']],
        ['vector_int', 'layersIds', '', ['/O', '/Ref']],
        ['vector_vector_MatShape', 'inLayersShapes', '', ['/O', '/Ref']],
        ['vector_vector_MatShape', 'outLayersShapes', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   'cv.dnn.Net.getLayersShapes',
    'void',
    ['/C'],
    [   ['MatShape', 'netInputShape', '', ['/C', '/Ref']],
        ['vector_int', 'layersIds', '', ['/O', '/Ref']],
        ['vector_vector_MatShape', 'inLayersShapes', '', ['/O', '/Ref']],
        ['vector_vector_MatShape', 'outLayersShapes', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [['vector_MatShape', 'netInputShapes', '', ['/C', '/Ref']]],
    'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [['MatShape', 'netInputShape', '', ['/C', '/Ref']]],
    'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [   ['int', 'layerId', '', ['/C']],
        ['vector_MatShape', 'netInputShapes', '', ['/C', '/Ref']]],
    'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   'cv.dnn.Net.getFLOPS',
    'int64',
    ['/C'],
    [   ['int', 'layerId', '', ['/C']],
        ['MatShape', 'netInputShape', '', ['/C', '/Ref']]],
    'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>

--- Incoming ---
[   'cv.dnn.Net.getLayerTypes',
    'void',
    ['/C'],
    [['vector_String', 'layersTypes', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>

--- Incoming ---
[   'cv.dnn.Net.getLayersCount',
    'int',
    ['/C'],
    [['String', 'layerType', '', ['/C', '/Ref']]],
    'int']
ok: FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['MatShape', 'netInputShape', '', ['/C', '/Ref']],
        ['size_t', 'weights', '', ['/O', '/Ref']],
        ['size_t', 'blobs', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['int', 'layerId', '', ['/C']],
        ['vector_MatShape', 'netInputShapes', '', ['/C', '/Ref']],
        ['size_t', 'weights', '', ['/O', '/Ref']],
        ['size_t', 'blobs', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   'cv.dnn.Net.getMemoryConsumption',
    'void',
    ['/C'],
    [   ['int', 'layerId', '', ['/C']],
        ['MatShape', 'netInputShape', '', ['/C', '/Ref']],
        ['size_t', 'weights', '', ['/O', '/Ref']],
        ['size_t', 'blobs', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
['cv.dnn.Net.enableFusion', 'void', [], [['bool', 'fusion', '', []]], 'void']
ok: FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>

--- Incoming ---
[   'cv.dnn.Net.enableWinograd',
    'void',
    [],
    [['bool', 'useWinograd', '', []]],
    'void']
ok: FUNC <void cv.dnn.Net.enableWinograd [ARG bool useWinograd=]>

--- Incoming ---
[   'cv.dnn.Net.getPerfProfile',
    'int64',
    [],
    [['vector_double', 'timings', '', ['/O', '/Ref']]],
    'int64']
ok: FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>

--- Incoming ---
[   'cv.dnn.readNetFromDarknet',
    'Net',
    [],
    [   ['String', 'cfgFile', '', ['/C', '/Ref']],
        ['String', 'darknetModel', 'String()', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>

--- Incoming ---
[   'cv.dnn.readNetFromDarknet',
    'Net',
    [],
    [   ['vector_uchar', 'bufferCfg', '', ['/C', '/Ref']],
        [   'vector_uchar',
            'bufferModel',
            'std::vector<uchar>()',
            ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   'cv.dnn.readNetFromCaffe',
    'Net',
    [],
    [   ['String', 'prototxt', '', ['/C', '/Ref']],
        ['String', 'caffeModel', 'String()', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>

--- Incoming ---
[   'cv.dnn.readNetFromCaffe',
    'Net',
    [],
    [   ['vector_uchar', 'bufferProto', '', ['/C', '/Ref']],
        [   'vector_uchar',
            'bufferModel',
            'std::vector<uchar>()',
            ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   'cv.dnn.readNetFromTensorflow',
    'Net',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', 'String()', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>

--- Incoming ---
[   'cv.dnn.readNetFromTensorflow',
    'Net',
    [],
    [   ['vector_uchar', 'bufferModel', '', ['/C', '/Ref']],
        [   'vector_uchar',
            'bufferConfig',
            'std::vector<uchar>()',
            ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   'cv.dnn.readNetFromTFLite',
    'Net',
    [],
    [['String', 'model', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromTFLite [ARG String model=]>

--- Incoming ---
[   'cv.dnn.readNetFromTFLite',
    'Net',
    [],
    [['vector_uchar', 'bufferModel', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromTFLite [ARG vector_uchar bufferModel=]>

--- Incoming ---
[   'cv.dnn.readNetFromTorch',
    'Net',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['bool', 'isBinary', 'true', []],
        ['bool', 'evaluate', 'true', []]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>

--- Incoming ---
[   'cv.dnn.readNet',
    'Net',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']],
        ['String', 'framework', '""', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>

--- Incoming ---
[   'cv.dnn.readNet',
    'Net',
    [],
    [   ['String', 'framework', '', ['/C', '/Ref']],
        ['vector_uchar', 'bufferModel', '', ['/C', '/Ref']],
        [   'vector_uchar',
            'bufferConfig',
            'std::vector<uchar>()',
            ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   'cv.dnn.readTorchBlob',
    'Mat',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['bool', 'isBinary', 'true', []]],
    'Mat']
ok: FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>

--- Incoming ---
[   'cv.dnn.readNetFromModelOptimizer',
    'Net',
    [],
    [   ['String', 'xml', '', ['/C', '/Ref']],
        ['String', 'bin', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[   'cv.dnn.readNetFromModelOptimizer',
    'Net',
    [],
    [   ['vector_uchar', 'bufferModelConfig', '', ['/C', '/Ref']],
        ['vector_uchar', 'bufferWeights', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>

--- Incoming ---
[   'cv.dnn.readNetFromONNX',
    'Net',
    [],
    [['String', 'onnxFile', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>

--- Incoming ---
[   'cv.dnn.readNetFromONNX',
    'Net',
    [],
    [['vector_uchar', 'buffer', '', ['/C', '/Ref']]],
    'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>

--- Incoming ---
[   'cv.dnn.readTensorFromONNX',
    'Mat',
    [],
    [['String', 'path', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>

--- Incoming ---
[   'cv.dnn.blobFromImage',
    'Mat',
    [],
    [   ['Mat', 'image', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['Size', 'size', 'Size()', ['/C', '/Ref']],
        ['Scalar', 'mean', 'Scalar()', ['/C', '/Ref']],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    'Mat']
ok: FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   'cv.dnn.blobFromImages',
    'Mat',
    [],
    [   ['vector_Mat', 'images', '', []],
        ['double', 'scalefactor', '1.0', []],
        ['Size', 'size', 'Size()', []],
        ['Scalar', 'mean', 'Scalar()', ['/C', '/Ref']],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []],
        ['int', 'ddepth', 'CV_32F', []]],
    'Mat']
ok: FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   'cv.dnn.imagesFromBlob',
    'void',
    [],
    [   ['Mat', 'blob_', '', ['/C', '/Ref']],
        ['vector_Mat', 'images_', '', ['/O']]],
    'void']
ok: FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>

--- Incoming ---
[   'cv.dnn.shrinkCaffeModel',
    'void',
    [],
    [   ['String', 'src', '', ['/C', '/Ref']],
        ['String', 'dst', '', ['/C', '/Ref']],
        [   'vector_String',
            'layersTypes',
            'std::vector<String>()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>

--- Incoming ---
[   'cv.dnn.writeTextGraph',
    'void',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'output', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>

--- Incoming ---
[   'cv.dnn.NMSBoxes',
    'void',
    [],
    [   ['vector_Rect2d', 'bboxes', '', ['/C', '/Ref']],
        ['vector_float', 'scores', '', ['/C', '/Ref']],
        ['float', 'score_threshold', '', ['/C']],
        ['float', 'nms_threshold', '', ['/C']],
        ['vector_int', 'indices', '', ['/O', '/Ref']],
        ['float', 'eta', '1.f', ['/C']],
        ['int', 'top_k', '0', ['/C']]],
    'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   'cv.dnn.NMSBoxes',
    'void',
    ['=NMSBoxesRotated'],
    [   ['vector_RotatedRect', 'bboxes', '', ['/C', '/Ref']],
        ['vector_float', 'scores', '', ['/C', '/Ref']],
        ['float', 'score_threshold', '', ['/C']],
        ['float', 'nms_threshold', '', ['/C']],
        ['vector_int', 'indices', '', ['/O', '/Ref']],
        ['float', 'eta', '1.f', ['/C']],
        ['int', 'top_k', '0', ['/C']]],
    'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   'cv.dnn.NMSBoxesBatched',
    'void',
    [],
    [   ['vector_Rect2d', 'bboxes', '', ['/C', '/Ref']],
        ['vector_float', 'scores', '', ['/C', '/Ref']],
        ['vector_int', 'class_ids', '', ['/C', '/Ref']],
        ['float', 'score_threshold', '', ['/C']],
        ['float', 'nms_threshold', '', ['/C']],
        ['vector_int', 'indices', '', ['/O', '/Ref']],
        ['float', 'eta', '1.f', ['/C']],
        ['int', 'top_k', '0', ['/C']]],
    'void']
ok: FUNC <void cv.dnn..NMSBoxesBatched [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG vector_int class_ids=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   'enum class cv.dnn.SoftNMSMethod',
    '',
    [],
    [   ['const cv.dnn.SoftNMSMethod.SOFTNMS_LINEAR', '1', [], [], None, ''],
        ['const cv.dnn.SoftNMSMethod.SOFTNMS_GAUSSIAN', '2', [], [], None, '']],
    None]
class not found: CONST SOFTNMS_LINEAR=1
ok: CONST SoftNMSMethod_SOFTNMS_LINEAR=1
class not found: CONST SOFTNMS_GAUSSIAN=2
ok: CONST SoftNMSMethod_SOFTNMS_GAUSSIAN=2

--- Incoming ---
[   'cv.dnn.softNMSBoxes',
    'void',
    [],
    [   ['vector_Rect', 'bboxes', '', ['/C', '/Ref']],
        ['vector_float', 'scores', '', ['/C', '/Ref']],
        ['vector_float', 'updated_scores', '', ['/O', '/Ref']],
        ['float', 'score_threshold', '', ['/C']],
        ['float', 'nms_threshold', '', ['/C']],
        ['vector_int', 'indices', '', ['/O', '/Ref']],
        ['size_t', 'top_k', '0', []],
        ['float', 'sigma', '0.5', ['/C']],
        ['SoftNMSMethod', 'method', 'SoftNMSMethod::SOFTNMS_GAUSSIAN', []]],
    'void']
ok: FUNC <void cv.dnn..softNMSBoxes [ARG vector_Rect bboxes=, ARG vector_float scores=, ARG vector_float updated_scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG size_t top_k=0, ARG float sigma=0.5, ARG SoftNMSMethod method=SoftNMSMethod::SOFTNMS_GAUSSIAN]>

--- Incoming ---
['class cv.dnn.Model', '', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.Model : , name: Model, base: 

--- Incoming ---
[   'cv.dnn.Model.Model',
    '',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.Model.Model [ARG String model=, ARG String config=""]>

--- Incoming ---
['cv.dnn.Model.Model', '', [], [['Net', 'network', '', ['/C', '/Ref']]], None]
ok: FUNC < cv.dnn.Model.Model [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.Model.setInputSize',
    'Model',
    [],
    [['Size', 'size', '', ['/C', '/Ref']]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setInputSize [ARG Size size=]>

--- Incoming ---
[   'cv.dnn.Model.setInputSize',
    'Model',
    [],
    [['int', 'width', '', []], ['int', 'height', '', []]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setInputSize [ARG int width=, ARG int height=]>

--- Incoming ---
[   'cv.dnn.Model.setInputMean',
    'Model',
    [],
    [['Scalar', 'mean', '', ['/C', '/Ref']]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setInputMean [ARG Scalar mean=]>

--- Incoming ---
[   'cv.dnn.Model.setInputScale',
    'Model',
    [],
    [['double', 'scale', '', []]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setInputScale [ARG double scale=]>

--- Incoming ---
['cv.dnn.Model.setInputCrop', 'Model', [], [['bool', 'crop', '', []]], 'Model']
ok: FUNC <Model cv.dnn.Model.setInputCrop [ARG bool crop=]>

--- Incoming ---
[   'cv.dnn.Model.setInputSwapRB',
    'Model',
    [],
    [['bool', 'swapRB', '', []]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setInputSwapRB [ARG bool swapRB=]>

--- Incoming ---
[   'cv.dnn.Model.setInputParams',
    'void',
    [],
    [   ['double', 'scale', '1.0', []],
        ['Size', 'size', 'Size()', ['/C', '/Ref']],
        ['Scalar', 'mean', 'Scalar()', ['/C', '/Ref']],
        ['bool', 'swapRB', 'false', []],
        ['bool', 'crop', 'false', []]],
    'void']
ok: FUNC <void cv.dnn.Model.setInputParams [ARG double scale=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false]>

--- Incoming ---
[   'cv.dnn.Model.predict',
    'void',
    ['/C'],
    [['Mat', 'frame', '', []], ['vector_Mat', 'outs', '', ['/O']]],
    'void']
ok: FUNC <void cv.dnn.Model.predict [ARG Mat frame=, ARG vector_Mat outs=]>

--- Incoming ---
[   'cv.dnn.Model.setPreferableBackend',
    'Model',
    [],
    [['dnn_Backend', 'backendId', '', []]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setPreferableBackend [ARG dnn_Backend backendId=]>

--- Incoming ---
[   'cv.dnn.Model.setPreferableTarget',
    'Model',
    [],
    [['dnn_Target', 'targetId', '', []]],
    'Model']
ok: FUNC <Model cv.dnn.Model.setPreferableTarget [ARG dnn_Target targetId=]>

--- Incoming ---
['class cv.dnn.ClassificationModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.ClassificationModel : Model, name: ClassificationModel, base: Model

--- Incoming ---
[   'cv.dnn.ClassificationModel.ClassificationModel',
    '',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   'cv.dnn.ClassificationModel.ClassificationModel',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.ClassificationModel.setEnableSoftmaxPostProcessing',
    'ClassificationModel',
    [],
    [['bool', 'enable', '', []]],
    'ClassificationModel']
ok: FUNC <ClassificationModel cv.dnn.ClassificationModel.setEnableSoftmaxPostProcessing [ARG bool enable=]>

--- Incoming ---
[   'cv.dnn.ClassificationModel.getEnableSoftmaxPostProcessing',
    'bool',
    ['/C'],
    [],
    'bool']
ok: FUNC <bool cv.dnn.ClassificationModel.getEnableSoftmaxPostProcessing []>

--- Incoming ---
[   'cv.dnn.ClassificationModel.classify',
    'void',
    [],
    [   ['Mat', 'frame', '', []],
        ['int', 'classId', '', ['/O', '/Ref']],
        ['float', 'conf', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.ClassificationModel.classify [ARG Mat frame=, ARG int classId=, ARG float conf=]>

--- Incoming ---
['class cv.dnn.KeypointsModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.KeypointsModel : Model, name: KeypointsModel, base: Model

--- Incoming ---
[   'cv.dnn.KeypointsModel.KeypointsModel',
    '',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   'cv.dnn.KeypointsModel.KeypointsModel',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.KeypointsModel.estimate',
    'vector_Point2f',
    [],
    [['Mat', 'frame', '', []], ['float', 'thresh', '0.5', []]],
    'std::vector<Point2f>']
ok: FUNC <vector_Point2f cv.dnn.KeypointsModel.estimate [ARG Mat frame=, ARG float thresh=0.5]>

--- Incoming ---
['class cv.dnn.SegmentationModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.SegmentationModel : Model, name: SegmentationModel, base: Model

--- Incoming ---
[   'cv.dnn.SegmentationModel.SegmentationModel',
    '',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   'cv.dnn.SegmentationModel.SegmentationModel',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.SegmentationModel.segment',
    'void',
    [],
    [['Mat', 'frame', '', []], ['Mat', 'mask', '', ['/O']]],
    'void']
ok: FUNC <void cv.dnn.SegmentationModel.segment [ARG Mat frame=, ARG Mat mask=]>

--- Incoming ---
['class cv.dnn.DetectionModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.DetectionModel : Model, name: DetectionModel, base: Model

--- Incoming ---
[   'cv.dnn.DetectionModel.DetectionModel',
    '',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DetectionModel.DetectionModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   'cv.dnn.DetectionModel.DetectionModel',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DetectionModel.DetectionModel [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.DetectionModel.setNmsAcrossClasses',
    'DetectionModel',
    [],
    [['bool', 'value', '', []]],
    'DetectionModel']
ok: FUNC <DetectionModel cv.dnn.DetectionModel.setNmsAcrossClasses [ARG bool value=]>

--- Incoming ---
['cv.dnn.DetectionModel.getNmsAcrossClasses', 'bool', [], [], 'bool']
ok: FUNC <bool cv.dnn.DetectionModel.getNmsAcrossClasses []>

--- Incoming ---
[   'cv.dnn.DetectionModel.detect',
    'void',
    [],
    [   ['Mat', 'frame', '', []],
        ['vector_int', 'classIds', '', ['/O', '/Ref']],
        ['vector_float', 'confidences', '', ['/O', '/Ref']],
        ['vector_Rect', 'boxes', '', ['/O', '/Ref']],
        ['float', 'confThreshold', '0.5f', []],
        ['float', 'nmsThreshold', '0.0f', []]],
    'void']
ok: FUNC <void cv.dnn.DetectionModel.detect [ARG Mat frame=, ARG vector_int classIds=, ARG vector_float confidences=, ARG vector_Rect boxes=, ARG float confThreshold=0.5f, ARG float nmsThreshold=0.0f]>

--- Incoming ---
['class cv.dnn.TextRecognitionModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.TextRecognitionModel : Model, name: TextRecognitionModel, base: Model

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.TextRecognitionModel',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextRecognitionModel.TextRecognitionModel [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.TextRecognitionModel',
    '',
    [],
    [   ['string', 'model', '', ['/C', '/Ref']],
        ['string', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextRecognitionModel.TextRecognitionModel [ARG string model=, ARG string config=""]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.setDecodeType',
    'TextRecognitionModel',
    [],
    [['string', 'decodeType', '', ['/C', '/Ref']]],
    'TextRecognitionModel']
ok: FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setDecodeType [ARG string decodeType=]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.getDecodeType',
    'string',
    ['/C'],
    [],
    'std::string']
ok: FUNC <string cv.dnn.TextRecognitionModel.getDecodeType []>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch',
    'TextRecognitionModel',
    [],
    [['int', 'beamSize', '', []], ['int', 'vocPruneSize', '0', []]],
    'TextRecognitionModel']
ok: FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch [ARG int beamSize=, ARG int vocPruneSize=0]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.setVocabulary',
    'TextRecognitionModel',
    [],
    [['vector_string', 'vocabulary', '', ['/C', '/Ref']]],
    'TextRecognitionModel']
ok: FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setVocabulary [ARG vector_string vocabulary=]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.getVocabulary',
    'vector_string',
    ['/C'],
    [],
    'std::vector<std::string>']
ok: FUNC <vector_string cv.dnn.TextRecognitionModel.getVocabulary []>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.recognize',
    'string',
    ['/C'],
    [['Mat', 'frame', '', []]],
    'std::string']
ok: FUNC <string cv.dnn.TextRecognitionModel.recognize [ARG Mat frame=]>

--- Incoming ---
[   'cv.dnn.TextRecognitionModel.recognize',
    'void',
    ['/C'],
    [   ['Mat', 'frame', '', []],
        ['vector_Mat', 'roiRects', '', []],
        ['vector_string', 'results', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.TextRecognitionModel.recognize [ARG Mat frame=, ARG vector_Mat roiRects=, ARG vector_string results=]>

--- Incoming ---
['class cv.dnn.TextDetectionModel', ': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.TextDetectionModel : Model, name: TextDetectionModel, base: Model

--- Incoming ---
[   'cv.dnn.TextDetectionModel.detect',
    'void',
    ['/C'],
    [   ['Mat', 'frame', '', []],
        ['vector_vector_Point', 'detections', '', ['/O', '/Ref']],
        ['vector_float', 'confidences', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.TextDetectionModel.detect [ARG Mat frame=, ARG vector_vector_Point detections=, ARG vector_float confidences=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel.detect',
    'void',
    ['/C'],
    [   ['Mat', 'frame', '', []],
        ['vector_vector_Point', 'detections', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.TextDetectionModel.detect [ARG Mat frame=, ARG vector_vector_Point detections=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel.detectTextRectangles',
    'void',
    ['/C'],
    [   ['Mat', 'frame', '', []],
        ['vector_RotatedRect', 'detections', '', ['/O', '/Ref']],
        ['vector_float', 'confidences', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.TextDetectionModel.detectTextRectangles [ARG Mat frame=, ARG vector_RotatedRect detections=, ARG vector_float confidences=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel.detectTextRectangles',
    'void',
    ['/C'],
    [   ['Mat', 'frame', '', []],
        ['vector_RotatedRect', 'detections', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.dnn.TextDetectionModel.detectTextRectangles [ARG Mat frame=, ARG vector_RotatedRect detections=]>

--- Incoming ---
[   'class cv.dnn.TextDetectionModel_EAST',
    ': cv::dnn::TextDetectionModel',
    ['/Simple'],
    [],
    None]
ok: class CLASS cv.dnn::.TextDetectionModel_EAST : TextDetectionModel, name: TextDetectionModel_EAST, base: TextDetectionModel

--- Incoming ---
[   'cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST',
    '',
    [],
    [   ['string', 'model', '', ['/C', '/Ref']],
        ['string', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST [ARG string model=, ARG string config=""]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_EAST.setConfidenceThreshold',
    'TextDetectionModel_EAST',
    [],
    [['float', 'confThreshold', '', []]],
    'TextDetectionModel_EAST']
ok: FUNC <TextDetectionModel_EAST cv.dnn.TextDetectionModel_EAST.setConfidenceThreshold [ARG float confThreshold=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_EAST.getConfidenceThreshold',
    'float',
    ['/C'],
    [],
    'float']
ok: FUNC <float cv.dnn.TextDetectionModel_EAST.getConfidenceThreshold []>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_EAST.setNMSThreshold',
    'TextDetectionModel_EAST',
    [],
    [['float', 'nmsThreshold', '', []]],
    'TextDetectionModel_EAST']
ok: FUNC <TextDetectionModel_EAST cv.dnn.TextDetectionModel_EAST.setNMSThreshold [ARG float nmsThreshold=]>

--- Incoming ---
['cv.dnn.TextDetectionModel_EAST.getNMSThreshold', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.dnn.TextDetectionModel_EAST.getNMSThreshold []>

--- Incoming ---
[   'class cv.dnn.TextDetectionModel_DB',
    ': cv::dnn::TextDetectionModel',
    ['/Simple'],
    [],
    None]
ok: class CLASS cv.dnn::.TextDetectionModel_DB : TextDetectionModel, name: TextDetectionModel_DB, base: TextDetectionModel

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB',
    '',
    [],
    [['Net', 'network', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB [ARG Net network=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB',
    '',
    [],
    [   ['string', 'model', '', ['/C', '/Ref']],
        ['string', 'config', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB [ARG string model=, ARG string config=""]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.setBinaryThreshold',
    'TextDetectionModel_DB',
    [],
    [['float', 'binaryThreshold', '', []]],
    'TextDetectionModel_DB']
ok: FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setBinaryThreshold [ARG float binaryThreshold=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.getBinaryThreshold',
    'float',
    ['/C'],
    [],
    'float']
ok: FUNC <float cv.dnn.TextDetectionModel_DB.getBinaryThreshold []>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.setPolygonThreshold',
    'TextDetectionModel_DB',
    [],
    [['float', 'polygonThreshold', '', []]],
    'TextDetectionModel_DB']
ok: FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setPolygonThreshold [ARG float polygonThreshold=]>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.getPolygonThreshold',
    'float',
    ['/C'],
    [],
    'float']
ok: FUNC <float cv.dnn.TextDetectionModel_DB.getPolygonThreshold []>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.setUnclipRatio',
    'TextDetectionModel_DB',
    [],
    [['double', 'unclipRatio', '', []]],
    'TextDetectionModel_DB']
ok: FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setUnclipRatio [ARG double unclipRatio=]>

--- Incoming ---
['cv.dnn.TextDetectionModel_DB.getUnclipRatio', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.dnn.TextDetectionModel_DB.getUnclipRatio []>

--- Incoming ---
[   'cv.dnn.TextDetectionModel_DB.setMaxCandidates',
    'TextDetectionModel_DB',
    [],
    [['int', 'maxCandidates', '', []]],
    'TextDetectionModel_DB']
ok: FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setMaxCandidates [ARG int maxCandidates=]>

--- Incoming ---
['cv.dnn.TextDetectionModel_DB.getMaxCandidates', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.dnn.TextDetectionModel_DB.getMaxCandidates []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/dict.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS', 'cv.dnn.accessor']

--- Incoming ---
['struct cv.dnn.DictValue', '', [], [], None]
ok: class CLASS cv.dnn::.DictValue : , name: DictValue, base: 

--- Incoming ---
['cv.dnn.DictValue.DictValue', '', [], [['int', 'i', '', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>

--- Incoming ---
['cv.dnn.DictValue.DictValue', '', [], [['double', 'p', '', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>

--- Incoming ---
[   'cv.dnn.DictValue.DictValue',
    '',
    [],
    [['String', 's', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>

--- Incoming ---
['cv.dnn.DictValue.isInt', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.dnn.DictValue.isInt []>

--- Incoming ---
['cv.dnn.DictValue.isString', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.dnn.DictValue.isString []>

--- Incoming ---
['cv.dnn.DictValue.isReal', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.dnn.DictValue.isReal []>

--- Incoming ---
[   'cv.dnn.DictValue.getIntValue',
    'int',
    ['/C'],
    [['int', 'idx', '-1', []]],
    'int']
ok: FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>

--- Incoming ---
[   'cv.dnn.DictValue.getRealValue',
    'double',
    ['/C'],
    [['int', 'idx', '-1', []]],
    'double']
ok: FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>

--- Incoming ---
[   'cv.dnn.DictValue.getStringValue',
    'String',
    ['/C'],
    [['int', 'idx', '-1', []]],
    'String']
ok: FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/utils/debug_utils.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS', 'cv.dnn.accessor']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/utils/debug_utils.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp =====
Namespaces: ['cv', 'cv.dnn', 'cv.dnn.<unnamed>', 'cv.dnn.CV__DNN_INLINE_NS', 'cv.dnn.accessor']

--- Incoming ---
['cv.dnn.getInferenceEngineBackendType', 'String', [], [], 'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineBackendType []>

--- Incoming ---
[   'cv.dnn.setInferenceEngineBackendType',
    'String',
    [],
    [['String', 'newBackendType', '', ['/C', '/Ref']]],
    'cv::String']
ok: FUNC <String cv.dnn..setInferenceEngineBackendType [ARG String newBackendType=]>

--- Incoming ---
['cv.dnn.resetMyriadDevice', 'void', [], [], 'void']
ok: FUNC <void cv.dnn..resetMyriadDevice []>

--- Incoming ---
['cv.dnn.getInferenceEngineVPUType', 'String', [], [], 'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineVPUType []>

--- Incoming ---
['cv.dnn.getInferenceEngineCPUType', 'String', [], [], 'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineCPUType []>

--- Incoming ---
['cv.dnn.releaseHDDLPlugin', 'void', [], [], 'void']
ok: FUNC <void cv.dnn..releaseHDDLPlugin []>


===== Generating... =====
CLASS cv::.Dnn : 
[CONST DNN_BACKEND_DEFAULT=0, CONST DNN_BACKEND_HALIDE=0+1, CONST DNN_BACKEND_INFERENCE_ENGINE=0+2, CONST DNN_BACKEND_OPENCV=0+3, CONST DNN_BACKEND_VKCOM=0+4, CONST DNN_BACKEND_CUDA=0+5, CONST DNN_BACKEND_WEBNN=0+6, CONST DNN_BACKEND_TIMVX=0+7, CONST DNN_BACKEND_CANN=0+8]
[CONST SoftNMSMethod_SOFTNMS_LINEAR=1, CONST SoftNMSMethod_SOFTNMS_GAUSSIAN=2]
[CONST DNN_TARGET_CPU=0, CONST DNN_TARGET_OPENCL=0+1, CONST DNN_TARGET_OPENCL_FP16=0+2, CONST DNN_TARGET_MYRIAD=0+3, CONST DNN_TARGET_VULKAN=0+4, CONST DNN_TARGET_FPGA=0+5, CONST DNN_TARGET_CUDA=0+6, CONST DNN_TARGET_CUDA_FP16=0+7, CONST DNN_TARGET_HDDL=0+8, CONST DNN_TARGET_NPU=0+9]
FUNC <vector_Target cv.dnn..getAvailableTargets [ARG dnn_Backend be=]>
java: List<Integer> getAvailableTargets(int be)
FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>
java: Net readNetFromDarknet(String cfgFile, String darknetModel)
java: Net readNetFromDarknet(String cfgFile)
FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromDarknet(MatOfByte bufferCfg, MatOfByte bufferModel)
java: Net readNetFromDarknet(MatOfByte bufferCfg)
FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>
java: Net readNetFromCaffe(String prototxt, String caffeModel)
java: Net readNetFromCaffe(String prototxt)
FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromCaffe(MatOfByte bufferProto, MatOfByte bufferModel)
java: Net readNetFromCaffe(MatOfByte bufferProto)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>
java: Net readNetFromTensorflow(String model, String config)
java: Net readNetFromTensorflow(String model)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNetFromTensorflow(MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNetFromTensorflow(MatOfByte bufferModel)
FUNC <Net cv.dnn..readNetFromTFLite [ARG String model=]>
java: Net readNetFromTFLite(String model)
FUNC <Net cv.dnn..readNetFromTFLite [ARG vector_uchar bufferModel=]>
java: Net readNetFromTFLite(MatOfByte bufferModel)
FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>
java: Net readNetFromTorch(String model, boolean isBinary, boolean evaluate)
java: Net readNetFromTorch(String model, boolean isBinary)
java: Net readNetFromTorch(String model)
FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>
java: Net readNet(String model, String config, String framework)
java: Net readNet(String model, String config)
java: Net readNet(String model)
FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNet(String framework, MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNet(String framework, MatOfByte bufferModel)
FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>
java: Mat readTorchBlob(String filename, boolean isBinary)
java: Mat readTorchBlob(String filename)
FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readNetFromModelOptimizer(String xml, String bin)
FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>
java: Net readNetFromModelOptimizer(MatOfByte bufferModelConfig, MatOfByte bufferWeights)
FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>
java: Net readNetFromONNX(String onnxFile)
FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>
java: Net readNetFromONNX(MatOfByte buffer)
FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>
java: Mat readTensorFromONNX(String path)
FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImage(Mat image, double scalefactor, Size size)
java: Mat blobFromImage(Mat image, double scalefactor)
java: Mat blobFromImage(Mat image)
FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size)
java: Mat blobFromImages(List<Mat> images, double scalefactor)
java: Mat blobFromImages(List<Mat> images)
FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>
java: void imagesFromBlob(Mat blob_, List<Mat> images_)
FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>
java: void shrinkCaffeModel(String src, String dst, List<String> layersTypes)
java: void shrinkCaffeModel(String src, String dst)
FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>
java: void writeTextGraph(String model, String output)
FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..NMSBoxesBatched [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG vector_int class_ids=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxesBatched(MatOfRect2d bboxes, MatOfFloat scores, MatOfInt class_ids, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxesBatched(MatOfRect2d bboxes, MatOfFloat scores, MatOfInt class_ids, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxesBatched(MatOfRect2d bboxes, MatOfFloat scores, MatOfInt class_ids, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..softNMSBoxes [ARG vector_Rect bboxes=, ARG vector_float scores=, ARG vector_float updated_scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG size_t top_k=0, ARG float sigma=0.5, ARG SoftNMSMethod method=SoftNMSMethod::SOFTNMS_GAUSSIAN]>
java: void softNMSBoxes(MatOfRect bboxes, MatOfFloat scores, MatOfFloat updated_scores, float score_threshold, float nms_threshold, MatOfInt indices, long top_k, float sigma)
java: void softNMSBoxes(MatOfRect bboxes, MatOfFloat scores, MatOfFloat updated_scores, float score_threshold, float nms_threshold, MatOfInt indices, long top_k, float sigma)
java: void softNMSBoxes(MatOfRect bboxes, MatOfFloat scores, MatOfFloat updated_scores, float score_threshold, float nms_threshold, MatOfInt indices, long top_k)
java: void softNMSBoxes(MatOfRect bboxes, MatOfFloat scores, MatOfFloat updated_scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <String cv.dnn..getInferenceEngineBackendType []>
java: String getInferenceEngineBackendType()
FUNC <String cv.dnn..setInferenceEngineBackendType [ARG String newBackendType=]>
java: String setInferenceEngineBackendType(String newBackendType)
FUNC <void cv.dnn..resetMyriadDevice []>
java: void resetMyriadDevice()
FUNC <String cv.dnn..getInferenceEngineVPUType []>
java: String getInferenceEngineVPUType()
FUNC <String cv.dnn..getInferenceEngineCPUType []>
java: String getInferenceEngineCPUType()
FUNC <void cv.dnn..releaseHDDLPlugin []>
java: void releaseHDDLPlugin()
CLASS cv.dnn::.ClassificationModel : Model
FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG String model=, ARG String config=""]>
java:  ClassificationModel(String model, String config)
java:  ClassificationModel(String model)
FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG Net network=]>
java:  ClassificationModel(Net network)
FUNC <ClassificationModel cv.dnn.ClassificationModel.setEnableSoftmaxPostProcessing [ARG bool enable=]>
java: ClassificationModel setEnableSoftmaxPostProcessing(boolean enable)
FUNC <bool cv.dnn.ClassificationModel.getEnableSoftmaxPostProcessing []>
java: boolean getEnableSoftmaxPostProcessing()
FUNC <void cv.dnn.ClassificationModel.classify [ARG Mat frame=, ARG int classId=, ARG float conf=]>
java: void classify(Mat frame, int[] classId, float[] conf)
CLASS cv.dnn::.DetectionModel : Model
FUNC < cv.dnn.DetectionModel.DetectionModel [ARG String model=, ARG String config=""]>
java:  DetectionModel(String model, String config)
java:  DetectionModel(String model)
FUNC < cv.dnn.DetectionModel.DetectionModel [ARG Net network=]>
java:  DetectionModel(Net network)
FUNC <DetectionModel cv.dnn.DetectionModel.setNmsAcrossClasses [ARG bool value=]>
java: DetectionModel setNmsAcrossClasses(boolean value)
FUNC <bool cv.dnn.DetectionModel.getNmsAcrossClasses []>
java: boolean getNmsAcrossClasses()
FUNC <void cv.dnn.DetectionModel.detect [ARG Mat frame=, ARG vector_int classIds=, ARG vector_float confidences=, ARG vector_Rect boxes=, ARG float confThreshold=0.5f, ARG float nmsThreshold=0.0f]>
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes, float confThreshold, float nmsThreshold)
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes, float confThreshold)
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes)
CLASS cv.dnn::.DictValue : 
FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>
java:  DictValue(int i)
FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>
java:  DictValue(double p)
FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>
java:  DictValue(String s)
FUNC <bool cv.dnn.DictValue.isInt []>
java: boolean isInt()
FUNC <bool cv.dnn.DictValue.isString []>
java: boolean isString()
FUNC <bool cv.dnn.DictValue.isReal []>
java: boolean isReal()
FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>
java: int getIntValue(int idx)
java: int getIntValue()
FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>
java: double getRealValue(int idx)
java: double getRealValue()
FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>
java: String getStringValue(int idx)
java: String getStringValue()
CLASS cv.dnn::.KeypointsModel : Model
FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG String model=, ARG String config=""]>
java:  KeypointsModel(String model, String config)
java:  KeypointsModel(String model)
FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG Net network=]>
java:  KeypointsModel(Net network)
FUNC <vector_Point2f cv.dnn.KeypointsModel.estimate [ARG Mat frame=, ARG float thresh=0.5]>
java: MatOfPoint2f estimate(Mat frame, float thresh)
java: MatOfPoint2f estimate(Mat frame)
CLASS cv.dnn::.Layer : Algorithm
FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>
java: void finalize(List<Mat> inputs, List<Mat> outputs)
FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>
java: void run(List<Mat> inputs, List<Mat> outputs, List<Mat> internals)
FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>
java: int outputNameToIndex(String outputName)
FUNC <vector_Mat cv.dnn.Layer.get_blobs []>
java: List<Mat> get_blobs()
FUNC <void cv.dnn.Layer.set_blobs [ARG vector_Mat blobs=]>
java: void set_blobs(List<Mat> blobs)
FUNC <String cv.dnn.Layer.get_name []>
java: String get_name()
FUNC <String cv.dnn.Layer.get_type []>
java: String get_type()
FUNC <int cv.dnn.Layer.get_preferableTarget []>
java: int get_preferableTarget()
CLASS cv.dnn::.Model : 
FUNC < cv.dnn.Model.Model [ARG String model=, ARG String config=""]>
java:  Model(String model, String config)
java:  Model(String model)
FUNC < cv.dnn.Model.Model [ARG Net network=]>
java:  Model(Net network)
FUNC <Model cv.dnn.Model.setInputSize [ARG Size size=]>
java: Model setInputSize(Size size)
FUNC <Model cv.dnn.Model.setInputSize [ARG int width=, ARG int height=]>
java: Model setInputSize(int width, int height)
FUNC <Model cv.dnn.Model.setInputMean [ARG Scalar mean=]>
java: Model setInputMean(Scalar mean)
FUNC <Model cv.dnn.Model.setInputScale [ARG double scale=]>
java: Model setInputScale(double scale)
FUNC <Model cv.dnn.Model.setInputCrop [ARG bool crop=]>
java: Model setInputCrop(boolean crop)
FUNC <Model cv.dnn.Model.setInputSwapRB [ARG bool swapRB=]>
java: Model setInputSwapRB(boolean swapRB)
FUNC <void cv.dnn.Model.setInputParams [ARG double scale=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false]>
java: void setInputParams(double scale, Size size, Scalar mean, boolean swapRB, boolean crop)
java: void setInputParams(double scale, Size size, Scalar mean, boolean swapRB)
java: void setInputParams(double scale, Size size, Scalar mean)
java: void setInputParams(double scale, Size size)
java: void setInputParams(double scale)
java: void setInputParams()
FUNC <void cv.dnn.Model.predict [ARG Mat frame=, ARG vector_Mat outs=]>
java: void predict(Mat frame, List<Mat> outs)
FUNC <Model cv.dnn.Model.setPreferableBackend [ARG dnn_Backend backendId=]>
java: Model setPreferableBackend(int backendId)
FUNC <Model cv.dnn.Model.setPreferableTarget [ARG dnn_Target targetId=]>
java: Model setPreferableTarget(int targetId)
CLASS cv.dnn::.Net : 
FUNC < cv.dnn.Net.Net []>
java:  Net()
FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readFromModelOptimizer(String xml, String bin)
FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>
java: Net readFromModelOptimizer(MatOfByte bufferModelConfig, MatOfByte bufferWeights)
FUNC <bool cv.dnn.Net.empty []>
java: boolean empty()
FUNC <String cv.dnn.Net.dump []>
java: String dump()
FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>
java: void dumpToFile(String path)
FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>
java: int getLayerId(String layer)
FUNC <vector_String cv.dnn.Net.getLayerNames []>
java: List<String> getLayerNames()
FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG int layerId=]>
java: Layer getLayer(int layerId)
FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG String layerName=]>
java: Layer getLayer(String layerName)
FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>
java: Layer getLayer(DictValue layerId)
FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>
java: void connect(String outPin, String inpPin)
FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>
java: void setInputsNames(List<String> inputBlobNames)
FUNC <void cv.dnn.Net.setInputShape [ARG String inputName=, ARG MatShape shape=]>
java: void setInputShape(String inputName, MatOfInt shape)
FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>
java: Mat forward(String outputName)
java: Mat forward()
FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>
SKIP:AsyncArray cv::dnn::Net::forwardAsync(String outputName = String())	 due to RET type AsyncArray
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>
java: void forward(List<Mat> outputBlobs, String outputName)
java: void forward(List<Mat> outputBlobs)
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
java: void forward(List<Mat> outputBlobs, List<String> outBlobNames)
FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
SKIP:void cv::dnn::Net::forward(vector_vector_Mat& outputBlobs, vector_String outBlobNames)	 due to ARG type vector_vector_Mat/O
FUNC <Net cv.dnn.Net.quantize [ARG vector_Mat calibData=, ARG int inputsDtype=, ARG int outputsDtype=, ARG bool perChannel=true]>
java: Net quantize(List<Mat> calibData, int inputsDtype, int outputsDtype, boolean perChannel)
java: Net quantize(List<Mat> calibData, int inputsDtype, int outputsDtype)
FUNC <void cv.dnn.Net.getInputDetails [ARG vector_float scales=, ARG vector_int zeropoints=]>
java: void getInputDetails(MatOfFloat scales, MatOfInt zeropoints)
FUNC <void cv.dnn.Net.getOutputDetails [ARG vector_float scales=, ARG vector_int zeropoints=]>
java: void getOutputDetails(MatOfFloat scales, MatOfInt zeropoints)
FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>
java: void setHalideScheduler(String scheduler)
FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>
java: void setPreferableBackend(int backendId)
FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>
java: void setPreferableTarget(int targetId)
FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>
java: void setInput(Mat blob, String name, double scalefactor, Scalar mean)
java: void setInput(Mat blob, String name, double scalefactor)
java: void setInput(Mat blob, String name)
java: void setInput(Mat blob)
FUNC <void cv.dnn.Net.setParam [ARG int layer=, ARG int numParam=, ARG Mat blob=]>
java: void setParam(int layer, int numParam, Mat blob)
FUNC <void cv.dnn.Net.setParam [ARG String layerName=, ARG int numParam=, ARG Mat blob=]>
java: void setParam(String layerName, int numParam, Mat blob)
FUNC <Mat cv.dnn.Net.getParam [ARG int layer=, ARG int numParam=0]>
java: Mat getParam(int layer, int numParam)
java: Mat getParam(int layer)
FUNC <Mat cv.dnn.Net.getParam [ARG String layerName=, ARG int numParam=0]>
java: Mat getParam(String layerName, int numParam)
java: Mat getParam(String layerName)
FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>
java: MatOfInt getUnconnectedOutLayers()
FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>
java: List<String> getUnconnectedOutLayersNames()
FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(vector_MatShape netInputShapes, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(MatShape netInputShape, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>
java: long getFLOPS(MatOfInt netInputShape)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(int layerId, List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>
java: long getFLOPS(int layerId, MatOfInt netInputShape)
FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>
java: void getLayerTypes(List<String> layersTypes)
FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>
java: int getLayersCount(String layerType)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, List<MatOfInt> netInputShapes, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>
java: void enableFusion(boolean fusion)
FUNC <void cv.dnn.Net.enableWinograd [ARG bool useWinograd=]>
java: void enableWinograd(boolean useWinograd)
FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>
java: long getPerfProfile(MatOfDouble timings)
CLASS cv.dnn::.SegmentationModel : Model
FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG String model=, ARG String config=""]>
java:  SegmentationModel(String model, String config)
java:  SegmentationModel(String model)
FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG Net network=]>
java:  SegmentationModel(Net network)
FUNC <void cv.dnn.SegmentationModel.segment [ARG Mat frame=, ARG Mat mask=]>
java: void segment(Mat frame, Mat mask)
CLASS cv.dnn::.TextDetectionModel : Model
FUNC <void cv.dnn.TextDetectionModel.detect [ARG Mat frame=, ARG vector_vector_Point detections=, ARG vector_float confidences=]>
java: void detect(Mat frame, List<MatOfPoint> detections, MatOfFloat confidences)
FUNC <void cv.dnn.TextDetectionModel.detect [ARG Mat frame=, ARG vector_vector_Point detections=]>
java: void detect(Mat frame, List<MatOfPoint> detections)
FUNC <void cv.dnn.TextDetectionModel.detectTextRectangles [ARG Mat frame=, ARG vector_RotatedRect detections=, ARG vector_float confidences=]>
java: void detectTextRectangles(Mat frame, MatOfRotatedRect detections, MatOfFloat confidences)
FUNC <void cv.dnn.TextDetectionModel.detectTextRectangles [ARG Mat frame=, ARG vector_RotatedRect detections=]>
java: void detectTextRectangles(Mat frame, MatOfRotatedRect detections)
CLASS cv.dnn::.TextDetectionModel_DB : TextDetectionModel
FUNC < cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB [ARG Net network=]>
java:  TextDetectionModel_DB(Net network)
FUNC < cv.dnn.TextDetectionModel_DB.TextDetectionModel_DB [ARG string model=, ARG string config=""]>
java:  TextDetectionModel_DB(String model, String config)
java:  TextDetectionModel_DB(String model)
FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setBinaryThreshold [ARG float binaryThreshold=]>
java: TextDetectionModel_DB setBinaryThreshold(float binaryThreshold)
FUNC <float cv.dnn.TextDetectionModel_DB.getBinaryThreshold []>
java: float getBinaryThreshold()
FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setPolygonThreshold [ARG float polygonThreshold=]>
java: TextDetectionModel_DB setPolygonThreshold(float polygonThreshold)
FUNC <float cv.dnn.TextDetectionModel_DB.getPolygonThreshold []>
java: float getPolygonThreshold()
FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setUnclipRatio [ARG double unclipRatio=]>
java: TextDetectionModel_DB setUnclipRatio(double unclipRatio)
FUNC <double cv.dnn.TextDetectionModel_DB.getUnclipRatio []>
java: double getUnclipRatio()
FUNC <TextDetectionModel_DB cv.dnn.TextDetectionModel_DB.setMaxCandidates [ARG int maxCandidates=]>
java: TextDetectionModel_DB setMaxCandidates(int maxCandidates)
FUNC <int cv.dnn.TextDetectionModel_DB.getMaxCandidates []>
java: int getMaxCandidates()
CLASS cv.dnn::.TextDetectionModel_EAST : TextDetectionModel
FUNC < cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST [ARG Net network=]>
java:  TextDetectionModel_EAST(Net network)
FUNC < cv.dnn.TextDetectionModel_EAST.TextDetectionModel_EAST [ARG string model=, ARG string config=""]>
java:  TextDetectionModel_EAST(String model, String config)
java:  TextDetectionModel_EAST(String model)
FUNC <TextDetectionModel_EAST cv.dnn.TextDetectionModel_EAST.setConfidenceThreshold [ARG float confThreshold=]>
java: TextDetectionModel_EAST setConfidenceThreshold(float confThreshold)
FUNC <float cv.dnn.TextDetectionModel_EAST.getConfidenceThreshold []>
java: float getConfidenceThreshold()
FUNC <TextDetectionModel_EAST cv.dnn.TextDetectionModel_EAST.setNMSThreshold [ARG float nmsThreshold=]>
java: TextDetectionModel_EAST setNMSThreshold(float nmsThreshold)
FUNC <float cv.dnn.TextDetectionModel_EAST.getNMSThreshold []>
java: float getNMSThreshold()
CLASS cv.dnn::.TextRecognitionModel : Model
FUNC < cv.dnn.TextRecognitionModel.TextRecognitionModel [ARG Net network=]>
java:  TextRecognitionModel(Net network)
FUNC < cv.dnn.TextRecognitionModel.TextRecognitionModel [ARG string model=, ARG string config=""]>
java:  TextRecognitionModel(String model, String config)
java:  TextRecognitionModel(String model)
FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setDecodeType [ARG string decodeType=]>
java: TextRecognitionModel setDecodeType(String decodeType)
FUNC <string cv.dnn.TextRecognitionModel.getDecodeType []>
java: String getDecodeType()
FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setDecodeOptsCTCPrefixBeamSearch [ARG int beamSize=, ARG int vocPruneSize=0]>
java: TextRecognitionModel setDecodeOptsCTCPrefixBeamSearch(int beamSize, int vocPruneSize)
java: TextRecognitionModel setDecodeOptsCTCPrefixBeamSearch(int beamSize)
FUNC <TextRecognitionModel cv.dnn.TextRecognitionModel.setVocabulary [ARG vector_string vocabulary=]>
java: TextRecognitionModel setVocabulary(List<String> vocabulary)
FUNC <vector_string cv.dnn.TextRecognitionModel.getVocabulary []>
java: List<String> getVocabulary()
FUNC <string cv.dnn.TextRecognitionModel.recognize [ARG Mat frame=]>
java: String recognize(Mat frame)
FUNC <void cv.dnn.TextRecognitionModel.recognize [ARG Mat frame=, ARG vector_Mat roiRects=, ARG vector_string results=]>
java: void recognize(Mat frame, List<Mat> roiRects, List<String> results)

=== MODULE: features2d (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/features2d) ===


Files (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/features2d/include/opencv2/features2d.hpp']

Common headers (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/features2d/misc/java/src/cpp/features2d_converters.hpp']
ok: class CLASS cv::.Features2d : , name: Features2d, base: 

===== Common header : /home/derek/Documents/thesis-ecj/ecj/opencv/modules/features2d/misc/java/src/cpp/features2d_converters.hpp =====


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/features2d/include/opencv2/features2d.hpp =====
Namespaces: ['cv']

--- Incoming ---
[   'class cv.Feature2D',
    ': cv::Algorithm, cv::class, cv::Feature2D, cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv::.Feature2D : Algorithm, name: Feature2D, base: Algorithm

--- Incoming ---
[   'cv.Feature2D.detect',
    'void',
    ['/V'],
    [   ['Mat', 'image', '', []],
        ['vector_KeyPoint', 'keypoints', '', ['/O', '/Ref']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.Feature2D.detect',
    'void',
    ['/V'],
    [   ['vector_Mat', 'images', '', []],
        ['vector_vector_KeyPoint', 'keypoints', '', ['/O', '/Ref']],
        ['vector_Mat', 'masks', 'vector_Mat()', []]],
    'void']
ok: FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   'cv.Feature2D.compute',
    'void',
    ['/V'],
    [   ['Mat', 'image', '', []],
        ['vector_KeyPoint', 'keypoints', '', ['/O', '/IO', '/Ref']],
        ['Mat', 'descriptors', '', ['/O']]],
    'void']
ok: FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>

--- Incoming ---
[   'cv.Feature2D.compute',
    'void',
    ['/V'],
    [   ['vector_Mat', 'images', '', []],
        ['vector_vector_KeyPoint', 'keypoints', '', ['/O', '/IO', '/Ref']],
        ['vector_Mat', 'descriptors', '', ['/O']]],
    'void']
ok: FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>

--- Incoming ---
[   'cv.Feature2D.detectAndCompute',
    'void',
    ['/V'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'mask', '', []],
        ['vector_KeyPoint', 'keypoints', '', ['/O', '/Ref']],
        ['Mat', 'descriptors', '', ['/O']],
        ['bool', 'useProvidedKeypoints', 'false', []]],
    'void']
ok: FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>

--- Incoming ---
['cv.Feature2D.descriptorSize', 'int', ['/C', '/V'], [], 'int']
ok: FUNC <int cv.Feature2D.descriptorSize []>

--- Incoming ---
['cv.Feature2D.descriptorType', 'int', ['/C', '/V'], [], 'int']
ok: FUNC <int cv.Feature2D.descriptorType []>

--- Incoming ---
['cv.Feature2D.defaultNorm', 'int', ['/C', '/V'], [], 'int']
ok: FUNC <int cv.Feature2D.defaultNorm []>

--- Incoming ---
[   'cv.Feature2D.write',
    'void',
    ['/C'],
    [['String', 'fileName', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Feature2D.write [ARG String fileName=]>

--- Incoming ---
[   'cv.Feature2D.read',
    'void',
    [],
    [['String', 'fileName', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Feature2D.read [ARG String fileName=]>

--- Incoming ---
[   'cv.Feature2D.read',
    'void',
    ['/V'],
    [['FileNode', 'arg1', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>

--- Incoming ---
['cv.Feature2D.empty', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.Feature2D.empty []>

--- Incoming ---
['cv.Feature2D.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.Feature2D.getDefaultName []>

--- Incoming ---
[   'cv.Feature2D.write',
    'void',
    ['/C'],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Feature2D.write [ARG FileStorage fs=, ARG String name=]>

--- Incoming ---
['class cv.AffineFeature', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AffineFeature : Feature2D, name: AffineFeature, base: Feature2D

--- Incoming ---
[   'cv.AffineFeature.create',
    'Ptr_AffineFeature',
    ['/S'],
    [   ['Ptr_Feature2D', 'backend', '', ['/C', '/Ref']],
        ['int', 'maxTilt', '5', []],
        ['int', 'minTilt', '0', []],
        ['float', 'tiltStep', '1.4142135623730951f', []],
        ['float', 'rotateStepBase', '72', []]],
    'Ptr<AffineFeature>']
ok: FUNC <Ptr_AffineFeature cv.AffineFeature.create [ARG Ptr_Feature2D backend=, ARG int maxTilt=5, ARG int minTilt=0, ARG float tiltStep=1.4142135623730951f, ARG float rotateStepBase=72]>

--- Incoming ---
[   'cv.AffineFeature.setViewParams',
    'void',
    ['/V', '/PV'],
    [   ['vector_float', 'tilts', '', ['/C', '/Ref']],
        ['vector_float', 'rolls', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.AffineFeature.setViewParams [ARG vector_float tilts=, ARG vector_float rolls=]>

--- Incoming ---
[   'cv.AffineFeature.getViewParams',
    'void',
    ['/C', '/V', '/PV'],
    [   ['vector_float', 'tilts', '', ['/Ref']],
        ['vector_float', 'rolls', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.AffineFeature.getViewParams [ARG vector_float tilts=, ARG vector_float rolls=]>

--- Incoming ---
['cv.AffineFeature.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.AffineFeature.getDefaultName []>

--- Incoming ---
['class cv.SIFT', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.SIFT : Feature2D, name: SIFT, base: Feature2D

--- Incoming ---
[   'cv.SIFT.create',
    'Ptr_SIFT',
    ['/S'],
    [   ['int', 'nfeatures', '0', []],
        ['int', 'nOctaveLayers', '3', []],
        ['double', 'contrastThreshold', '0.04', []],
        ['double', 'edgeThreshold', '10', []],
        ['double', 'sigma', '1.6', []],
        ['bool', 'enable_precise_upscale', 'false', []]],
    'Ptr<SIFT>']
ok: FUNC <Ptr_SIFT cv.SIFT.create [ARG int nfeatures=0, ARG int nOctaveLayers=3, ARG double contrastThreshold=0.04, ARG double edgeThreshold=10, ARG double sigma=1.6, ARG bool enable_precise_upscale=false]>

--- Incoming ---
[   'cv.SIFT.create',
    'Ptr_SIFT',
    ['/S'],
    [   ['int', 'nfeatures', '', []],
        ['int', 'nOctaveLayers', '', []],
        ['double', 'contrastThreshold', '', []],
        ['double', 'edgeThreshold', '', []],
        ['double', 'sigma', '', []],
        ['int', 'descriptorType', '', []],
        ['bool', 'enable_precise_upscale', 'false', []]],
    'Ptr<SIFT>']
ok: FUNC <Ptr_SIFT cv.SIFT.create [ARG int nfeatures=, ARG int nOctaveLayers=, ARG double contrastThreshold=, ARG double edgeThreshold=, ARG double sigma=, ARG int descriptorType=, ARG bool enable_precise_upscale=false]>

--- Incoming ---
['cv.SIFT.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.SIFT.getDefaultName []>

--- Incoming ---
[   'cv.SIFT.setNFeatures',
    'void',
    ['/V', '/PV'],
    [['int', 'maxFeatures', '', []]],
    'void']
ok: FUNC <void cv.SIFT.setNFeatures [ARG int maxFeatures=]>

--- Incoming ---
['cv.SIFT.getNFeatures', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.SIFT.getNFeatures []>

--- Incoming ---
[   'cv.SIFT.setNOctaveLayers',
    'void',
    ['/V', '/PV'],
    [['int', 'nOctaveLayers', '', []]],
    'void']
ok: FUNC <void cv.SIFT.setNOctaveLayers [ARG int nOctaveLayers=]>

--- Incoming ---
['cv.SIFT.getNOctaveLayers', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.SIFT.getNOctaveLayers []>

--- Incoming ---
[   'cv.SIFT.setContrastThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'contrastThreshold', '', []]],
    'void']
ok: FUNC <void cv.SIFT.setContrastThreshold [ARG double contrastThreshold=]>

--- Incoming ---
['cv.SIFT.getContrastThreshold', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.SIFT.getContrastThreshold []>

--- Incoming ---
[   'cv.SIFT.setEdgeThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'edgeThreshold', '', []]],
    'void']
ok: FUNC <void cv.SIFT.setEdgeThreshold [ARG double edgeThreshold=]>

--- Incoming ---
['cv.SIFT.getEdgeThreshold', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.SIFT.getEdgeThreshold []>

--- Incoming ---
[   'cv.SIFT.setSigma',
    'void',
    ['/V', '/PV'],
    [['double', 'sigma', '', []]],
    'void']
ok: FUNC <void cv.SIFT.setSigma [ARG double sigma=]>

--- Incoming ---
['cv.SIFT.getSigma', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.SIFT.getSigma []>

--- Incoming ---
['class cv.BRISK', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.BRISK : Feature2D, name: BRISK, base: Feature2D

--- Incoming ---
[   'cv.BRISK.create',
    'Ptr_BRISK',
    ['/S'],
    [   ['int', 'thresh', '30', []],
        ['int', 'octaves', '3', []],
        ['float', 'patternScale', '1.0f', []]],
    'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>

--- Incoming ---
[   'cv.BRISK.create',
    'Ptr_BRISK',
    ['/S'],
    [   ['vector_float', 'radiusList', '', ['/C', '/Ref']],
        ['vector_int', 'numberList', '', ['/C', '/Ref']],
        ['float', 'dMax', '5.85f', []],
        ['float', 'dMin', '8.2f', []],
        ['vector_int', 'indexChange', 'std::vector<int>()', ['/C', '/Ref']]],
    'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
[   'cv.BRISK.create',
    'Ptr_BRISK',
    ['/S'],
    [   ['int', 'thresh', '', []],
        ['int', 'octaves', '', []],
        ['vector_float', 'radiusList', '', ['/C', '/Ref']],
        ['vector_int', 'numberList', '', ['/C', '/Ref']],
        ['float', 'dMax', '5.85f', []],
        ['float', 'dMin', '8.2f', []],
        ['vector_int', 'indexChange', 'std::vector<int>()', ['/C', '/Ref']]],
    'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
['cv.BRISK.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.BRISK.getDefaultName []>

--- Incoming ---
[   'cv.BRISK.setThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>

--- Incoming ---
['cv.BRISK.getThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.BRISK.getThreshold []>

--- Incoming ---
[   'cv.BRISK.setOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'octaves', '', []]],
    'void']
ok: FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>

--- Incoming ---
['cv.BRISK.getOctaves', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.BRISK.getOctaves []>

--- Incoming ---
[   'cv.BRISK.setPatternScale',
    'void',
    ['/V', '/PV'],
    [['float', 'patternScale', '', []]],
    'void']
ok: FUNC <void cv.BRISK.setPatternScale [ARG float patternScale=]>

--- Incoming ---
['cv.BRISK.getPatternScale', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.BRISK.getPatternScale []>

--- Incoming ---
['class cv.ORB', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.ORB : Feature2D, name: ORB, base: Feature2D

--- Incoming ---
[   'enum cv.ORB.ScoreType',
    '',
    [],
    [   ['const cv.ORB.HARRIS_SCORE', '0', [], [], None, ''],
        ['const cv.ORB.FAST_SCORE', '1', [], [], None, '']],
    None]
ok: CONST HARRIS_SCORE=0
ok: CONST FAST_SCORE=1

--- Incoming ---
[   'cv.ORB.create',
    'Ptr_ORB',
    ['/S'],
    [   ['int', 'nfeatures', '500', []],
        ['float', 'scaleFactor', '1.2f', []],
        ['int', 'nlevels', '8', []],
        ['int', 'edgeThreshold', '31', []],
        ['int', 'firstLevel', '0', []],
        ['int', 'WTA_K', '2', []],
        ['ORB_ScoreType', 'scoreType', 'ORB::HARRIS_SCORE', []],
        ['int', 'patchSize', '31', []],
        ['int', 'fastThreshold', '20', []]],
    'Ptr<ORB>']
ok: FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>

--- Incoming ---
[   'cv.ORB.setMaxFeatures',
    'void',
    ['/V', '/PV'],
    [['int', 'maxFeatures', '', []]],
    'void']
ok: FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
['cv.ORB.getMaxFeatures', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getMaxFeatures []>

--- Incoming ---
[   'cv.ORB.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['double', 'scaleFactor', '', []]],
    'void']
ok: FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>

--- Incoming ---
['cv.ORB.getScaleFactor', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.ORB.getScaleFactor []>

--- Incoming ---
[   'cv.ORB.setNLevels',
    'void',
    ['/V', '/PV'],
    [['int', 'nlevels', '', []]],
    'void']
ok: FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>

--- Incoming ---
['cv.ORB.getNLevels', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getNLevels []>

--- Incoming ---
[   'cv.ORB.setEdgeThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'edgeThreshold', '', []]],
    'void']
ok: FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>

--- Incoming ---
['cv.ORB.getEdgeThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getEdgeThreshold []>

--- Incoming ---
[   'cv.ORB.setFirstLevel',
    'void',
    ['/V', '/PV'],
    [['int', 'firstLevel', '', []]],
    'void']
ok: FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>

--- Incoming ---
['cv.ORB.getFirstLevel', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getFirstLevel []>

--- Incoming ---
['cv.ORB.setWTA_K', 'void', ['/V', '/PV'], [['int', 'wta_k', '', []]], 'void']
ok: FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>

--- Incoming ---
['cv.ORB.getWTA_K', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getWTA_K []>

--- Incoming ---
[   'cv.ORB.setScoreType',
    'void',
    ['/V', '/PV'],
    [['ORB_ScoreType', 'scoreType', '', []]],
    'void']
ok: FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>

--- Incoming ---
[   'cv.ORB.getScoreType',
    'ORB_ScoreType',
    ['/C', '/V', '/PV'],
    [],
    'ORB::ScoreType']
ok: FUNC <ORB_ScoreType cv.ORB.getScoreType []>

--- Incoming ---
[   'cv.ORB.setPatchSize',
    'void',
    ['/V', '/PV'],
    [['int', 'patchSize', '', []]],
    'void']
ok: FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>

--- Incoming ---
['cv.ORB.getPatchSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getPatchSize []>

--- Incoming ---
[   'cv.ORB.setFastThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'fastThreshold', '', []]],
    'void']
ok: FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>

--- Incoming ---
['cv.ORB.getFastThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ORB.getFastThreshold []>

--- Incoming ---
['cv.ORB.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.ORB.getDefaultName []>

--- Incoming ---
['class cv.MSER', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.MSER : Feature2D, name: MSER, base: Feature2D

--- Incoming ---
[   'cv.MSER.create',
    'Ptr_MSER',
    ['/S'],
    [   ['int', 'delta', '5', []],
        ['int', 'min_area', '60', []],
        ['int', 'max_area', '14400', []],
        ['double', 'max_variation', '0.25', []],
        ['double', 'min_diversity', '.2', []],
        ['int', 'max_evolution', '200', []],
        ['double', 'area_threshold', '1.01', []],
        ['double', 'min_margin', '0.003', []],
        ['int', 'edge_blur_size', '5', []]],
    'Ptr<MSER>']
ok: FUNC <Ptr_MSER cv.MSER.create [ARG int delta=5, ARG int min_area=60, ARG int max_area=14400, ARG double max_variation=0.25, ARG double min_diversity=.2, ARG int max_evolution=200, ARG double area_threshold=1.01, ARG double min_margin=0.003, ARG int edge_blur_size=5]>

--- Incoming ---
[   'cv.MSER.detectRegions',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['vector_vector_Point', 'msers', '', ['/O', '/Ref']],
        ['vector_Rect', 'bboxes', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>

--- Incoming ---
['cv.MSER.setDelta', 'void', ['/V', '/PV'], [['int', 'delta', '', []]], 'void']
ok: FUNC <void cv.MSER.setDelta [ARG int delta=]>

--- Incoming ---
['cv.MSER.getDelta', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.MSER.getDelta []>

--- Incoming ---
[   'cv.MSER.setMinArea',
    'void',
    ['/V', '/PV'],
    [['int', 'minArea', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMinArea [ARG int minArea=]>

--- Incoming ---
['cv.MSER.getMinArea', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.MSER.getMinArea []>

--- Incoming ---
[   'cv.MSER.setMaxArea',
    'void',
    ['/V', '/PV'],
    [['int', 'maxArea', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>

--- Incoming ---
['cv.MSER.getMaxArea', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.MSER.getMaxArea []>

--- Incoming ---
[   'cv.MSER.setMaxVariation',
    'void',
    ['/V', '/PV'],
    [['double', 'maxVariation', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMaxVariation [ARG double maxVariation=]>

--- Incoming ---
['cv.MSER.getMaxVariation', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.MSER.getMaxVariation []>

--- Incoming ---
[   'cv.MSER.setMinDiversity',
    'void',
    ['/V', '/PV'],
    [['double', 'minDiversity', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMinDiversity [ARG double minDiversity=]>

--- Incoming ---
['cv.MSER.getMinDiversity', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.MSER.getMinDiversity []>

--- Incoming ---
[   'cv.MSER.setMaxEvolution',
    'void',
    ['/V', '/PV'],
    [['int', 'maxEvolution', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMaxEvolution [ARG int maxEvolution=]>

--- Incoming ---
['cv.MSER.getMaxEvolution', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.MSER.getMaxEvolution []>

--- Incoming ---
[   'cv.MSER.setAreaThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'areaThreshold', '', []]],
    'void']
ok: FUNC <void cv.MSER.setAreaThreshold [ARG double areaThreshold=]>

--- Incoming ---
['cv.MSER.getAreaThreshold', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.MSER.getAreaThreshold []>

--- Incoming ---
[   'cv.MSER.setMinMargin',
    'void',
    ['/V', '/PV'],
    [['double', 'min_margin', '', []]],
    'void']
ok: FUNC <void cv.MSER.setMinMargin [ARG double min_margin=]>

--- Incoming ---
['cv.MSER.getMinMargin', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.MSER.getMinMargin []>

--- Incoming ---
[   'cv.MSER.setEdgeBlurSize',
    'void',
    ['/V', '/PV'],
    [['int', 'edge_blur_size', '', []]],
    'void']
ok: FUNC <void cv.MSER.setEdgeBlurSize [ARG int edge_blur_size=]>

--- Incoming ---
['cv.MSER.getEdgeBlurSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.MSER.getEdgeBlurSize []>

--- Incoming ---
['cv.MSER.setPass2Only', 'void', ['/V', '/PV'], [['bool', 'f', '', []]], 'void']
ok: FUNC <void cv.MSER.setPass2Only [ARG bool f=]>

--- Incoming ---
['cv.MSER.getPass2Only', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.MSER.getPass2Only []>

--- Incoming ---
['cv.MSER.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.MSER.getDefaultName []>

--- Incoming ---
['class cv.FastFeatureDetector', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.FastFeatureDetector : Feature2D, name: FastFeatureDetector, base: Feature2D

--- Incoming ---
[   'enum cv.FastFeatureDetector.DetectorType',
    '',
    [],
    [   ['const cv.FastFeatureDetector.TYPE_5_8', '0', [], [], None, ''],
        ['const cv.FastFeatureDetector.TYPE_7_12', '1', [], [], None, ''],
        ['const cv.FastFeatureDetector.TYPE_9_16', '2', [], [], None, '']],
    None]
ok: CONST TYPE_5_8=0
ok: CONST TYPE_7_12=1
ok: CONST TYPE_9_16=2

--- Incoming ---
[   'enum cv.FastFeatureDetector.<unnamed>',
    '',
    [],
    [   ['const cv.FastFeatureDetector.THRESHOLD', '10000', [], [], None, ''],
        [   'const cv.FastFeatureDetector.NONMAX_SUPPRESSION',
            '10001',
            [],
            [],
            None,
            ''],
        ['const cv.FastFeatureDetector.FAST_N', '10002', [], [], None, '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001
ok: CONST FAST_N=10002

--- Incoming ---
[   'cv.FastFeatureDetector.create',
    'Ptr_FastFeatureDetector',
    ['/S'],
    [   ['int', 'threshold', '10', []],
        ['bool', 'nonmaxSuppression', 'true', []],
        [   'FastFeatureDetector_DetectorType',
            'type',
            'FastFeatureDetector::TYPE_9_16',
            []]],
    'Ptr<FastFeatureDetector>']
ok: FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>

--- Incoming ---
[   'cv.FastFeatureDetector.setThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
['cv.FastFeatureDetector.getThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FastFeatureDetector.getThreshold []>

--- Incoming ---
[   'cv.FastFeatureDetector.setNonmaxSuppression',
    'void',
    ['/V', '/PV'],
    [['bool', 'f', '', []]],
    'void']
ok: FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   'cv.FastFeatureDetector.getNonmaxSuppression',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   'cv.FastFeatureDetector.setType',
    'void',
    ['/V', '/PV'],
    [['FastFeatureDetector_DetectorType', 'type', '', []]],
    'void']
ok: FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   'cv.FastFeatureDetector.getType',
    'FastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    'FastFeatureDetector::DetectorType']
ok: FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>

--- Incoming ---
['cv.FastFeatureDetector.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.FastFeatureDetector.getDefaultName []>

--- Incoming ---
['class cv.AgastFeatureDetector', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AgastFeatureDetector : Feature2D, name: AgastFeatureDetector, base: Feature2D

--- Incoming ---
[   'enum cv.AgastFeatureDetector.DetectorType',
    '',
    [],
    [   ['const cv.AgastFeatureDetector.AGAST_5_8', '0', [], [], None, ''],
        ['const cv.AgastFeatureDetector.AGAST_7_12d', '1', [], [], None, ''],
        ['const cv.AgastFeatureDetector.AGAST_7_12s', '2', [], [], None, ''],
        ['const cv.AgastFeatureDetector.OAST_9_16', '3', [], [], None, '']],
    None]
ok: CONST AGAST_5_8=0
ok: CONST AGAST_7_12d=1
ok: CONST AGAST_7_12s=2
ok: CONST OAST_9_16=3

--- Incoming ---
[   'enum cv.AgastFeatureDetector.<unnamed>',
    '',
    [],
    [   ['const cv.AgastFeatureDetector.THRESHOLD', '10000', [], [], None, ''],
        [   'const cv.AgastFeatureDetector.NONMAX_SUPPRESSION',
            '10001',
            [],
            [],
            None,
            '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001

--- Incoming ---
[   'cv.AgastFeatureDetector.create',
    'Ptr_AgastFeatureDetector',
    ['/S'],
    [   ['int', 'threshold', '10', []],
        ['bool', 'nonmaxSuppression', 'true', []],
        [   'AgastFeatureDetector_DetectorType',
            'type',
            'AgastFeatureDetector::OAST_9_16',
            []]],
    'Ptr<AgastFeatureDetector>']
ok: FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>

--- Incoming ---
[   'cv.AgastFeatureDetector.setThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
['cv.AgastFeatureDetector.getThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AgastFeatureDetector.getThreshold []>

--- Incoming ---
[   'cv.AgastFeatureDetector.setNonmaxSuppression',
    'void',
    ['/V', '/PV'],
    [['bool', 'f', '', []]],
    'void']
ok: FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   'cv.AgastFeatureDetector.getNonmaxSuppression',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   'cv.AgastFeatureDetector.setType',
    'void',
    ['/V', '/PV'],
    [['AgastFeatureDetector_DetectorType', 'type', '', []]],
    'void']
ok: FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   'cv.AgastFeatureDetector.getType',
    'AgastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    'AgastFeatureDetector::DetectorType']
ok: FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>

--- Incoming ---
['cv.AgastFeatureDetector.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.AgastFeatureDetector.getDefaultName []>

--- Incoming ---
['class cv.GFTTDetector', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.GFTTDetector : Feature2D, name: GFTTDetector, base: Feature2D

--- Incoming ---
[   'cv.GFTTDetector.create',
    'Ptr_GFTTDetector',
    ['/S'],
    [   ['int', 'maxCorners', '1000', []],
        ['double', 'qualityLevel', '0.01', []],
        ['double', 'minDistance', '1', []],
        ['int', 'blockSize', '3', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   'cv.GFTTDetector.create',
    'Ptr_GFTTDetector',
    ['/S'],
    [   ['int', 'maxCorners', '', []],
        ['double', 'qualityLevel', '', []],
        ['double', 'minDistance', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'gradiantSize', '', []],
        ['bool', 'useHarrisDetector', 'false', []],
        ['double', 'k', '0.04', []]],
    'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   'cv.GFTTDetector.setMaxFeatures',
    'void',
    ['/V', '/PV'],
    [['int', 'maxFeatures', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
['cv.GFTTDetector.getMaxFeatures', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GFTTDetector.getMaxFeatures []>

--- Incoming ---
[   'cv.GFTTDetector.setQualityLevel',
    'void',
    ['/V', '/PV'],
    [['double', 'qlevel', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>

--- Incoming ---
['cv.GFTTDetector.getQualityLevel', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GFTTDetector.getQualityLevel []>

--- Incoming ---
[   'cv.GFTTDetector.setMinDistance',
    'void',
    ['/V', '/PV'],
    [['double', 'minDistance', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>

--- Incoming ---
['cv.GFTTDetector.getMinDistance', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GFTTDetector.getMinDistance []>

--- Incoming ---
[   'cv.GFTTDetector.setBlockSize',
    'void',
    ['/V', '/PV'],
    [['int', 'blockSize', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>

--- Incoming ---
['cv.GFTTDetector.getBlockSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.GFTTDetector.getBlockSize []>

--- Incoming ---
[   'cv.GFTTDetector.setGradientSize',
    'void',
    ['/V', '/PV'],
    [['int', 'gradientSize_', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setGradientSize [ARG int gradientSize_=]>

--- Incoming ---
['cv.GFTTDetector.getGradientSize', 'int', ['/V', '/PV'], [], 'int']
ok: FUNC <int cv.GFTTDetector.getGradientSize []>

--- Incoming ---
[   'cv.GFTTDetector.setHarrisDetector',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>

--- Incoming ---
['cv.GFTTDetector.getHarrisDetector', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.GFTTDetector.getHarrisDetector []>

--- Incoming ---
[   'cv.GFTTDetector.setK',
    'void',
    ['/V', '/PV'],
    [['double', 'k', '', []]],
    'void']
ok: FUNC <void cv.GFTTDetector.setK [ARG double k=]>

--- Incoming ---
['cv.GFTTDetector.getK', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.GFTTDetector.getK []>

--- Incoming ---
['cv.GFTTDetector.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.GFTTDetector.getDefaultName []>

--- Incoming ---
['class cv.SimpleBlobDetector', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.SimpleBlobDetector : Feature2D, name: SimpleBlobDetector, base: Feature2D

--- Incoming ---
[   'struct cv.SimpleBlobDetector.Params',
    '',
    ['/Simple'],
    [   ['float', 'thresholdStep', '', ['/RW']],
        ['float', 'minThreshold', '', ['/RW']],
        ['float', 'maxThreshold', '', ['/RW']],
        ['size_t', 'minRepeatability', '', ['/RW']],
        ['float', 'minDistBetweenBlobs', '', ['/RW']],
        ['bool', 'filterByColor', '', ['/RW']],
        ['uchar', 'blobColor', '', ['/RW']],
        ['bool', 'filterByArea', '', ['/RW']],
        ['float', 'minArea', '', ['/RW']],
        ['float', 'maxArea', '', ['/RW']],
        ['bool', 'filterByCircularity', '', ['/RW']],
        ['float', 'minCircularity', '', ['/RW']],
        ['float', 'maxCircularity', '', ['/RW']],
        ['bool', 'filterByInertia', '', ['/RW']],
        ['float', 'minInertiaRatio', '', ['/RW']],
        ['float', 'maxInertiaRatio', '', ['/RW']],
        ['bool', 'filterByConvexity', '', ['/RW']],
        ['float', 'minConvexity', '', ['/RW']],
        ['float', 'maxConvexity', '', ['/RW']],
        ['bool', 'collectContours', '', ['/RW']]],
    None]
ok: class CLASS cv::SimpleBlobDetector.SimpleBlobDetector_Params : , name: SimpleBlobDetector_Params, base: 

--- Incoming ---
['cv.SimpleBlobDetector.Params.Params', '', [], [], None]
ok: FUNC < cv.SimpleBlobDetector.Params.SimpleBlobDetector_Params []>

--- Incoming ---
[   'cv.SimpleBlobDetector.create',
    'Ptr_SimpleBlobDetector',
    ['/S'],
    [   [   'SimpleBlobDetector_Params',
            'parameters',
            'SimpleBlobDetector::Params()',
            ['/C', '/Ref']]],
    'Ptr<SimpleBlobDetector>']
ok: FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>

--- Incoming ---
[   'cv.SimpleBlobDetector.setParams',
    'void',
    ['/V', '/PV'],
    [['SimpleBlobDetector_Params', 'params', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.SimpleBlobDetector.setParams [ARG SimpleBlobDetector_Params params=]>

--- Incoming ---
[   'cv.SimpleBlobDetector.getParams',
    'SimpleBlobDetector_Params',
    ['/C', '/V', '/PV'],
    [],
    'SimpleBlobDetector::Params']
ok: FUNC <SimpleBlobDetector_Params cv.SimpleBlobDetector.getParams []>

--- Incoming ---
['cv.SimpleBlobDetector.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.SimpleBlobDetector.getDefaultName []>

--- Incoming ---
[   'cv.SimpleBlobDetector.getBlobContours',
    'vector_vector_Point',
    ['/C', '/V'],
    [],
    'std::vector<std::vector<cv::Point> >']
ok: FUNC <vector_vector_Point cv.SimpleBlobDetector.getBlobContours []>

--- Incoming ---
['class cv.KAZE', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.KAZE : Feature2D, name: KAZE, base: Feature2D

--- Incoming ---
[   'enum cv.KAZE.DiffusivityType',
    '',
    [],
    [   ['const cv.KAZE.DIFF_PM_G1', '0', [], [], None, ''],
        ['const cv.KAZE.DIFF_PM_G2', '1', [], [], None, ''],
        ['const cv.KAZE.DIFF_WEICKERT', '2', [], [], None, ''],
        ['const cv.KAZE.DIFF_CHARBONNIER', '3', [], [], None, '']],
    None]
ok: CONST DIFF_PM_G1=0
ok: CONST DIFF_PM_G2=1
ok: CONST DIFF_WEICKERT=2
ok: CONST DIFF_CHARBONNIER=3

--- Incoming ---
[   'cv.KAZE.create',
    'Ptr_KAZE',
    ['/S'],
    [   ['bool', 'extended', 'false', []],
        ['bool', 'upright', 'false', []],
        ['float', 'threshold', '0.001f', []],
        ['int', 'nOctaves', '4', []],
        ['int', 'nOctaveLayers', '4', []],
        ['KAZE_DiffusivityType', 'diffusivity', 'KAZE::DIFF_PM_G2', []]],
    'Ptr<KAZE>']
ok: FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   'cv.KAZE.setExtended',
    'void',
    ['/V', '/PV'],
    [['bool', 'extended', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setExtended [ARG bool extended=]>

--- Incoming ---
['cv.KAZE.getExtended', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.KAZE.getExtended []>

--- Incoming ---
[   'cv.KAZE.setUpright',
    'void',
    ['/V', '/PV'],
    [['bool', 'upright', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setUpright [ARG bool upright=]>

--- Incoming ---
['cv.KAZE.getUpright', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.KAZE.getUpright []>

--- Incoming ---
[   'cv.KAZE.setThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
['cv.KAZE.getThreshold', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.KAZE.getThreshold []>

--- Incoming ---
[   'cv.KAZE.setNOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'octaves', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
['cv.KAZE.getNOctaves', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.KAZE.getNOctaves []>

--- Incoming ---
[   'cv.KAZE.setNOctaveLayers',
    'void',
    ['/V', '/PV'],
    [['int', 'octaveLayers', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
['cv.KAZE.getNOctaveLayers', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.KAZE.getNOctaveLayers []>

--- Incoming ---
[   'cv.KAZE.setDiffusivity',
    'void',
    ['/V', '/PV'],
    [['KAZE_DiffusivityType', 'diff', '', []]],
    'void']
ok: FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   'cv.KAZE.getDiffusivity',
    'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>

--- Incoming ---
['cv.KAZE.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.KAZE.getDefaultName []>

--- Incoming ---
['class cv.AKAZE', ': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AKAZE : Feature2D, name: AKAZE, base: Feature2D

--- Incoming ---
[   'enum cv.AKAZE.DescriptorType',
    '',
    [],
    [   ['const cv.AKAZE.DESCRIPTOR_KAZE_UPRIGHT', '2', [], [], None, ''],
        ['const cv.AKAZE.DESCRIPTOR_KAZE', '3', [], [], None, ''],
        ['const cv.AKAZE.DESCRIPTOR_MLDB_UPRIGHT', '4', [], [], None, ''],
        ['const cv.AKAZE.DESCRIPTOR_MLDB', '5', [], [], None, '']],
    None]
ok: CONST DESCRIPTOR_KAZE_UPRIGHT=2
ok: CONST DESCRIPTOR_KAZE=3
ok: CONST DESCRIPTOR_MLDB_UPRIGHT=4
ok: CONST DESCRIPTOR_MLDB=5

--- Incoming ---
[   'cv.AKAZE.create',
    'Ptr_AKAZE',
    ['/S'],
    [   [   'AKAZE_DescriptorType',
            'descriptor_type',
            'AKAZE::DESCRIPTOR_MLDB',
            []],
        ['int', 'descriptor_size', '0', []],
        ['int', 'descriptor_channels', '3', []],
        ['float', 'threshold', '0.001f', []],
        ['int', 'nOctaves', '4', []],
        ['int', 'nOctaveLayers', '4', []],
        ['KAZE_DiffusivityType', 'diffusivity', 'KAZE::DIFF_PM_G2', []]],
    'Ptr<AKAZE>']
ok: FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   'cv.AKAZE.setDescriptorType',
    'void',
    ['/V', '/PV'],
    [['AKAZE_DescriptorType', 'dtype', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>

--- Incoming ---
[   'cv.AKAZE.getDescriptorType',
    'AKAZE_DescriptorType',
    ['/C', '/V', '/PV'],
    [],
    'AKAZE::DescriptorType']
ok: FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>

--- Incoming ---
[   'cv.AKAZE.setDescriptorSize',
    'void',
    ['/V', '/PV'],
    [['int', 'dsize', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>

--- Incoming ---
['cv.AKAZE.getDescriptorSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AKAZE.getDescriptorSize []>

--- Incoming ---
[   'cv.AKAZE.setDescriptorChannels',
    'void',
    ['/V', '/PV'],
    [['int', 'dch', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>

--- Incoming ---
['cv.AKAZE.getDescriptorChannels', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AKAZE.getDescriptorChannels []>

--- Incoming ---
[   'cv.AKAZE.setThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
['cv.AKAZE.getThreshold', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.AKAZE.getThreshold []>

--- Incoming ---
[   'cv.AKAZE.setNOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'octaves', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
['cv.AKAZE.getNOctaves', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AKAZE.getNOctaves []>

--- Incoming ---
[   'cv.AKAZE.setNOctaveLayers',
    'void',
    ['/V', '/PV'],
    [['int', 'octaveLayers', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
['cv.AKAZE.getNOctaveLayers', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.AKAZE.getNOctaveLayers []>

--- Incoming ---
[   'cv.AKAZE.setDiffusivity',
    'void',
    ['/V', '/PV'],
    [['KAZE_DiffusivityType', 'diff', '', []]],
    'void']
ok: FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   'cv.AKAZE.getDiffusivity',
    'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>

--- Incoming ---
['cv.AKAZE.getDefaultName', 'String', ['/C', '/V'], [], 'String']
ok: FUNC <String cv.AKAZE.getDefaultName []>

--- Incoming ---
['class cv.DescriptorMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DescriptorMatcher : Algorithm, name: DescriptorMatcher, base: Algorithm

--- Incoming ---
[   'enum cv.DescriptorMatcher.MatcherType',
    '',
    [],
    [   ['const cv.DescriptorMatcher.FLANNBASED', '1', [], [], None, ''],
        ['const cv.DescriptorMatcher.BRUTEFORCE', '2', [], [], None, ''],
        ['const cv.DescriptorMatcher.BRUTEFORCE_L1', '3', [], [], None, ''],
        [   'const cv.DescriptorMatcher.BRUTEFORCE_HAMMING',
            '4',
            [],
            [],
            None,
            ''],
        [   'const cv.DescriptorMatcher.BRUTEFORCE_HAMMINGLUT',
            '5',
            [],
            [],
            None,
            ''],
        ['const cv.DescriptorMatcher.BRUTEFORCE_SL2', '6', [], [], None, '']],
    None]
ok: CONST FLANNBASED=1
ok: CONST BRUTEFORCE=2
ok: CONST BRUTEFORCE_L1=3
ok: CONST BRUTEFORCE_HAMMING=4
ok: CONST BRUTEFORCE_HAMMINGLUT=5
ok: CONST BRUTEFORCE_SL2=6

--- Incoming ---
[   'cv.DescriptorMatcher.add',
    'void',
    ['/V'],
    [['vector_Mat', 'descriptors', '', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>

--- Incoming ---
[   'cv.DescriptorMatcher.getTrainDescriptors',
    'vector_Mat',
    ['/C'],
    [],
    'std::vector<Mat>']
ok: FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>

--- Incoming ---
['cv.DescriptorMatcher.clear', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.DescriptorMatcher.clear []>

--- Incoming ---
['cv.DescriptorMatcher.empty', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.DescriptorMatcher.empty []>

--- Incoming ---
[   'cv.DescriptorMatcher.isMaskSupported',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.DescriptorMatcher.isMaskSupported []>

--- Incoming ---
['cv.DescriptorMatcher.train', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.DescriptorMatcher.train []>

--- Incoming ---
[   'cv.DescriptorMatcher.match',
    'void',
    ['/C'],
    [   ['Mat', 'queryDescriptors', '', []],
        ['Mat', 'trainDescriptors', '', []],
        ['vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.DescriptorMatcher.knnMatch',
    'void',
    ['/C'],
    [   ['Mat', 'queryDescriptors', '', []],
        ['Mat', 'trainDescriptors', '', []],
        ['vector_vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['int', 'k', '', []],
        ['Mat', 'mask', 'Mat()', []],
        ['bool', 'compactResult', 'false', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   'cv.DescriptorMatcher.radiusMatch',
    'void',
    ['/C'],
    [   ['Mat', 'queryDescriptors', '', []],
        ['Mat', 'trainDescriptors', '', []],
        ['vector_vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['float', 'maxDistance', '', []],
        ['Mat', 'mask', 'Mat()', []],
        ['bool', 'compactResult', 'false', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   'cv.DescriptorMatcher.match',
    'void',
    [],
    [   ['Mat', 'queryDescriptors', '', []],
        ['vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['vector_Mat', 'masks', 'vector_Mat()', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   'cv.DescriptorMatcher.knnMatch',
    'void',
    [],
    [   ['Mat', 'queryDescriptors', '', []],
        ['vector_vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['int', 'k', '', []],
        ['vector_Mat', 'masks', 'vector_Mat()', []],
        ['bool', 'compactResult', 'false', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   'cv.DescriptorMatcher.radiusMatch',
    'void',
    [],
    [   ['Mat', 'queryDescriptors', '', []],
        ['vector_vector_DMatch', 'matches', '', ['/O', '/Ref']],
        ['float', 'maxDistance', '', []],
        ['vector_Mat', 'masks', 'vector_Mat()', []],
        ['bool', 'compactResult', 'false', []]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   'cv.DescriptorMatcher.write',
    'void',
    ['/C'],
    [['String', 'fileName', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>

--- Incoming ---
[   'cv.DescriptorMatcher.read',
    'void',
    [],
    [['String', 'fileName', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>

--- Incoming ---
[   'cv.DescriptorMatcher.read',
    'void',
    ['/V'],
    [['FileNode', 'arg1', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>

--- Incoming ---
[   'cv.DescriptorMatcher.clone',
    'Ptr_DescriptorMatcher',
    ['/C', '/V', '/PV'],
    [['bool', 'emptyTrainData', 'false', []]],
    'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>

--- Incoming ---
[   'cv.DescriptorMatcher.create',
    'Ptr_DescriptorMatcher',
    ['/S'],
    [['String', 'descriptorMatcherType', '', ['/C', '/Ref']]],
    'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>

--- Incoming ---
[   'cv.DescriptorMatcher.create',
    'Ptr_DescriptorMatcher',
    ['/S'],
    [['DescriptorMatcher_MatcherType', 'matcherType', '', ['/C', '/Ref']]],
    'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>

--- Incoming ---
[   'cv.DescriptorMatcher.write',
    'void',
    ['/C'],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG FileStorage fs=, ARG String name=]>

--- Incoming ---
['class cv.BFMatcher', ': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.BFMatcher : DescriptorMatcher, name: BFMatcher, base: DescriptorMatcher

--- Incoming ---
[   'cv.BFMatcher.BFMatcher',
    '',
    [],
    [['int', 'normType', 'NORM_L2', []], ['bool', 'crossCheck', 'false', []]],
    None]
ok: FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
[   'cv.BFMatcher.create',
    'Ptr_BFMatcher',
    ['/S'],
    [['int', 'normType', 'NORM_L2', []], ['bool', 'crossCheck', 'false', []]],
    'Ptr<BFMatcher>']
ok: FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
['class cv.FlannBasedMatcher', ': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.FlannBasedMatcher : DescriptorMatcher, name: FlannBasedMatcher, base: DescriptorMatcher

--- Incoming ---
[   'cv.FlannBasedMatcher.FlannBasedMatcher',
    '',
    [],
    [   [   'Ptr_flann_IndexParams',
            'indexParams',
            'makePtr<flann::KDTreeIndexParams>()',
            ['/C', '/Ref']],
        [   'Ptr_flann_SearchParams',
            'searchParams',
            'makePtr<flann::SearchParams>()',
            ['/C', '/Ref']]],
    None]
ok: FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>

--- Incoming ---
[   'cv.FlannBasedMatcher.create',
    'Ptr_FlannBasedMatcher',
    ['/S'],
    [],
    'Ptr<FlannBasedMatcher>']
ok: FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>

--- Incoming ---
[   'enum struct cv.DrawMatchesFlags',
    '',
    [],
    [   ['const cv.DrawMatchesFlags.DEFAULT', '0', [], [], None, ''],
        ['const cv.DrawMatchesFlags.DRAW_OVER_OUTIMG', '1', [], [], None, ''],
        [   'const cv.DrawMatchesFlags.NOT_DRAW_SINGLE_POINTS',
            '2',
            [],
            [],
            None,
            ''],
        [   'const cv.DrawMatchesFlags.DRAW_RICH_KEYPOINTS',
            '4',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST DEFAULT=0
ok: CONST DrawMatchesFlags_DEFAULT=0
class not found: CONST DRAW_OVER_OUTIMG=1
ok: CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1
class not found: CONST NOT_DRAW_SINGLE_POINTS=2
ok: CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2
class not found: CONST DRAW_RICH_KEYPOINTS=4
ok: CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4

--- Incoming ---
[   'cv.drawKeypoints',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['vector_KeyPoint', 'keypoints', '', ['/C', '/Ref']],
        ['Mat', 'outImage', '', ['/IO']],
        ['Scalar', 'color', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['DrawMatchesFlags', 'flags', 'DrawMatchesFlags::DEFAULT', []]],
    'void']
ok: FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   'cv.drawMatches',
    'void',
    [],
    [   ['Mat', 'img1', '', []],
        ['vector_KeyPoint', 'keypoints1', '', ['/C', '/Ref']],
        ['Mat', 'img2', '', []],
        ['vector_KeyPoint', 'keypoints2', '', ['/C', '/Ref']],
        ['vector_DMatch', 'matches1to2', '', ['/C', '/Ref']],
        ['Mat', 'outImg', '', ['/IO']],
        ['Scalar', 'matchColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['Scalar', 'singlePointColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['vector_char', 'matchesMask', 'std::vector<char>()', ['/C', '/Ref']],
        ['DrawMatchesFlags', 'flags', 'DrawMatchesFlags::DEFAULT', []]],
    'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   'cv.drawMatches',
    'void',
    [],
    [   ['Mat', 'img1', '', []],
        ['vector_KeyPoint', 'keypoints1', '', ['/C', '/Ref']],
        ['Mat', 'img2', '', []],
        ['vector_KeyPoint', 'keypoints2', '', ['/C', '/Ref']],
        ['vector_DMatch', 'matches1to2', '', ['/C', '/Ref']],
        ['Mat', 'outImg', '', ['/IO']],
        ['int', 'matchesThickness', '', ['/C']],
        ['Scalar', 'matchColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['Scalar', 'singlePointColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['vector_char', 'matchesMask', 'std::vector<char>()', ['/C', '/Ref']],
        ['DrawMatchesFlags', 'flags', 'DrawMatchesFlags::DEFAULT', []]],
    'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG int matchesThickness=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   'cv.drawMatches',
    'void',
    ['=drawMatchesKnn'],
    [   ['Mat', 'img1', '', []],
        ['vector_KeyPoint', 'keypoints1', '', ['/C', '/Ref']],
        ['Mat', 'img2', '', []],
        ['vector_KeyPoint', 'keypoints2', '', ['/C', '/Ref']],
        ['vector_vector_DMatch', 'matches1to2', '', ['/C', '/Ref']],
        ['Mat', 'outImg', '', ['/IO']],
        ['Scalar', 'matchColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        ['Scalar', 'singlePointColor', 'Scalar::all(-1)', ['/C', '/Ref']],
        [   'vector_vector_char',
            'matchesMask',
            'std::vector<std::vector<char> >()',
            ['/C', '/Ref']],
        ['DrawMatchesFlags', 'flags', 'DrawMatchesFlags::DEFAULT', []]],
    'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
['class cv.BOWTrainer', '', [], [], None]
ok: class CLASS cv::.BOWTrainer : , name: BOWTrainer, base: 

--- Incoming ---
[   'cv.BOWTrainer.add',
    'void',
    [],
    [['Mat', 'descriptors', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>

--- Incoming ---
['cv.BOWTrainer.getDescriptors', 'vector_Mat', ['/C'], [], 'std::vector<Mat>']
ok: FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>

--- Incoming ---
['cv.BOWTrainer.descriptorsCount', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.BOWTrainer.descriptorsCount []>

--- Incoming ---
['cv.BOWTrainer.clear', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.BOWTrainer.clear []>

--- Incoming ---
['cv.BOWTrainer.cluster', 'Mat', ['/C', '/V', '/PV'], [], 'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster []>

--- Incoming ---
[   'cv.BOWTrainer.cluster',
    'Mat',
    ['/C', '/V', '/PV'],
    [['Mat', 'descriptors', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
['class cv.BOWKMeansTrainer', ': cv::BOWTrainer', [], [], None]
ok: class CLASS cv::.BOWKMeansTrainer : BOWTrainer, name: BOWKMeansTrainer, base: BOWTrainer

--- Incoming ---
[   'cv.BOWKMeansTrainer.BOWKMeansTrainer',
    '',
    [],
    [   ['int', 'clusterCount', '', []],
        ['TermCriteria', 'termcrit', 'TermCriteria()', ['/C', '/Ref']],
        ['int', 'attempts', '3', []],
        ['int', 'flags', 'KMEANS_PP_CENTERS', []]],
    None]
ok: FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>

--- Incoming ---
['cv.BOWKMeansTrainer.cluster', 'Mat', ['/C', '/V'], [], 'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster []>

--- Incoming ---
[   'cv.BOWKMeansTrainer.cluster',
    'Mat',
    ['/C', '/V'],
    [['Mat', 'descriptors', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
['class cv.BOWImgDescriptorExtractor', '', [], [], None]
ok: class CLASS cv::.BOWImgDescriptorExtractor : , name: BOWImgDescriptorExtractor, base: 

--- Incoming ---
[   'cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor',
    '',
    [],
    [   ['Ptr_DescriptorExtractor', 'dextractor', '', ['/C', '/Ref']],
        ['Ptr_DescriptorMatcher', 'dmatcher', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>

--- Incoming ---
[   'cv.BOWImgDescriptorExtractor.setVocabulary',
    'void',
    [],
    [['Mat', 'vocabulary', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>

--- Incoming ---
['cv.BOWImgDescriptorExtractor.getVocabulary', 'Mat', ['/C'], [], 'Mat']
ok: FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>

--- Incoming ---
[   'cv.BOWImgDescriptorExtractor.compute2',
    'void',
    ['=compute'],
    [   ['Mat', 'image', '', ['/C', '/Ref']],
        ['vector_KeyPoint', 'keypoints', '', ['/Ref']],
        ['Mat', 'imgDescriptor', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>

--- Incoming ---
['cv.BOWImgDescriptorExtractor.descriptorSize', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>

--- Incoming ---
['cv.BOWImgDescriptorExtractor.descriptorType', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>


===== Generating... =====
CLASS cv::.AKAZE : Feature2D
[CONST DESCRIPTOR_KAZE_UPRIGHT=2, CONST DESCRIPTOR_KAZE=3, CONST DESCRIPTOR_MLDB_UPRIGHT=4, CONST DESCRIPTOR_MLDB=5]
FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels)
java: AKAZE create(int descriptor_type, int descriptor_size)
java: AKAZE create(int descriptor_type)
java: AKAZE create()
FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>
java: void setDescriptorType(int dtype)
FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>
java: int getDescriptorType()
FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>
java: void setDescriptorSize(int dsize)
FUNC <int cv.AKAZE.getDescriptorSize []>
java: int getDescriptorSize()
FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>
java: void setDescriptorChannels(int dch)
FUNC <int cv.AKAZE.getDescriptorChannels []>
java: int getDescriptorChannels()
FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
FUNC <double cv.AKAZE.getThreshold []>
java: double getThreshold()
FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <int cv.AKAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <int cv.AKAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <String cv.AKAZE.getDefaultName []>
java: String getDefaultName()
CLASS cv::.AffineFeature : Feature2D
FUNC <Ptr_AffineFeature cv.AffineFeature.create [ARG Ptr_Feature2D backend=, ARG int maxTilt=5, ARG int minTilt=0, ARG float tiltStep=1.4142135623730951f, ARG float rotateStepBase=72]>
java: AffineFeature create(Feature2D backend, int maxTilt, int minTilt, float tiltStep, float rotateStepBase)
java: AffineFeature create(Feature2D backend, int maxTilt, int minTilt, float tiltStep)
java: AffineFeature create(Feature2D backend, int maxTilt, int minTilt)
java: AffineFeature create(Feature2D backend, int maxTilt)
java: AffineFeature create(Feature2D backend)
FUNC <void cv.AffineFeature.setViewParams [ARG vector_float tilts=, ARG vector_float rolls=]>
java: void setViewParams(MatOfFloat tilts, MatOfFloat rolls)
FUNC <void cv.AffineFeature.getViewParams [ARG vector_float tilts=, ARG vector_float rolls=]>
java: void getViewParams(MatOfFloat tilts, MatOfFloat rolls)
FUNC <String cv.AffineFeature.getDefaultName []>
java: String getDefaultName()
CLASS cv::.AgastFeatureDetector : Feature2D
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001]
[CONST AGAST_5_8=0, CONST AGAST_7_12d=1, CONST AGAST_7_12s=2, CONST OAST_9_16=3]
FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: AgastFeatureDetector create(int threshold)
java: AgastFeatureDetector create()
FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <int cv.AgastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>
java: void setType(int type)
FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>
java: int getType()
FUNC <String cv.AgastFeatureDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv::.BFMatcher : DescriptorMatcher
FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java:  BFMatcher(int normType, boolean crossCheck)
java:  BFMatcher(int normType)
java:  BFMatcher()
FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java: BFMatcher create(int normType, boolean crossCheck)
java: BFMatcher create(int normType)
java: BFMatcher create()
CLASS cv::.BOWImgDescriptorExtractor : 
FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>
SKIP:cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(Ptr_DescriptorExtractor dextractor, Ptr_DescriptorMatcher dmatcher)	 due to ARG type Ptr_DescriptorExtractor/I
FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>
java: void setVocabulary(Mat vocabulary)
FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>
java: Mat getVocabulary()
FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat imgDescriptor)
FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>
java: int descriptorType()
CLASS cv::.BOWKMeansTrainer : BOWTrainer
FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts, int flags)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit)
java:  BOWKMeansTrainer(int clusterCount)
FUNC <Mat cv.BOWKMeansTrainer.cluster []>
java: Mat cluster()
FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
CLASS cv::.BOWTrainer : 
FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>
java: void add(Mat descriptors)
FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>
java: List<Mat> getDescriptors()
FUNC <int cv.BOWTrainer.descriptorsCount []>
java: int descriptorsCount()
FUNC <void cv.BOWTrainer.clear []>
java: void clear()
FUNC <Mat cv.BOWTrainer.cluster []>
java: Mat cluster()
FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
CLASS cv::.BRISK : Feature2D
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>
java: BRISK create(int thresh, int octaves, float patternScale)
java: BRISK create(int thresh, int octaves)
java: BRISK create(int thresh)
java: BRISK create()
FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList)
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList)
FUNC <String cv.BRISK.getDefaultName []>
java: String getDefaultName()
FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <int cv.BRISK.getThreshold []>
java: int getThreshold()
FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>
java: void setOctaves(int octaves)
FUNC <int cv.BRISK.getOctaves []>
java: int getOctaves()
FUNC <void cv.BRISK.setPatternScale [ARG float patternScale=]>
java: void setPatternScale(float patternScale)
FUNC <float cv.BRISK.getPatternScale []>
java: float getPatternScale()
CLASS cv::.DescriptorMatcher : Algorithm
[CONST FLANNBASED=1, CONST BRUTEFORCE=2, CONST BRUTEFORCE_L1=3, CONST BRUTEFORCE_HAMMING=4, CONST BRUTEFORCE_HAMMINGLUT=5, CONST BRUTEFORCE_SL2=6]
FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>
java: void add(List<Mat> descriptors)
FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>
java: List<Mat> getTrainDescriptors()
FUNC <void cv.DescriptorMatcher.clear []>
java: void clear()
FUNC <bool cv.DescriptorMatcher.empty []>
java: boolean empty()
FUNC <bool cv.DescriptorMatcher.isMaskSupported []>
java: boolean isMaskSupported()
FUNC <void cv.DescriptorMatcher.train []>
java: void train()
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches, Mat mask)
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>
java: void match(Mat queryDescriptors, MatOfDMatch matches, List<Mat> masks)
java: void match(Mat queryDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>
java: void write(String fileName)
FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>
SKIP:void cv::DescriptorMatcher::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>
java: DescriptorMatcher clone(boolean emptyTrainData)
java: DescriptorMatcher clone()
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>
java: DescriptorMatcher create(String descriptorMatcherType)
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>
java: DescriptorMatcher create(int matcherType)
FUNC <void cv.DescriptorMatcher.write [ARG FileStorage fs=, ARG String name=]>
SKIP:void cv::DescriptorMatcher::write(FileStorage fs, String name)	 due to ARG type FileStorage/I
CLASS cv::.FastFeatureDetector : Feature2D
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001, CONST FAST_N=10002]
[CONST TYPE_5_8=0, CONST TYPE_7_12=1, CONST TYPE_9_16=2]
FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: FastFeatureDetector create(int threshold)
java: FastFeatureDetector create()
FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <int cv.FastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>
java: void setType(int type)
FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>
java: int getType()
FUNC <String cv.FastFeatureDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv::.Feature2D : Algorithm
FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>
java: void detect(Mat image, MatOfKeyPoint keypoints, Mat mask)
java: void detect(Mat image, MatOfKeyPoint keypoints)
FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> masks)
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints)
FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>
java: void compute(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> descriptors)
FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors, boolean useProvidedKeypoints)
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <int cv.Feature2D.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.Feature2D.descriptorType []>
java: int descriptorType()
FUNC <int cv.Feature2D.defaultNorm []>
java: int defaultNorm()
FUNC <void cv.Feature2D.write [ARG String fileName=]>
java: void write(String fileName)
FUNC <void cv.Feature2D.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>
SKIP:void cv::Feature2D::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <bool cv.Feature2D.empty []>
java: boolean empty()
FUNC <String cv.Feature2D.getDefaultName []>
java: String getDefaultName()
FUNC <void cv.Feature2D.write [ARG FileStorage fs=, ARG String name=]>
SKIP:void cv::Feature2D::write(FileStorage fs, String name)	 due to ARG type FileStorage/I
CLASS cv::.Features2d : 
[CONST DrawMatchesFlags_DEFAULT=0, CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1, CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2, CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4]
FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color, int flags)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask, int flags)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG int matchesThickness=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, int matchesThickness, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask, int flags)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, int matchesThickness, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, int matchesThickness, Scalar matchColor, Scalar singlePointColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, int matchesThickness, Scalar matchColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, int matchesThickness)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask, int flags)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg)
CLASS cv::.FlannBasedMatcher : DescriptorMatcher
FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>
java: FlannBasedMatcher create()
CLASS cv::.GFTTDetector : Feature2D
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance)
java: GFTTDetector create(int maxCorners, double qualityLevel)
java: GFTTDetector create(int maxCorners)
java: GFTTDetector create()
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize)
FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <int cv.GFTTDetector.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>
java: void setQualityLevel(double qlevel)
FUNC <double cv.GFTTDetector.getQualityLevel []>
java: double getQualityLevel()
FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>
java: void setMinDistance(double minDistance)
FUNC <double cv.GFTTDetector.getMinDistance []>
java: double getMinDistance()
FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <int cv.GFTTDetector.getBlockSize []>
java: int getBlockSize()
FUNC <void cv.GFTTDetector.setGradientSize [ARG int gradientSize_=]>
java: void setGradientSize(int gradientSize_)
FUNC <int cv.GFTTDetector.getGradientSize []>
java: int getGradientSize()
FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>
java: void setHarrisDetector(boolean val)
FUNC <bool cv.GFTTDetector.getHarrisDetector []>
java: boolean getHarrisDetector()
FUNC <void cv.GFTTDetector.setK [ARG double k=]>
java: void setK(double k)
FUNC <double cv.GFTTDetector.getK []>
java: double getK()
FUNC <String cv.GFTTDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv::.KAZE : Feature2D
[CONST DIFF_PM_G1=0, CONST DIFF_PM_G2=1, CONST DIFF_WEICKERT=2, CONST DIFF_CHARBONNIER=3]
FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves)
java: KAZE create(boolean extended, boolean upright, float threshold)
java: KAZE create(boolean extended, boolean upright)
java: KAZE create(boolean extended)
java: KAZE create()
FUNC <void cv.KAZE.setExtended [ARG bool extended=]>
java: void setExtended(boolean extended)
FUNC <bool cv.KAZE.getExtended []>
java: boolean getExtended()
FUNC <void cv.KAZE.setUpright [ARG bool upright=]>
java: void setUpright(boolean upright)
FUNC <bool cv.KAZE.getUpright []>
java: boolean getUpright()
FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
FUNC <double cv.KAZE.getThreshold []>
java: double getThreshold()
FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <int cv.KAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <int cv.KAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <String cv.KAZE.getDefaultName []>
java: String getDefaultName()
CLASS cv::.MSER : Feature2D
FUNC <Ptr_MSER cv.MSER.create [ARG int delta=5, ARG int min_area=60, ARG int max_area=14400, ARG double max_variation=0.25, ARG double min_diversity=.2, ARG int max_evolution=200, ARG double area_threshold=1.01, ARG double min_margin=0.003, ARG int edge_blur_size=5]>
java: MSER create(int delta, int min_area, int max_area, double max_variation, double min_diversity, int max_evolution, double area_threshold, double min_margin, int edge_blur_size)
java: MSER create(int delta, int min_area, int max_area, double max_variation, double min_diversity, int max_evolution, double area_threshold, double min_margin)
java: MSER create(int delta, int min_area, int max_area, double max_variation, double min_diversity, int max_evolution, double area_threshold)
java: MSER create(int delta, int min_area, int max_area, double max_variation, double min_diversity, int max_evolution)
java: MSER create(int delta, int min_area, int max_area, double max_variation, double min_diversity)
java: MSER create(int delta, int min_area, int max_area, double max_variation)
java: MSER create(int delta, int min_area, int max_area)
java: MSER create(int delta, int min_area)
java: MSER create(int delta)
java: MSER create()
FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>
java: void detectRegions(Mat image, List<MatOfPoint> msers, MatOfRect bboxes)
FUNC <void cv.MSER.setDelta [ARG int delta=]>
java: void setDelta(int delta)
FUNC <int cv.MSER.getDelta []>
java: int getDelta()
FUNC <void cv.MSER.setMinArea [ARG int minArea=]>
java: void setMinArea(int minArea)
FUNC <int cv.MSER.getMinArea []>
java: int getMinArea()
FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>
java: void setMaxArea(int maxArea)
FUNC <int cv.MSER.getMaxArea []>
java: int getMaxArea()
FUNC <void cv.MSER.setMaxVariation [ARG double maxVariation=]>
java: void setMaxVariation(double maxVariation)
FUNC <double cv.MSER.getMaxVariation []>
java: double getMaxVariation()
FUNC <void cv.MSER.setMinDiversity [ARG double minDiversity=]>
java: void setMinDiversity(double minDiversity)
FUNC <double cv.MSER.getMinDiversity []>
java: double getMinDiversity()
FUNC <void cv.MSER.setMaxEvolution [ARG int maxEvolution=]>
java: void setMaxEvolution(int maxEvolution)
FUNC <int cv.MSER.getMaxEvolution []>
java: int getMaxEvolution()
FUNC <void cv.MSER.setAreaThreshold [ARG double areaThreshold=]>
java: void setAreaThreshold(double areaThreshold)
FUNC <double cv.MSER.getAreaThreshold []>
java: double getAreaThreshold()
FUNC <void cv.MSER.setMinMargin [ARG double min_margin=]>
java: void setMinMargin(double min_margin)
FUNC <double cv.MSER.getMinMargin []>
java: double getMinMargin()
FUNC <void cv.MSER.setEdgeBlurSize [ARG int edge_blur_size=]>
java: void setEdgeBlurSize(int edge_blur_size)
FUNC <int cv.MSER.getEdgeBlurSize []>
java: int getEdgeBlurSize()
FUNC <void cv.MSER.setPass2Only [ARG bool f=]>
java: void setPass2Only(boolean f)
FUNC <bool cv.MSER.getPass2Only []>
java: boolean getPass2Only()
FUNC <String cv.MSER.getDefaultName []>
java: String getDefaultName()
CLASS cv::.ORB : Feature2D
[CONST HARRIS_SCORE=0, CONST FAST_SCORE=1]
FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize, int fastThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels)
java: ORB create(int nfeatures, float scaleFactor)
java: ORB create(int nfeatures)
java: ORB create()
FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <int cv.ORB.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>
java: void setScaleFactor(double scaleFactor)
FUNC <double cv.ORB.getScaleFactor []>
java: double getScaleFactor()
FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>
java: void setNLevels(int nlevels)
FUNC <int cv.ORB.getNLevels []>
java: int getNLevels()
FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>
java: void setEdgeThreshold(int edgeThreshold)
FUNC <int cv.ORB.getEdgeThreshold []>
java: int getEdgeThreshold()
FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>
java: void setFirstLevel(int firstLevel)
FUNC <int cv.ORB.getFirstLevel []>
java: int getFirstLevel()
FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>
java: void setWTA_K(int wta_k)
FUNC <int cv.ORB.getWTA_K []>
java: int getWTA_K()
FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>
java: void setScoreType(int scoreType)
FUNC <ORB_ScoreType cv.ORB.getScoreType []>
java: int getScoreType()
FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>
java: void setPatchSize(int patchSize)
FUNC <int cv.ORB.getPatchSize []>
java: int getPatchSize()
FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>
java: void setFastThreshold(int fastThreshold)
FUNC <int cv.ORB.getFastThreshold []>
java: int getFastThreshold()
FUNC <String cv.ORB.getDefaultName []>
java: String getDefaultName()
CLASS cv::.SIFT : Feature2D
FUNC <Ptr_SIFT cv.SIFT.create [ARG int nfeatures=0, ARG int nOctaveLayers=3, ARG double contrastThreshold=0.04, ARG double edgeThreshold=10, ARG double sigma=1.6, ARG bool enable_precise_upscale=false]>
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma, boolean enable_precise_upscale)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold)
java: SIFT create(int nfeatures, int nOctaveLayers)
java: SIFT create(int nfeatures)
java: SIFT create()
FUNC <Ptr_SIFT cv.SIFT.create [ARG int nfeatures=, ARG int nOctaveLayers=, ARG double contrastThreshold=, ARG double edgeThreshold=, ARG double sigma=, ARG int descriptorType=, ARG bool enable_precise_upscale=false]>
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma, int descriptorType, boolean enable_precise_upscale)
java: SIFT create(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma, int descriptorType)
FUNC <String cv.SIFT.getDefaultName []>
java: String getDefaultName()
FUNC <void cv.SIFT.setNFeatures [ARG int maxFeatures=]>
java: void setNFeatures(int maxFeatures)
FUNC <int cv.SIFT.getNFeatures []>
java: int getNFeatures()
FUNC <void cv.SIFT.setNOctaveLayers [ARG int nOctaveLayers=]>
java: void setNOctaveLayers(int nOctaveLayers)
FUNC <int cv.SIFT.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <void cv.SIFT.setContrastThreshold [ARG double contrastThreshold=]>
java: void setContrastThreshold(double contrastThreshold)
FUNC <double cv.SIFT.getContrastThreshold []>
java: double getContrastThreshold()
FUNC <void cv.SIFT.setEdgeThreshold [ARG double edgeThreshold=]>
java: void setEdgeThreshold(double edgeThreshold)
FUNC <double cv.SIFT.getEdgeThreshold []>
java: double getEdgeThreshold()
FUNC <void cv.SIFT.setSigma [ARG double sigma=]>
java: void setSigma(double sigma)
FUNC <double cv.SIFT.getSigma []>
java: double getSigma()
CLASS cv::.SimpleBlobDetector : Feature2D
FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>
java: SimpleBlobDetector create(SimpleBlobDetector_Params parameters)
java: SimpleBlobDetector create()
FUNC <void cv.SimpleBlobDetector.setParams [ARG SimpleBlobDetector_Params params=]>
java: void setParams(SimpleBlobDetector_Params params)
FUNC <SimpleBlobDetector_Params cv.SimpleBlobDetector.getParams []>
java: SimpleBlobDetector_Params getParams()
FUNC <String cv.SimpleBlobDetector.getDefaultName []>
java: String getDefaultName()
FUNC <vector_vector_Point cv.SimpleBlobDetector.getBlobContours []>
java: List<MatOfPoint> getBlobContours()
CLASS cv::SimpleBlobDetector.SimpleBlobDetector_Params : 
FUNC < cv.SimpleBlobDetector.Params.SimpleBlobDetector_Params []>
java:  SimpleBlobDetector_Params()
FUNC <float cv.SimpleBlobDetector.Params.get_thresholdStep []>
java: float get_thresholdStep()
FUNC <void cv.SimpleBlobDetector.Params.set_thresholdStep [ARG float thresholdStep=]>
java: void set_thresholdStep(float thresholdStep)
FUNC <float cv.SimpleBlobDetector.Params.get_minThreshold []>
java: float get_minThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_minThreshold [ARG float minThreshold=]>
java: void set_minThreshold(float minThreshold)
FUNC <float cv.SimpleBlobDetector.Params.get_maxThreshold []>
java: float get_maxThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_maxThreshold [ARG float maxThreshold=]>
java: void set_maxThreshold(float maxThreshold)
FUNC <size_t cv.SimpleBlobDetector.Params.get_minRepeatability []>
java: long get_minRepeatability()
FUNC <void cv.SimpleBlobDetector.Params.set_minRepeatability [ARG size_t minRepeatability=]>
java: void set_minRepeatability(long minRepeatability)
FUNC <float cv.SimpleBlobDetector.Params.get_minDistBetweenBlobs []>
java: float get_minDistBetweenBlobs()
FUNC <void cv.SimpleBlobDetector.Params.set_minDistBetweenBlobs [ARG float minDistBetweenBlobs=]>
java: void set_minDistBetweenBlobs(float minDistBetweenBlobs)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByColor []>
java: boolean get_filterByColor()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByColor [ARG bool filterByColor=]>
java: void set_filterByColor(boolean filterByColor)
FUNC <uchar cv.SimpleBlobDetector.Params.get_blobColor []>
SKIP:uchar SimpleBlobDetector_Params::blobColor	 due to RET type uchar
FUNC <void cv.SimpleBlobDetector.Params.set_blobColor [ARG uchar blobColor=]>
SKIP:void SimpleBlobDetector_Params::blobColor	 due to ARG type uchar/I
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByArea []>
java: boolean get_filterByArea()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByArea [ARG bool filterByArea=]>
java: void set_filterByArea(boolean filterByArea)
FUNC <float cv.SimpleBlobDetector.Params.get_minArea []>
java: float get_minArea()
FUNC <void cv.SimpleBlobDetector.Params.set_minArea [ARG float minArea=]>
java: void set_minArea(float minArea)
FUNC <float cv.SimpleBlobDetector.Params.get_maxArea []>
java: float get_maxArea()
FUNC <void cv.SimpleBlobDetector.Params.set_maxArea [ARG float maxArea=]>
java: void set_maxArea(float maxArea)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByCircularity []>
java: boolean get_filterByCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByCircularity [ARG bool filterByCircularity=]>
java: void set_filterByCircularity(boolean filterByCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_minCircularity []>
java: float get_minCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_minCircularity [ARG float minCircularity=]>
java: void set_minCircularity(float minCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxCircularity []>
java: float get_maxCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxCircularity [ARG float maxCircularity=]>
java: void set_maxCircularity(float maxCircularity)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByInertia []>
java: boolean get_filterByInertia()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByInertia [ARG bool filterByInertia=]>
java: void set_filterByInertia(boolean filterByInertia)
FUNC <float cv.SimpleBlobDetector.Params.get_minInertiaRatio []>
java: float get_minInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_minInertiaRatio [ARG float minInertiaRatio=]>
java: void set_minInertiaRatio(float minInertiaRatio)
FUNC <float cv.SimpleBlobDetector.Params.get_maxInertiaRatio []>
java: float get_maxInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_maxInertiaRatio [ARG float maxInertiaRatio=]>
java: void set_maxInertiaRatio(float maxInertiaRatio)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByConvexity []>
java: boolean get_filterByConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByConvexity [ARG bool filterByConvexity=]>
java: void set_filterByConvexity(boolean filterByConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_minConvexity []>
java: float get_minConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_minConvexity [ARG float minConvexity=]>
java: void set_minConvexity(float minConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxConvexity []>
java: float get_maxConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxConvexity [ARG float maxConvexity=]>
java: void set_maxConvexity(float maxConvexity)
FUNC <bool cv.SimpleBlobDetector.Params.get_collectContours []>
java: boolean get_collectContours()
FUNC <void cv.SimpleBlobDetector.Params.set_collectContours [ARG bool collectContours=]>
java: void set_collectContours(boolean collectContours)

=== MODULE: img_hash (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash) ===


Files (8):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/block_mean_hash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/img_hash_base.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/color_moment_hash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/phash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/average_hash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/marr_hildreth_hash.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/radial_variance_hash.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Img_hash : , name: Img_hash, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/block_mean_hash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
[   'enum cv.img_hash.BlockMeanHashMode',
    '',
    [],
    [   ['const cv.img_hash.BLOCK_MEAN_HASH_MODE_0', '0', [], [], None, ''],
        ['const cv.img_hash.BLOCK_MEAN_HASH_MODE_1', '1', [], [], None, '']],
    None]
ok: CONST BLOCK_MEAN_HASH_MODE_0=0
ok: CONST BLOCK_MEAN_HASH_MODE_1=1

--- Incoming ---
['class cv.img_hash.BlockMeanHash', ': cv::img_hash::ImgHashBase', [], [], None]
ok: class CLASS cv.img_hash::.BlockMeanHash : ImgHashBase, name: BlockMeanHash, base: ImgHashBase

--- Incoming ---
[   'cv.img_hash.BlockMeanHash.setMode',
    'void',
    [],
    [['int', 'mode', '', []]],
    'void']
ok: FUNC <void cv.img_hash.BlockMeanHash.setMode [ARG int mode=]>

--- Incoming ---
[   'cv.img_hash.BlockMeanHash.getMean',
    'vector_double',
    ['/C'],
    [],
    'std::vector<double>']
ok: FUNC <vector_double cv.img_hash.BlockMeanHash.getMean []>

--- Incoming ---
[   'cv.img_hash.BlockMeanHash.create',
    'Ptr_BlockMeanHash',
    ['/S'],
    [['int', 'mode', 'BLOCK_MEAN_HASH_MODE_0', []]],
    'Ptr<BlockMeanHash>']
ok: FUNC <Ptr_BlockMeanHash cv.img_hash.BlockMeanHash.create [ARG int mode=BLOCK_MEAN_HASH_MODE_0]>

--- Incoming ---
[   'cv.img_hash.blockMeanHash',
    'void',
    [],
    [   ['Mat', 'inputArr', '', []],
        ['Mat', 'outputArr', '', ['/O']],
        ['int', 'mode', 'BLOCK_MEAN_HASH_MODE_0', []]],
    'void']
ok: FUNC <void cv.img_hash..blockMeanHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG int mode=BLOCK_MEAN_HASH_MODE_0]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/img_hash_base.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
['class cv.img_hash.ImgHashBase', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.img_hash::.ImgHashBase : Algorithm, name: ImgHashBase, base: Algorithm

--- Incoming ---
[   'cv.img_hash.ImgHashBase.compute',
    'void',
    [],
    [['Mat', 'inputArr', '', []], ['Mat', 'outputArr', '', ['/O']]],
    'void']
ok: FUNC <void cv.img_hash.ImgHashBase.compute [ARG Mat inputArr=, ARG Mat outputArr=]>

--- Incoming ---
[   'cv.img_hash.ImgHashBase.compare',
    'double',
    ['/C'],
    [['Mat', 'hashOne', '', []], ['Mat', 'hashTwo', '', []]],
    'double']
ok: FUNC <double cv.img_hash.ImgHashBase.compare [ARG Mat hashOne=, ARG Mat hashTwo=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/color_moment_hash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
[   'class cv.img_hash.ColorMomentHash',
    ': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.ColorMomentHash : ImgHashBase, name: ColorMomentHash, base: ImgHashBase

--- Incoming ---
[   'cv.img_hash.ColorMomentHash.create',
    'Ptr_ColorMomentHash',
    ['/S'],
    [],
    'Ptr<ColorMomentHash>']
ok: FUNC <Ptr_ColorMomentHash cv.img_hash.ColorMomentHash.create []>

--- Incoming ---
[   'cv.img_hash.colorMomentHash',
    'void',
    [],
    [['Mat', 'inputArr', '', []], ['Mat', 'outputArr', '', ['/O']]],
    'void']
ok: FUNC <void cv.img_hash..colorMomentHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/phash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
['class cv.img_hash.PHash', ': cv::img_hash::ImgHashBase', [], [], None]
ok: class CLASS cv.img_hash::.PHash : ImgHashBase, name: PHash, base: ImgHashBase

--- Incoming ---
['cv.img_hash.PHash.create', 'Ptr_PHash', ['/S'], [], 'Ptr<PHash>']
ok: FUNC <Ptr_PHash cv.img_hash.PHash.create []>

--- Incoming ---
[   'cv.img_hash.pHash',
    'void',
    [],
    [['Mat', 'inputArr', '', []], ['Mat', 'outputArr', '', ['/O']]],
    'void']
ok: FUNC <void cv.img_hash..pHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/average_hash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
['class cv.img_hash.AverageHash', ': cv::img_hash::ImgHashBase', [], [], None]
ok: class CLASS cv.img_hash::.AverageHash : ImgHashBase, name: AverageHash, base: ImgHashBase

--- Incoming ---
[   'cv.img_hash.AverageHash.create',
    'Ptr_AverageHash',
    ['/S'],
    [],
    'Ptr<AverageHash>']
ok: FUNC <Ptr_AverageHash cv.img_hash.AverageHash.create []>

--- Incoming ---
[   'cv.img_hash.averageHash',
    'void',
    [],
    [['Mat', 'inputArr', '', []], ['Mat', 'outputArr', '', ['/O']]],
    'void']
ok: FUNC <void cv.img_hash..averageHash [ARG Mat inputArr=, ARG Mat outputArr=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/marr_hildreth_hash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
[   'class cv.img_hash.MarrHildrethHash',
    ': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.MarrHildrethHash : ImgHashBase, name: MarrHildrethHash, base: ImgHashBase

--- Incoming ---
['cv.img_hash.MarrHildrethHash.getAlpha', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.img_hash.MarrHildrethHash.getAlpha []>

--- Incoming ---
['cv.img_hash.MarrHildrethHash.getScale', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.img_hash.MarrHildrethHash.getScale []>

--- Incoming ---
[   'cv.img_hash.MarrHildrethHash.setKernelParam',
    'void',
    [],
    [['float', 'alpha', '', []], ['float', 'scale', '', []]],
    'void']
ok: FUNC <void cv.img_hash.MarrHildrethHash.setKernelParam [ARG float alpha=, ARG float scale=]>

--- Incoming ---
[   'cv.img_hash.MarrHildrethHash.create',
    'Ptr_MarrHildrethHash',
    ['/S'],
    [['float', 'alpha', '2.0f', []], ['float', 'scale', '1.0f', []]],
    'Ptr<MarrHildrethHash>']
ok: FUNC <Ptr_MarrHildrethHash cv.img_hash.MarrHildrethHash.create [ARG float alpha=2.0f, ARG float scale=1.0f]>

--- Incoming ---
[   'cv.img_hash.marrHildrethHash',
    'void',
    [],
    [   ['Mat', 'inputArr', '', []],
        ['Mat', 'outputArr', '', ['/O']],
        ['float', 'alpha', '2.0f', []],
        ['float', 'scale', '1.0f', []]],
    'void']
ok: FUNC <void cv.img_hash..marrHildrethHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG float alpha=2.0f, ARG float scale=1.0f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/img_hash/include/opencv2/img_hash/radial_variance_hash.hpp =====
Namespaces: ['cv', 'cv.img_hash']

--- Incoming ---
[   'class cv.img_hash.RadialVarianceHash',
    ': cv::img_hash::ImgHashBase',
    [],
    [],
    None]
ok: class CLASS cv.img_hash::.RadialVarianceHash : ImgHashBase, name: RadialVarianceHash, base: ImgHashBase

--- Incoming ---
[   'cv.img_hash.RadialVarianceHash.create',
    'Ptr_RadialVarianceHash',
    ['/S'],
    [['double', 'sigma', '1', []], ['int', 'numOfAngleLine', '180', []]],
    'Ptr<RadialVarianceHash>']
ok: FUNC <Ptr_RadialVarianceHash cv.img_hash.RadialVarianceHash.create [ARG double sigma=1, ARG int numOfAngleLine=180]>

--- Incoming ---
['cv.img_hash.RadialVarianceHash.getNumOfAngleLine', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.img_hash.RadialVarianceHash.getNumOfAngleLine []>

--- Incoming ---
['cv.img_hash.RadialVarianceHash.getSigma', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.img_hash.RadialVarianceHash.getSigma []>

--- Incoming ---
[   'cv.img_hash.RadialVarianceHash.setNumOfAngleLine',
    'void',
    [],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.img_hash.RadialVarianceHash.setNumOfAngleLine [ARG int value=]>

--- Incoming ---
[   'cv.img_hash.RadialVarianceHash.setSigma',
    'void',
    [],
    [['double', 'value', '', []]],
    'void']
ok: FUNC <void cv.img_hash.RadialVarianceHash.setSigma [ARG double value=]>

--- Incoming ---
[   'cv.img_hash.radialVarianceHash',
    'void',
    [],
    [   ['Mat', 'inputArr', '', []],
        ['Mat', 'outputArr', '', ['/O']],
        ['double', 'sigma', '1', []],
        ['int', 'numOfAngleLine', '180', []]],
    'void']
ok: FUNC <void cv.img_hash..radialVarianceHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG double sigma=1, ARG int numOfAngleLine=180]>


===== Generating... =====
CLASS cv::.Img_hash : 
[CONST BLOCK_MEAN_HASH_MODE_0=0, CONST BLOCK_MEAN_HASH_MODE_1=1]
FUNC <void cv.img_hash..blockMeanHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG int mode=BLOCK_MEAN_HASH_MODE_0]>
java: void blockMeanHash(Mat inputArr, Mat outputArr, int mode)
java: void blockMeanHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..colorMomentHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void colorMomentHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..pHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void pHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..averageHash [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void averageHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..marrHildrethHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG float alpha=2.0f, ARG float scale=1.0f]>
java: void marrHildrethHash(Mat inputArr, Mat outputArr, float alpha, float scale)
java: void marrHildrethHash(Mat inputArr, Mat outputArr, float alpha)
java: void marrHildrethHash(Mat inputArr, Mat outputArr)
FUNC <void cv.img_hash..radialVarianceHash [ARG Mat inputArr=, ARG Mat outputArr=, ARG double sigma=1, ARG int numOfAngleLine=180]>
java: void radialVarianceHash(Mat inputArr, Mat outputArr, double sigma, int numOfAngleLine)
java: void radialVarianceHash(Mat inputArr, Mat outputArr, double sigma)
java: void radialVarianceHash(Mat inputArr, Mat outputArr)
CLASS cv.img_hash::.AverageHash : ImgHashBase
FUNC <Ptr_AverageHash cv.img_hash.AverageHash.create []>
java: AverageHash create()
CLASS cv.img_hash::.BlockMeanHash : ImgHashBase
FUNC <void cv.img_hash.BlockMeanHash.setMode [ARG int mode=]>
java: void setMode(int mode)
FUNC <vector_double cv.img_hash.BlockMeanHash.getMean []>
java: MatOfDouble getMean()
FUNC <Ptr_BlockMeanHash cv.img_hash.BlockMeanHash.create [ARG int mode=BLOCK_MEAN_HASH_MODE_0]>
java: BlockMeanHash create(int mode)
java: BlockMeanHash create()
CLASS cv.img_hash::.ColorMomentHash : ImgHashBase
FUNC <Ptr_ColorMomentHash cv.img_hash.ColorMomentHash.create []>
java: ColorMomentHash create()
CLASS cv.img_hash::.ImgHashBase : Algorithm
FUNC <void cv.img_hash.ImgHashBase.compute [ARG Mat inputArr=, ARG Mat outputArr=]>
java: void compute(Mat inputArr, Mat outputArr)
FUNC <double cv.img_hash.ImgHashBase.compare [ARG Mat hashOne=, ARG Mat hashTwo=]>
java: double compare(Mat hashOne, Mat hashTwo)
CLASS cv.img_hash::.MarrHildrethHash : ImgHashBase
FUNC <float cv.img_hash.MarrHildrethHash.getAlpha []>
java: float getAlpha()
FUNC <float cv.img_hash.MarrHildrethHash.getScale []>
java: float getScale()
FUNC <void cv.img_hash.MarrHildrethHash.setKernelParam [ARG float alpha=, ARG float scale=]>
java: void setKernelParam(float alpha, float scale)
FUNC <Ptr_MarrHildrethHash cv.img_hash.MarrHildrethHash.create [ARG float alpha=2.0f, ARG float scale=1.0f]>
java: MarrHildrethHash create(float alpha, float scale)
java: MarrHildrethHash create(float alpha)
java: MarrHildrethHash create()
CLASS cv.img_hash::.PHash : ImgHashBase
FUNC <Ptr_PHash cv.img_hash.PHash.create []>
java: PHash create()
CLASS cv.img_hash::.RadialVarianceHash : ImgHashBase
FUNC <Ptr_RadialVarianceHash cv.img_hash.RadialVarianceHash.create [ARG double sigma=1, ARG int numOfAngleLine=180]>
java: RadialVarianceHash create(double sigma, int numOfAngleLine)
java: RadialVarianceHash create(double sigma)
java: RadialVarianceHash create()
FUNC <int cv.img_hash.RadialVarianceHash.getNumOfAngleLine []>
java: int getNumOfAngleLine()
FUNC <double cv.img_hash.RadialVarianceHash.getSigma []>
java: double getSigma()
FUNC <void cv.img_hash.RadialVarianceHash.setNumOfAngleLine [ARG int value=]>
java: void setNumOfAngleLine(int value)
FUNC <void cv.img_hash.RadialVarianceHash.setSigma [ARG double value=]>
java: void setSigma(double value)

=== MODULE: imgcodecs (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs) ===


Files (5):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/macosx.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/ios.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Imgcodecs : , name: Imgcodecs, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/macosx.h =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/macosx.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/ios.h =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/ios.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs.hpp =====
Namespaces: ['cv']

--- Incoming ---
[   'enum cv.ImreadModes',
    '',
    [],
    [   ['const cv.IMREAD_UNCHANGED', '-1', [], [], None, ''],
        ['const cv.IMREAD_GRAYSCALE', '0', [], [], None, ''],
        ['const cv.IMREAD_COLOR', '1', [], [], None, ''],
        ['const cv.IMREAD_ANYDEPTH', '2', [], [], None, ''],
        ['const cv.IMREAD_ANYCOLOR', '4', [], [], None, ''],
        ['const cv.IMREAD_LOAD_GDAL', '8', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_GRAYSCALE_2', '16', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_COLOR_2', '17', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_GRAYSCALE_4', '32', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_COLOR_4', '33', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_GRAYSCALE_8', '64', [], [], None, ''],
        ['const cv.IMREAD_REDUCED_COLOR_8', '65', [], [], None, ''],
        ['const cv.IMREAD_IGNORE_ORIENTATION', '128', [], [], None, '']],
    None]
ok: CONST IMREAD_UNCHANGED=-1
ok: CONST IMREAD_GRAYSCALE=0
ok: CONST IMREAD_COLOR=1
ok: CONST IMREAD_ANYDEPTH=2
ok: CONST IMREAD_ANYCOLOR=4
ok: CONST IMREAD_LOAD_GDAL=8
ok: CONST IMREAD_REDUCED_GRAYSCALE_2=16
ok: CONST IMREAD_REDUCED_COLOR_2=17
ok: CONST IMREAD_REDUCED_GRAYSCALE_4=32
ok: CONST IMREAD_REDUCED_COLOR_4=33
ok: CONST IMREAD_REDUCED_GRAYSCALE_8=64
ok: CONST IMREAD_REDUCED_COLOR_8=65
ok: CONST IMREAD_IGNORE_ORIENTATION=128

--- Incoming ---
[   'enum cv.ImwriteFlags',
    '',
    [],
    [   ['const cv.IMWRITE_JPEG_QUALITY', '1', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_PROGRESSIVE', '2', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_OPTIMIZE', '3', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_RST_INTERVAL', '4', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_LUMA_QUALITY', '5', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_CHROMA_QUALITY', '6', [], [], None, ''],
        ['const cv.IMWRITE_JPEG_SAMPLING_FACTOR', '7', [], [], None, ''],
        ['const cv.IMWRITE_PNG_COMPRESSION', '16', [], [], None, ''],
        ['const cv.IMWRITE_PNG_STRATEGY', '17', [], [], None, ''],
        ['const cv.IMWRITE_PNG_BILEVEL', '18', [], [], None, ''],
        ['const cv.IMWRITE_PXM_BINARY', '32', [], [], None, ''],
        ['const cv.IMWRITE_EXR_TYPE', '(3 << 4) + 0', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION', '(3 << 4) + 1', [], [], None, ''],
        [   'const cv.IMWRITE_EXR_DWA_COMPRESSION_LEVEL',
            '(3 << 4) + 2',
            [],
            [],
            None,
            ''],
        ['const cv.IMWRITE_WEBP_QUALITY', '64', [], [], None, ''],
        ['const cv.IMWRITE_HDR_COMPRESSION', '(5 << 4) + 0', [], [], None, ''],
        ['const cv.IMWRITE_PAM_TUPLETYPE', '128', [], [], None, ''],
        ['const cv.IMWRITE_TIFF_RESUNIT', '256', [], [], None, ''],
        ['const cv.IMWRITE_TIFF_XDPI', '257', [], [], None, ''],
        ['const cv.IMWRITE_TIFF_YDPI', '258', [], [], None, ''],
        ['const cv.IMWRITE_TIFF_COMPRESSION', '259', [], [], None, ''],
        [   'const cv.IMWRITE_JPEG2000_COMPRESSION_X1000',
            '272',
            [],
            [],
            None,
            '']],
    None]
ok: CONST IMWRITE_JPEG_QUALITY=1
ok: CONST IMWRITE_JPEG_PROGRESSIVE=2
ok: CONST IMWRITE_JPEG_OPTIMIZE=3
ok: CONST IMWRITE_JPEG_RST_INTERVAL=4
ok: CONST IMWRITE_JPEG_LUMA_QUALITY=5
ok: CONST IMWRITE_JPEG_CHROMA_QUALITY=6
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR=7
ok: CONST IMWRITE_PNG_COMPRESSION=16
ok: CONST IMWRITE_PNG_STRATEGY=17
ok: CONST IMWRITE_PNG_BILEVEL=18
ok: CONST IMWRITE_PXM_BINARY=32
ok: CONST IMWRITE_EXR_TYPE=(3 << 4) + 0
ok: CONST IMWRITE_EXR_COMPRESSION=(3 << 4) + 1
ok: CONST IMWRITE_EXR_DWA_COMPRESSION_LEVEL=(3 << 4) + 2
ok: CONST IMWRITE_WEBP_QUALITY=64
ok: CONST IMWRITE_HDR_COMPRESSION=(5 << 4) + 0
ok: CONST IMWRITE_PAM_TUPLETYPE=128
ok: CONST IMWRITE_TIFF_RESUNIT=256
ok: CONST IMWRITE_TIFF_XDPI=257
ok: CONST IMWRITE_TIFF_YDPI=258
ok: CONST IMWRITE_TIFF_COMPRESSION=259
ok: CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272

--- Incoming ---
[   'enum cv.ImwriteJPEGSamplingFactorParams',
    '',
    [],
    [   [   'const cv.IMWRITE_JPEG_SAMPLING_FACTOR_411',
            '0x411111',
            [],
            [],
            None,
            ''],
        [   'const cv.IMWRITE_JPEG_SAMPLING_FACTOR_420',
            '0x221111',
            [],
            [],
            None,
            ''],
        [   'const cv.IMWRITE_JPEG_SAMPLING_FACTOR_422',
            '0x211111',
            [],
            [],
            None,
            ''],
        [   'const cv.IMWRITE_JPEG_SAMPLING_FACTOR_440',
            '0x121111',
            [],
            [],
            None,
            ''],
        [   'const cv.IMWRITE_JPEG_SAMPLING_FACTOR_444',
            '0x111111',
            [],
            [],
            None,
            '']],
    None]
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR_411=0x411111
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR_420=0x221111
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR_422=0x211111
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR_440=0x121111
ok: CONST IMWRITE_JPEG_SAMPLING_FACTOR_444=0x111111

--- Incoming ---
[   'enum cv.ImwriteEXRTypeFlags',
    '',
    [],
    [   ['const cv.IMWRITE_EXR_TYPE_HALF', '1', [], [], None, ''],
        ['const cv.IMWRITE_EXR_TYPE_FLOAT', '2', [], [], None, '']],
    None]
ok: CONST IMWRITE_EXR_TYPE_HALF=1
ok: CONST IMWRITE_EXR_TYPE_FLOAT=2

--- Incoming ---
[   'enum cv.ImwriteEXRCompressionFlags',
    '',
    [],
    [   ['const cv.IMWRITE_EXR_COMPRESSION_NO', '0', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_RLE', '1', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_ZIPS', '2', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_ZIP', '3', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_PIZ', '4', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_PXR24', '5', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_B44', '6', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_B44A', '7', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_DWAA', '8', [], [], None, ''],
        ['const cv.IMWRITE_EXR_COMPRESSION_DWAB', '9', [], [], None, '']],
    None]
ok: CONST IMWRITE_EXR_COMPRESSION_NO=0
ok: CONST IMWRITE_EXR_COMPRESSION_RLE=1
ok: CONST IMWRITE_EXR_COMPRESSION_ZIPS=2
ok: CONST IMWRITE_EXR_COMPRESSION_ZIP=3
ok: CONST IMWRITE_EXR_COMPRESSION_PIZ=4
ok: CONST IMWRITE_EXR_COMPRESSION_PXR24=5
ok: CONST IMWRITE_EXR_COMPRESSION_B44=6
ok: CONST IMWRITE_EXR_COMPRESSION_B44A=7
ok: CONST IMWRITE_EXR_COMPRESSION_DWAA=8
ok: CONST IMWRITE_EXR_COMPRESSION_DWAB=9

--- Incoming ---
[   'enum cv.ImwritePNGFlags',
    '',
    [],
    [   ['const cv.IMWRITE_PNG_STRATEGY_DEFAULT', '0', [], [], None, ''],
        ['const cv.IMWRITE_PNG_STRATEGY_FILTERED', '1', [], [], None, ''],
        ['const cv.IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY', '2', [], [], None, ''],
        ['const cv.IMWRITE_PNG_STRATEGY_RLE', '3', [], [], None, ''],
        ['const cv.IMWRITE_PNG_STRATEGY_FIXED', '4', [], [], None, '']],
    None]
ok: CONST IMWRITE_PNG_STRATEGY_DEFAULT=0
ok: CONST IMWRITE_PNG_STRATEGY_FILTERED=1
ok: CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2
ok: CONST IMWRITE_PNG_STRATEGY_RLE=3
ok: CONST IMWRITE_PNG_STRATEGY_FIXED=4

--- Incoming ---
[   'enum cv.ImwritePAMFlags',
    '',
    [],
    [   ['const cv.IMWRITE_PAM_FORMAT_NULL', '0', [], [], None, ''],
        ['const cv.IMWRITE_PAM_FORMAT_BLACKANDWHITE', '1', [], [], None, ''],
        ['const cv.IMWRITE_PAM_FORMAT_GRAYSCALE', '2', [], [], None, ''],
        ['const cv.IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA', '3', [], [], None, ''],
        ['const cv.IMWRITE_PAM_FORMAT_RGB', '4', [], [], None, ''],
        ['const cv.IMWRITE_PAM_FORMAT_RGB_ALPHA', '5', [], [], None, '']],
    None]
ok: CONST IMWRITE_PAM_FORMAT_NULL=0
ok: CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3
ok: CONST IMWRITE_PAM_FORMAT_RGB=4
ok: CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5

--- Incoming ---
[   'enum cv.ImwriteHDRCompressionFlags',
    '',
    [],
    [   ['const cv.IMWRITE_HDR_COMPRESSION_NONE', '0', [], [], None, ''],
        ['const cv.IMWRITE_HDR_COMPRESSION_RLE', '1', [], [], None, '']],
    None]
ok: CONST IMWRITE_HDR_COMPRESSION_NONE=0
ok: CONST IMWRITE_HDR_COMPRESSION_RLE=1

--- Incoming ---
[   'cv.imread',
    'Mat',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'flags', 'IMREAD_COLOR', []]],
    'Mat']
ok: FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>

--- Incoming ---
[   'cv.imreadmulti',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['vector_Mat', 'mats', '', ['/O', '/Ref']],
        ['int', 'flags', 'IMREAD_ANYCOLOR', []]],
    'bool']
ok: FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>

--- Incoming ---
[   'cv.imreadmulti',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['vector_Mat', 'mats', '', ['/O', '/Ref']],
        ['int', 'start', '', []],
        ['int', 'count', '', []],
        ['int', 'flags', 'IMREAD_ANYCOLOR', []]],
    'bool']
ok: FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int start=, ARG int count=, ARG int flags=IMREAD_ANYCOLOR]>

--- Incoming ---
[   'cv.imcount',
    'size_t',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'flags', 'IMREAD_ANYCOLOR', []]],
    'size_t']
ok: FUNC <size_t cv..imcount [ARG String filename=, ARG int flags=IMREAD_ANYCOLOR]>

--- Incoming ---
[   'cv.imwrite',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['Mat', 'img', '', []],
        ['vector_int', 'params', 'std::vector<int>()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   'cv.imwritemulti',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['vector_Mat', 'img', '', []],
        ['vector_int', 'params', 'std::vector<int>()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..imwritemulti [ARG String filename=, ARG vector_Mat img=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   'cv.imdecode',
    'Mat',
    [],
    [['Mat', 'buf', '', []], ['int', 'flags', '', []]],
    'Mat']
ok: FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>

--- Incoming ---
[   'cv.imdecodemulti',
    'bool',
    [],
    [   ['Mat', 'buf', '', []],
        ['int', 'flags', '', []],
        ['vector_Mat', 'mats', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv..imdecodemulti [ARG Mat buf=, ARG int flags=, ARG vector_Mat mats=]>

--- Incoming ---
[   'cv.imencode',
    'bool',
    [],
    [   ['String', 'ext', '', ['/C', '/Ref']],
        ['Mat', 'img', '', []],
        ['vector_uchar', 'buf', '', ['/O', '/Ref']],
        ['vector_int', 'params', 'std::vector<int>()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   'cv.haveImageReader',
    'bool',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..haveImageReader [ARG String filename=]>

--- Incoming ---
[   'cv.haveImageWriter',
    'bool',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..haveImageWriter [ARG String filename=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp =====
Namespaces: ['cv']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp


===== Generating... =====
CLASS cv::.Imgcodecs : 
[CONST IMREAD_UNCHANGED=-1, CONST IMREAD_GRAYSCALE=0, CONST IMREAD_COLOR=1, CONST IMREAD_ANYDEPTH=2, CONST IMREAD_ANYCOLOR=4, CONST IMREAD_LOAD_GDAL=8, CONST IMREAD_REDUCED_GRAYSCALE_2=16, CONST IMREAD_REDUCED_COLOR_2=17, CONST IMREAD_REDUCED_GRAYSCALE_4=32, CONST IMREAD_REDUCED_COLOR_4=33, CONST IMREAD_REDUCED_GRAYSCALE_8=64, CONST IMREAD_REDUCED_COLOR_8=65, CONST IMREAD_IGNORE_ORIENTATION=128]
[CONST IMWRITE_EXR_COMPRESSION_NO=0, CONST IMWRITE_EXR_COMPRESSION_RLE=1, CONST IMWRITE_EXR_COMPRESSION_ZIPS=2, CONST IMWRITE_EXR_COMPRESSION_ZIP=3, CONST IMWRITE_EXR_COMPRESSION_PIZ=4, CONST IMWRITE_EXR_COMPRESSION_PXR24=5, CONST IMWRITE_EXR_COMPRESSION_B44=6, CONST IMWRITE_EXR_COMPRESSION_B44A=7, CONST IMWRITE_EXR_COMPRESSION_DWAA=8, CONST IMWRITE_EXR_COMPRESSION_DWAB=9]
[CONST IMWRITE_EXR_TYPE_HALF=1, CONST IMWRITE_EXR_TYPE_FLOAT=2]
[CONST IMWRITE_JPEG_QUALITY=1, CONST IMWRITE_JPEG_PROGRESSIVE=2, CONST IMWRITE_JPEG_OPTIMIZE=3, CONST IMWRITE_JPEG_RST_INTERVAL=4, CONST IMWRITE_JPEG_LUMA_QUALITY=5, CONST IMWRITE_JPEG_CHROMA_QUALITY=6, CONST IMWRITE_JPEG_SAMPLING_FACTOR=7, CONST IMWRITE_PNG_COMPRESSION=16, CONST IMWRITE_PNG_STRATEGY=17, CONST IMWRITE_PNG_BILEVEL=18, CONST IMWRITE_PXM_BINARY=32, CONST IMWRITE_EXR_TYPE=(3 << 4) + 0, CONST IMWRITE_EXR_COMPRESSION=(3 << 4) + 1, CONST IMWRITE_EXR_DWA_COMPRESSION_LEVEL=(3 << 4) + 2, CONST IMWRITE_WEBP_QUALITY=64, CONST IMWRITE_HDR_COMPRESSION=(5 << 4) + 0, CONST IMWRITE_PAM_TUPLETYPE=128, CONST IMWRITE_TIFF_RESUNIT=256, CONST IMWRITE_TIFF_XDPI=257, CONST IMWRITE_TIFF_YDPI=258, CONST IMWRITE_TIFF_COMPRESSION=259, CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272]
[CONST IMWRITE_HDR_COMPRESSION_NONE=0, CONST IMWRITE_HDR_COMPRESSION_RLE=1]
[CONST IMWRITE_JPEG_SAMPLING_FACTOR_411=0x411111, CONST IMWRITE_JPEG_SAMPLING_FACTOR_420=0x221111, CONST IMWRITE_JPEG_SAMPLING_FACTOR_422=0x211111, CONST IMWRITE_JPEG_SAMPLING_FACTOR_440=0x121111, CONST IMWRITE_JPEG_SAMPLING_FACTOR_444=0x111111]
[CONST IMWRITE_PAM_FORMAT_NULL=0, CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1, CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2, CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3, CONST IMWRITE_PAM_FORMAT_RGB=4, CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5]
[CONST IMWRITE_PNG_STRATEGY_DEFAULT=0, CONST IMWRITE_PNG_STRATEGY_FILTERED=1, CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2, CONST IMWRITE_PNG_STRATEGY_RLE=3, CONST IMWRITE_PNG_STRATEGY_FIXED=4]
FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>
java: Mat imread(String filename, int flags)
java: Mat imread(String filename)
FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>
java: boolean imreadmulti(String filename, List<Mat> mats, int flags)
java: boolean imreadmulti(String filename, List<Mat> mats)
FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int start=, ARG int count=, ARG int flags=IMREAD_ANYCOLOR]>
java: boolean imreadmulti(String filename, List<Mat> mats, int start, int count, int flags)
java: boolean imreadmulti(String filename, List<Mat> mats, int start, int count)
FUNC <size_t cv..imcount [ARG String filename=, ARG int flags=IMREAD_ANYCOLOR]>
java: long imcount(String filename, int flags)
java: long imcount(String filename)
FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>
java: boolean imwrite(String filename, Mat img, MatOfInt params)
java: boolean imwrite(String filename, Mat img)
FUNC <bool cv..imwritemulti [ARG String filename=, ARG vector_Mat img=, ARG vector_int params=std::vector<int>()]>
java: boolean imwritemulti(String filename, List<Mat> img, MatOfInt params)
java: boolean imwritemulti(String filename, List<Mat> img)
FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>
java: Mat imdecode(Mat buf, int flags)
FUNC <bool cv..imdecodemulti [ARG Mat buf=, ARG int flags=, ARG vector_Mat mats=]>
java: boolean imdecodemulti(Mat buf, int flags, List<Mat> mats)
FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>
java: boolean imencode(String ext, Mat img, MatOfByte buf, MatOfInt params)
java: boolean imencode(String ext, Mat img, MatOfByte buf)
FUNC <bool cv..haveImageReader [ARG String filename=]>
java: boolean haveImageReader(String filename)
FUNC <bool cv..haveImageWriter [ARG String filename=]>
java: boolean haveImageWriter(String filename)

=== MODULE: text (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text) ===


Files (5):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/swt_text_detection.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/erfilter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/ocr.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/textDetector.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Text : , name: Text, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/swt_text_detection.hpp =====
Namespaces: ['cv', 'cv.text']

--- Incoming ---
[   'cv.text.detectTextSWT',
    'void',
    [],
    [   ['Mat', 'input', '', []],
        ['vector_Rect', 'result', '', ['/O', '/Ref']],
        ['bool', 'dark_on_light', '', []],
        ['Mat', 'draw', 'Mat()', ['/Ref', '/O']],
        ['Mat', 'chainBBs', 'Mat()', ['/Ref', '/O']]],
    'void']
ok: FUNC <void cv.text..detectTextSWT [ARG Mat input=, ARG vector_Rect result=, ARG bool dark_on_light=, ARG Mat draw=Mat(), ARG Mat chainBBs=Mat()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/erfilter.hpp =====
Namespaces: ['cv', 'cv.text']

--- Incoming ---
['class cv.text.ERFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.text::.ERFilter : Algorithm, name: ERFilter, base: Algorithm

--- Incoming ---
['class cv.text.ERFilter.Callback', '', [], [], None]
ok: class CLASS cv.text::ERFilter.ERFilter_Callback : , name: ERFilter_Callback, base: 

--- Incoming ---
[   'cv.text.createERFilterNM1',
    'Ptr_ERFilter',
    [],
    [   ['Ptr_ERFilter_Callback', 'cb', '', ['/C', '/Ref']],
        ['int', 'thresholdDelta', '1', []],
        ['float', 'minArea', '(float)0.00025', []],
        ['float', 'maxArea', '(float)0.13', []],
        ['float', 'minProbability', '(float)0.4', []],
        ['bool', 'nonMaxSuppression', 'true', []],
        ['float', 'minProbabilityDiff', '(float)0.1', []]],
    'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG Ptr_ERFilter_Callback cb=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>

--- Incoming ---
[   'cv.text.createERFilterNM2',
    'Ptr_ERFilter',
    [],
    [   ['Ptr_ERFilter_Callback', 'cb', '', ['/C', '/Ref']],
        ['float', 'minProbability', '(float)0.3', []]],
    'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG Ptr_ERFilter_Callback cb=, ARG float minProbability=(float)0.3]>

--- Incoming ---
[   'cv.text.createERFilterNM1',
    'Ptr_ERFilter',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'thresholdDelta', '1', []],
        ['float', 'minArea', '(float)0.00025', []],
        ['float', 'maxArea', '(float)0.13', []],
        ['float', 'minProbability', '(float)0.4', []],
        ['bool', 'nonMaxSuppression', 'true', []],
        ['float', 'minProbabilityDiff', '(float)0.1', []]],
    'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG String filename=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>

--- Incoming ---
[   'cv.text.createERFilterNM2',
    'Ptr_ERFilter',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['float', 'minProbability', '(float)0.3', []]],
    'Ptr<ERFilter>']
ok: FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG String filename=, ARG float minProbability=(float)0.3]>

--- Incoming ---
[   'cv.text.loadClassifierNM1',
    'Ptr_ERFilter_Callback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'Ptr<ERFilter::Callback>']
ok: FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM1 [ARG String filename=]>

--- Incoming ---
[   'cv.text.loadClassifierNM2',
    'Ptr_ERFilter_Callback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'Ptr<ERFilter::Callback>']
ok: FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM2 [ARG String filename=]>

--- Incoming ---
[   'enum cv.text.<unnamed>',
    '',
    [],
    [   ['const cv.text.ERFILTER_NM_RGBLGrad', '0', [], [], None, ''],
        ['const cv.text.ERFILTER_NM_IHSGrad', '1', [], [], None, '']],
    None]
ok: CONST ERFILTER_NM_RGBLGrad=0
ok: CONST ERFILTER_NM_IHSGrad=1

--- Incoming ---
[   'cv.text.computeNMChannels',
    'void',
    [],
    [   ['Mat', '_src', '', []],
        ['vector_Mat', '_channels', '', ['/O', '/O']],
        ['int', '_mode', 'ERFILTER_NM_RGBLGrad', []]],
    'void']
ok: FUNC <void cv.text..computeNMChannels [ARG Mat _src=, ARG vector_Mat _channels=, ARG int _mode=ERFILTER_NM_RGBLGrad]>

--- Incoming ---
[   'enum cv.text.erGrouping_Modes',
    '',
    [],
    [   ['const cv.text.ERGROUPING_ORIENTATION_HORIZ', '0', [], [], None, ''],
        ['const cv.text.ERGROUPING_ORIENTATION_ANY', '1', [], [], None, '']],
    None]
ok: CONST ERGROUPING_ORIENTATION_HORIZ=0
ok: CONST ERGROUPING_ORIENTATION_ANY=1

--- Incoming ---
[   'cv.text.erGrouping',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'channel', '', []],
        ['vector_vector_Point', 'regions', '', []],
        ['vector_Rect', 'groups_rects', '', ['/O', '/Ref']],
        ['int', 'method', 'ERGROUPING_ORIENTATION_HORIZ', []],
        ['String', 'filename', 'String()', ['/C', '/Ref']],
        ['float', 'minProbablity', '(float)0.5', []]],
    'void']
ok: FUNC <void cv.text..erGrouping [ARG Mat image=, ARG Mat channel=, ARG vector_vector_Point regions=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbablity=(float)0.5]>

--- Incoming ---
[   'cv.text.detectRegions',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Ptr_ERFilter', 'er_filter1', '', ['/C', '/Ref']],
        ['Ptr_ERFilter', 'er_filter2', '', ['/C', '/Ref']],
        ['vector_vector_Point', 'regions', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_vector_Point regions=]>

--- Incoming ---
[   'cv.text.detectRegions',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Ptr_ERFilter', 'er_filter1', '', ['/C', '/Ref']],
        ['Ptr_ERFilter', 'er_filter2', '', ['/C', '/Ref']],
        ['vector_Rect', 'groups_rects', '', ['/O', '/Ref']],
        ['int', 'method', 'ERGROUPING_ORIENTATION_HORIZ', []],
        ['String', 'filename', 'String()', ['/C', '/Ref']],
        ['float', 'minProbability', '(float)0.5', []]],
    'void']
ok: FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbability=(float)0.5]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/ocr.hpp =====
Namespaces: ['cv', 'cv.text']

--- Incoming ---
[   'enum cv.text.<unnamed>',
    '',
    [],
    [   ['const cv.text.OCR_LEVEL_WORD', '0', [], [], None, ''],
        ['const cv.text.OCR_LEVEL_TEXTLINE', '1', [], [], None, '']],
    None]
ok: CONST OCR_LEVEL_WORD=0
ok: CONST OCR_LEVEL_TEXTLINE=1

--- Incoming ---
[   'enum cv.text.page_seg_mode',
    '',
    [],
    [   ['const cv.text.PSM_OSD_ONLY', '0', [], [], None, ''],
        ['const cv.text.PSM_AUTO_OSD', '1', [], [], None, ''],
        ['const cv.text.PSM_AUTO_ONLY', '2', [], [], None, ''],
        ['const cv.text.PSM_AUTO', '3', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_COLUMN', '4', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_BLOCK_VERT_TEXT', '5', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_BLOCK', '6', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_LINE', '7', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_WORD', '8', [], [], None, ''],
        ['const cv.text.PSM_CIRCLE_WORD', '9', [], [], None, ''],
        ['const cv.text.PSM_SINGLE_CHAR', '10', [], [], None, '']],
    None]
ok: CONST PSM_OSD_ONLY=0
ok: CONST PSM_AUTO_OSD=1
ok: CONST PSM_AUTO_ONLY=2
ok: CONST PSM_AUTO=3
ok: CONST PSM_SINGLE_COLUMN=4
ok: CONST PSM_SINGLE_BLOCK_VERT_TEXT=5
ok: CONST PSM_SINGLE_BLOCK=6
ok: CONST PSM_SINGLE_LINE=7
ok: CONST PSM_SINGLE_WORD=8
ok: CONST PSM_CIRCLE_WORD=9
ok: CONST PSM_SINGLE_CHAR=10

--- Incoming ---
[   'enum cv.text.ocr_engine_mode',
    '',
    [],
    [   ['const cv.text.OEM_TESSERACT_ONLY', '0', [], [], None, ''],
        ['const cv.text.OEM_CUBE_ONLY', '1', [], [], None, ''],
        ['const cv.text.OEM_TESSERACT_CUBE_COMBINED', '2', [], [], None, ''],
        ['const cv.text.OEM_DEFAULT', '3', [], [], None, '']],
    None]
ok: CONST OEM_TESSERACT_ONLY=0
ok: CONST OEM_CUBE_ONLY=1
ok: CONST OEM_TESSERACT_CUBE_COMBINED=2
ok: CONST OEM_DEFAULT=3

--- Incoming ---
['class cv.text.BaseOCR', '', [], [], None]
ok: class CLASS cv.text::.BaseOCR : , name: BaseOCR, base: 

--- Incoming ---
['class cv.text.OCRTesseract', ': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRTesseract : BaseOCR, name: OCRTesseract, base: BaseOCR

--- Incoming ---
[   'cv.text.OCRTesseract.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRTesseract.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'mask', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRTesseract.setWhiteList',
    'void',
    ['/V', '/PV'],
    [['String', 'char_whitelist', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.text.OCRTesseract.setWhiteList [ARG String char_whitelist=]>

--- Incoming ---
[   'cv.text.OCRTesseract.create',
    'Ptr_OCRTesseract',
    ['/S'],
    [   ['c_string', 'datapath', '0', ['/C']],
        ['c_string', 'language', '0', ['/C']],
        ['c_string', 'char_whitelist', '0', ['/C']],
        ['int', 'oem', 'OEM_DEFAULT', []],
        ['int', 'psmode', 'PSM_AUTO', []]],
    'Ptr<OCRTesseract>']
ok: FUNC <Ptr_OCRTesseract cv.text.OCRTesseract.create [ARG c_string datapath=0, ARG c_string language=0, ARG c_string char_whitelist=0, ARG int oem=OEM_DEFAULT, ARG int psmode=PSM_AUTO]>

--- Incoming ---
[   'enum cv.text.decoder_mode',
    '',
    [],
    [['const cv.text.OCR_DECODER_VITERBI', '0', [], [], None, '']],
    None]
ok: CONST OCR_DECODER_VITERBI=0

--- Incoming ---
[   'enum cv.text.classifier_type',
    '',
    [],
    [   ['const cv.text.OCR_KNN_CLASSIFIER', '0', [], [], None, ''],
        ['const cv.text.OCR_CNN_CLASSIFIER', '1', [], [], None, '']],
    None]
ok: CONST OCR_KNN_CLASSIFIER=0
ok: CONST OCR_CNN_CLASSIFIER=1

--- Incoming ---
['class cv.text.OCRHMMDecoder', ': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRHMMDecoder : BaseOCR, name: OCRHMMDecoder, base: BaseOCR

--- Incoming ---
['class cv.text.OCRHMMDecoder.ClassifierCallback', '', [], [], None]
ok: class CLASS cv.text::OCRHMMDecoder.OCRHMMDecoder_ClassifierCallback : , name: OCRHMMDecoder_ClassifierCallback, base: 

--- Incoming ---
[   'cv.text.OCRHMMDecoder.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRHMMDecoder.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'mask', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRHMMDecoder.create',
    'Ptr_OCRHMMDecoder',
    ['/S'],
    [   ['Ptr_OCRHMMDecoder_ClassifierCallback', 'classifier', '', ['/C']],
        ['String', 'vocabulary', '', ['/C', '/Ref']],
        ['Mat', 'transition_probabilities_table', '', []],
        ['Mat', 'emission_probabilities_table', '', []],
        ['int', 'mode', 'OCR_DECODER_VITERBI', []]],
    'Ptr<OCRHMMDecoder>']
ok: FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG Ptr_OCRHMMDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI]>

--- Incoming ---
[   'cv.text.OCRHMMDecoder.create',
    'Ptr_OCRHMMDecoder',
    ['/S'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['String', 'vocabulary', '', ['/C', '/Ref']],
        ['Mat', 'transition_probabilities_table', '', []],
        ['Mat', 'emission_probabilities_table', '', []],
        ['int', 'mode', 'OCR_DECODER_VITERBI', []],
        ['int', 'classifier', 'OCR_KNN_CLASSIFIER', []]],
    'Ptr<OCRHMMDecoder>']
ok: FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int classifier=OCR_KNN_CLASSIFIER]>

--- Incoming ---
[   'cv.text.loadOCRHMMClassifierNM',
    'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierNM [ARG String filename=]>

--- Incoming ---
[   'cv.text.loadOCRHMMClassifierCNN',
    'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierCNN [ARG String filename=]>

--- Incoming ---
[   'cv.text.loadOCRHMMClassifier',
    'Ptr_OCRHMMDecoder_ClassifierCallback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']], ['int', 'classifier', '', []]],
    'Ptr<OCRHMMDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifier [ARG String filename=, ARG int classifier=]>

--- Incoming ---
[   'cv.text.createOCRHMMTransitionsTable',
    'Mat',
    [],
    [   ['String', 'vocabulary', '', ['/C', '/Ref']],
        ['vector_String', 'lexicon', '', ['/Ref']]],
    'Mat']
ok: FUNC <Mat cv.text..createOCRHMMTransitionsTable [ARG String vocabulary=, ARG vector_String lexicon=]>

--- Incoming ---
['class cv.text.OCRBeamSearchDecoder', ': cv::text::BaseOCR', [], [], None]
ok: class CLASS cv.text::.OCRBeamSearchDecoder : BaseOCR, name: OCRBeamSearchDecoder, base: BaseOCR

--- Incoming ---
['class cv.text.OCRBeamSearchDecoder.ClassifierCallback', '', [], [], None]
ok: class CLASS cv.text::OCRBeamSearchDecoder.OCRBeamSearchDecoder_ClassifierCallback : , name: OCRBeamSearchDecoder_ClassifierCallback, base: 

--- Incoming ---
[   'cv.text.OCRBeamSearchDecoder.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRBeamSearchDecoder.run',
    'String',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'mask', '', []],
        ['int', 'min_confidence', '', []],
        ['int', 'component_level', '0', []]],
    'String']
ok: FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>

--- Incoming ---
[   'cv.text.OCRBeamSearchDecoder.create',
    'Ptr_OCRBeamSearchDecoder',
    ['/S'],
    [   [   'Ptr_OCRBeamSearchDecoder_ClassifierCallback',
            'classifier',
            '',
            ['/C']],
        ['string', 'vocabulary', '', ['/C', '/Ref']],
        ['Mat', 'transition_probabilities_table', '', []],
        ['Mat', 'emission_probabilities_table', '', []],
        ['text_decoder_mode', 'mode', 'OCR_DECODER_VITERBI', []],
        ['int', 'beam_size', '500', []]],
    'Ptr<OCRBeamSearchDecoder>']
ok: FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG Ptr_OCRBeamSearchDecoder_ClassifierCallback classifier=, ARG string vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG text_decoder_mode mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>

--- Incoming ---
[   'cv.text.loadOCRBeamSearchClassifierCNN',
    'Ptr_OCRBeamSearchDecoder_ClassifierCallback',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'Ptr<OCRBeamSearchDecoder::ClassifierCallback>']
ok: FUNC <Ptr_OCRBeamSearchDecoder_ClassifierCallback cv.text..loadOCRBeamSearchClassifierCNN [ARG String filename=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/text/include/opencv2/text/textDetector.hpp =====
Namespaces: ['cv', 'cv.text']

--- Incoming ---
['class cv.text.TextDetector', '', [], [], None]
ok: class CLASS cv.text::.TextDetector : , name: TextDetector, base: 

--- Incoming ---
[   'cv.text.TextDetector.detect',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'inputImage', '', []],
        ['vector_Rect', 'Bbox', '', ['/O', '/Ref']],
        ['vector_float', 'confidence', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.text.TextDetector.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>

--- Incoming ---
['class cv.text.TextDetectorCNN', ': cv::text::TextDetector', [], [], None]
ok: class CLASS cv.text::.TextDetectorCNN : TextDetector, name: TextDetectorCNN, base: TextDetector

--- Incoming ---
[   'cv.text.TextDetectorCNN.detect',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'inputImage', '', []],
        ['vector_Rect', 'Bbox', '', ['/O', '/Ref']],
        ['vector_float', 'confidence', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.text.TextDetectorCNN.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>

--- Incoming ---
[   'cv.text.TextDetectorCNN.create',
    'Ptr_TextDetectorCNN',
    ['/S'],
    [   ['String', 'modelArchFilename', '', ['/C', '/Ref']],
        ['String', 'modelWeightsFilename', '', ['/C', '/Ref']]],
    'Ptr<TextDetectorCNN>']
ok: FUNC <Ptr_TextDetectorCNN cv.text.TextDetectorCNN.create [ARG String modelArchFilename=, ARG String modelWeightsFilename=]>


===== Generating... =====
CLASS cv::.Text : 
[CONST ERFILTER_NM_RGBLGrad=0, CONST ERFILTER_NM_IHSGrad=1, CONST OCR_LEVEL_WORD=0, CONST OCR_LEVEL_TEXTLINE=1]
[CONST OCR_KNN_CLASSIFIER=0, CONST OCR_CNN_CLASSIFIER=1]
[CONST OCR_DECODER_VITERBI=0]
[CONST ERGROUPING_ORIENTATION_HORIZ=0, CONST ERGROUPING_ORIENTATION_ANY=1]
[CONST OEM_TESSERACT_ONLY=0, CONST OEM_CUBE_ONLY=1, CONST OEM_TESSERACT_CUBE_COMBINED=2, CONST OEM_DEFAULT=3]
[CONST PSM_OSD_ONLY=0, CONST PSM_AUTO_OSD=1, CONST PSM_AUTO_ONLY=2, CONST PSM_AUTO=3, CONST PSM_SINGLE_COLUMN=4, CONST PSM_SINGLE_BLOCK_VERT_TEXT=5, CONST PSM_SINGLE_BLOCK=6, CONST PSM_SINGLE_LINE=7, CONST PSM_SINGLE_WORD=8, CONST PSM_CIRCLE_WORD=9, CONST PSM_SINGLE_CHAR=10]
FUNC <void cv.text..detectTextSWT [ARG Mat input=, ARG vector_Rect result=, ARG bool dark_on_light=, ARG Mat draw=Mat(), ARG Mat chainBBs=Mat()]>
java: void detectTextSWT(Mat input, MatOfRect result, boolean dark_on_light, Mat draw, Mat chainBBs)
java: void detectTextSWT(Mat input, MatOfRect result, boolean dark_on_light, Mat draw)
java: void detectTextSWT(Mat input, MatOfRect result, boolean dark_on_light)
FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG Ptr_ERFilter_Callback cb=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression, float minProbabilityDiff)
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression)
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta, float minArea, float maxArea, float minProbability)
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta, float minArea, float maxArea)
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta, float minArea)
java: ERFilter createERFilterNM1(ERFilter_Callback cb, int thresholdDelta)
java: ERFilter createERFilterNM1(ERFilter_Callback cb)
FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG Ptr_ERFilter_Callback cb=, ARG float minProbability=(float)0.3]>
java: ERFilter createERFilterNM2(ERFilter_Callback cb, float minProbability)
java: ERFilter createERFilterNM2(ERFilter_Callback cb)
FUNC <Ptr_ERFilter cv.text..createERFilterNM1 [ARG String filename=, ARG int thresholdDelta=1, ARG float minArea=(float)0.00025, ARG float maxArea=(float)0.13, ARG float minProbability=(float)0.4, ARG bool nonMaxSuppression=true, ARG float minProbabilityDiff=(float)0.1]>
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression, float minProbabilityDiff)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability, boolean nonMaxSuppression)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea, float minProbability)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea, float maxArea)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta, float minArea)
java: ERFilter createERFilterNM1(String filename, int thresholdDelta)
java: ERFilter createERFilterNM1(String filename)
FUNC <Ptr_ERFilter cv.text..createERFilterNM2 [ARG String filename=, ARG float minProbability=(float)0.3]>
java: ERFilter createERFilterNM2(String filename, float minProbability)
java: ERFilter createERFilterNM2(String filename)
FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM1 [ARG String filename=]>
java: ERFilter_Callback loadClassifierNM1(String filename)
FUNC <Ptr_ERFilter_Callback cv.text..loadClassifierNM2 [ARG String filename=]>
java: ERFilter_Callback loadClassifierNM2(String filename)
FUNC <void cv.text..computeNMChannels [ARG Mat _src=, ARG vector_Mat _channels=, ARG int _mode=ERFILTER_NM_RGBLGrad]>
java: void computeNMChannels(Mat _src, List<Mat> _channels, int _mode)
java: void computeNMChannels(Mat _src, List<Mat> _channels)
FUNC <void cv.text..erGrouping [ARG Mat image=, ARG Mat channel=, ARG vector_vector_Point regions=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbablity=(float)0.5]>
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method, String filename, float minProbablity)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method, String filename)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects, int method)
java: void erGrouping(Mat image, Mat channel, List<MatOfPoint> regions, MatOfRect groups_rects)
FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_vector_Point regions=]>
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, List<MatOfPoint> regions)
FUNC <void cv.text..detectRegions [ARG Mat image=, ARG Ptr_ERFilter er_filter1=, ARG Ptr_ERFilter er_filter2=, ARG vector_Rect groups_rects=, ARG int method=ERGROUPING_ORIENTATION_HORIZ, ARG String filename=String(), ARG float minProbability=(float)0.5]>
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method, String filename, float minProbability)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method, String filename)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects, int method)
java: void detectRegions(Mat image, ERFilter er_filter1, ERFilter er_filter2, MatOfRect groups_rects)
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierNM [ARG String filename=]>
java: OCRHMMDecoder_ClassifierCallback loadOCRHMMClassifierNM(String filename)
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifierCNN [ARG String filename=]>
java: OCRHMMDecoder_ClassifierCallback loadOCRHMMClassifierCNN(String filename)
FUNC <Ptr_OCRHMMDecoder_ClassifierCallback cv.text..loadOCRHMMClassifier [ARG String filename=, ARG int classifier=]>
java: OCRHMMDecoder_ClassifierCallback loadOCRHMMClassifier(String filename, int classifier)
FUNC <Mat cv.text..createOCRHMMTransitionsTable [ARG String vocabulary=, ARG vector_String lexicon=]>
java: Mat createOCRHMMTransitionsTable(String vocabulary, List<String> lexicon)
FUNC <Ptr_OCRBeamSearchDecoder_ClassifierCallback cv.text..loadOCRBeamSearchClassifierCNN [ARG String filename=]>
java: OCRBeamSearchDecoder_ClassifierCallback loadOCRBeamSearchClassifierCNN(String filename)
CLASS cv.text::.BaseOCR : 
CLASS cv.text::.ERFilter : Algorithm
CLASS cv.text::ERFilter.ERFilter_Callback : 
CLASS cv.text::.OCRBeamSearchDecoder : BaseOCR
FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
FUNC <String cv.text.OCRBeamSearchDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <Ptr_OCRBeamSearchDecoder cv.text.OCRBeamSearchDecoder.create [ARG Ptr_OCRBeamSearchDecoder_ClassifierCallback classifier=, ARG string vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG text_decoder_mode mode=OCR_DECODER_VITERBI, ARG int beam_size=500]>
java: OCRBeamSearchDecoder create(OCRBeamSearchDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode, int beam_size)
java: OCRBeamSearchDecoder create(OCRBeamSearchDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode)
java: OCRBeamSearchDecoder create(OCRBeamSearchDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table)
CLASS cv.text::OCRBeamSearchDecoder.OCRBeamSearchDecoder_ClassifierCallback : 
CLASS cv.text::.OCRHMMDecoder : BaseOCR
FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
FUNC <String cv.text.OCRHMMDecoder.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG Ptr_OCRHMMDecoder_ClassifierCallback classifier=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI]>
java: OCRHMMDecoder create(OCRHMMDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode)
java: OCRHMMDecoder create(OCRHMMDecoder_ClassifierCallback classifier, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table)
FUNC <Ptr_OCRHMMDecoder cv.text.OCRHMMDecoder.create [ARG String filename=, ARG String vocabulary=, ARG Mat transition_probabilities_table=, ARG Mat emission_probabilities_table=, ARG int mode=OCR_DECODER_VITERBI, ARG int classifier=OCR_KNN_CLASSIFIER]>
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode, int classifier)
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table, int mode)
java: OCRHMMDecoder create(String filename, String vocabulary, Mat transition_probabilities_table, Mat emission_probabilities_table)
CLASS cv.text::OCRHMMDecoder.OCRHMMDecoder_ClassifierCallback : 
CLASS cv.text::.OCRTesseract : BaseOCR
FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, int min_confidence, int component_level)
java: String run(Mat image, int min_confidence)
FUNC <String cv.text.OCRTesseract.run [ARG Mat image=, ARG Mat mask=, ARG int min_confidence=, ARG int component_level=0]>
java: String run(Mat image, Mat mask, int min_confidence, int component_level)
java: String run(Mat image, Mat mask, int min_confidence)
FUNC <void cv.text.OCRTesseract.setWhiteList [ARG String char_whitelist=]>
java: void setWhiteList(String char_whitelist)
FUNC <Ptr_OCRTesseract cv.text.OCRTesseract.create [ARG c_string datapath=0, ARG c_string language=0, ARG c_string char_whitelist=0, ARG int oem=OEM_DEFAULT, ARG int psmode=PSM_AUTO]>
java: OCRTesseract create(String datapath, String language, String char_whitelist, int oem, int psmode)
java: OCRTesseract create(String datapath, String language, String char_whitelist, int oem)
java: OCRTesseract create(String datapath, String language, String char_whitelist)
java: OCRTesseract create(String datapath, String language)
java: OCRTesseract create(String datapath)
java: OCRTesseract create()
CLASS cv.text::.TextDetector : 
FUNC <void cv.text.TextDetector.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>
java: void detect(Mat inputImage, MatOfRect Bbox, MatOfFloat confidence)
CLASS cv.text::.TextDetectorCNN : TextDetector
FUNC <void cv.text.TextDetectorCNN.detect [ARG Mat inputImage=, ARG vector_Rect Bbox=, ARG vector_float confidence=]>
java: void detect(Mat inputImage, MatOfRect Bbox, MatOfFloat confidence)
FUNC <Ptr_TextDetectorCNN cv.text.TextDetectorCNN.create [ARG String modelArchFilename=, ARG String modelWeightsFilename=]>
java: TextDetectorCNN create(String modelArchFilename, String modelWeightsFilename)

=== MODULE: videoio (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio) ===


Files (6):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/cap_ios.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio_c.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/registry.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/doc/hwaccel.doc.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Videoio : , name: Videoio, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/cap_ios.h =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/cap_ios.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio_c.h =====
Namespaces: ['']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio_c.h


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio.hpp =====
Namespaces: ['', 'cv', 'cv.internal']

--- Incoming ---
[   'enum cv.VideoCaptureAPIs',
    '',
    [],
    [   ['const cv.CAP_ANY', '0', [], [], None, ''],
        ['const cv.CAP_VFW', '200', [], [], None, ''],
        ['const cv.CAP_V4L', '200', [], [], None, ''],
        ['const cv.CAP_V4L2', 'CAP_V4L', [], [], None, ''],
        ['const cv.CAP_FIREWIRE', '300', [], [], None, ''],
        ['const cv.CAP_FIREWARE', 'CAP_FIREWIRE', [], [], None, ''],
        ['const cv.CAP_IEEE1394', 'CAP_FIREWIRE', [], [], None, ''],
        ['const cv.CAP_DC1394', 'CAP_FIREWIRE', [], [], None, ''],
        ['const cv.CAP_CMU1394', 'CAP_FIREWIRE', [], [], None, ''],
        ['const cv.CAP_QT', '500', [], [], None, ''],
        ['const cv.CAP_UNICAP', '600', [], [], None, ''],
        ['const cv.CAP_DSHOW', '700', [], [], None, ''],
        ['const cv.CAP_PVAPI', '800', [], [], None, ''],
        ['const cv.CAP_OPENNI', '900', [], [], None, ''],
        ['const cv.CAP_OPENNI_ASUS', '910', [], [], None, ''],
        ['const cv.CAP_ANDROID', '1000', [], [], None, ''],
        ['const cv.CAP_XIAPI', '1100', [], [], None, ''],
        ['const cv.CAP_AVFOUNDATION', '1200', [], [], None, ''],
        ['const cv.CAP_GIGANETIX', '1300', [], [], None, ''],
        ['const cv.CAP_MSMF', '1400', [], [], None, ''],
        ['const cv.CAP_WINRT', '1410', [], [], None, ''],
        ['const cv.CAP_INTELPERC', '1500', [], [], None, ''],
        ['const cv.CAP_REALSENSE', '1500', [], [], None, ''],
        ['const cv.CAP_OPENNI2', '1600', [], [], None, ''],
        ['const cv.CAP_OPENNI2_ASUS', '1610', [], [], None, ''],
        ['const cv.CAP_OPENNI2_ASTRA', '1620', [], [], None, ''],
        ['const cv.CAP_GPHOTO2', '1700', [], [], None, ''],
        ['const cv.CAP_GSTREAMER', '1800', [], [], None, ''],
        ['const cv.CAP_FFMPEG', '1900', [], [], None, ''],
        ['const cv.CAP_IMAGES', '2000', [], [], None, ''],
        ['const cv.CAP_ARAVIS', '2100', [], [], None, ''],
        ['const cv.CAP_OPENCV_MJPEG', '2200', [], [], None, ''],
        ['const cv.CAP_INTEL_MFX', '2300', [], [], None, ''],
        ['const cv.CAP_XINE', '2400', [], [], None, ''],
        ['const cv.CAP_UEYE', '2500', [], [], None, ''],
        ['const cv.CAP_OBSENSOR', '2600', [], [], None, '']],
    None]
ok: CONST CAP_ANY=0
ok: CONST CAP_VFW=200
ok: CONST CAP_V4L=200
ok: CONST CAP_V4L2=CAP_V4L
ok: CONST CAP_FIREWIRE=300
ok: CONST CAP_FIREWARE=CAP_FIREWIRE
ok: CONST CAP_IEEE1394=CAP_FIREWIRE
ok: CONST CAP_DC1394=CAP_FIREWIRE
ok: CONST CAP_CMU1394=CAP_FIREWIRE
ok: CONST CAP_QT=500
ok: CONST CAP_UNICAP=600
ok: CONST CAP_DSHOW=700
ok: CONST CAP_PVAPI=800
ok: CONST CAP_OPENNI=900
ok: CONST CAP_OPENNI_ASUS=910
ok: CONST CAP_ANDROID=1000
ok: CONST CAP_XIAPI=1100
ok: CONST CAP_AVFOUNDATION=1200
ok: CONST CAP_GIGANETIX=1300
ok: CONST CAP_MSMF=1400
ok: CONST CAP_WINRT=1410
ok: CONST CAP_INTELPERC=1500
ok: CONST CAP_REALSENSE=1500
ok: CONST CAP_OPENNI2=1600
ok: CONST CAP_OPENNI2_ASUS=1610
ok: CONST CAP_OPENNI2_ASTRA=1620
ok: CONST CAP_GPHOTO2=1700
ok: CONST CAP_GSTREAMER=1800
ok: CONST CAP_FFMPEG=1900
ok: CONST CAP_IMAGES=2000
ok: CONST CAP_ARAVIS=2100
ok: CONST CAP_OPENCV_MJPEG=2200
ok: CONST CAP_INTEL_MFX=2300
ok: CONST CAP_XINE=2400
ok: CONST CAP_UEYE=2500
ok: CONST CAP_OBSENSOR=2600

--- Incoming ---
[   'enum cv.VideoCaptureProperties',
    '',
    [],
    [   ['const cv.CAP_PROP_POS_MSEC', '0', [], [], None, ''],
        ['const cv.CAP_PROP_POS_FRAMES', '1', [], [], None, ''],
        ['const cv.CAP_PROP_POS_AVI_RATIO', '2', [], [], None, ''],
        ['const cv.CAP_PROP_FRAME_WIDTH', '3', [], [], None, ''],
        ['const cv.CAP_PROP_FRAME_HEIGHT', '4', [], [], None, ''],
        ['const cv.CAP_PROP_FPS', '5', [], [], None, ''],
        ['const cv.CAP_PROP_FOURCC', '6', [], [], None, ''],
        ['const cv.CAP_PROP_FRAME_COUNT', '7', [], [], None, ''],
        ['const cv.CAP_PROP_FORMAT', '8', [], [], None, ''],
        ['const cv.CAP_PROP_MODE', '9', [], [], None, ''],
        ['const cv.CAP_PROP_BRIGHTNESS', '10', [], [], None, ''],
        ['const cv.CAP_PROP_CONTRAST', '11', [], [], None, ''],
        ['const cv.CAP_PROP_SATURATION', '12', [], [], None, ''],
        ['const cv.CAP_PROP_HUE', '13', [], [], None, ''],
        ['const cv.CAP_PROP_GAIN', '14', [], [], None, ''],
        ['const cv.CAP_PROP_EXPOSURE', '15', [], [], None, ''],
        ['const cv.CAP_PROP_CONVERT_RGB', '16', [], [], None, ''],
        ['const cv.CAP_PROP_WHITE_BALANCE_BLUE_U', '17', [], [], None, ''],
        ['const cv.CAP_PROP_RECTIFICATION', '18', [], [], None, ''],
        ['const cv.CAP_PROP_MONOCHROME', '19', [], [], None, ''],
        ['const cv.CAP_PROP_SHARPNESS', '20', [], [], None, ''],
        ['const cv.CAP_PROP_AUTO_EXPOSURE', '21', [], [], None, ''],
        ['const cv.CAP_PROP_GAMMA', '22', [], [], None, ''],
        ['const cv.CAP_PROP_TEMPERATURE', '23', [], [], None, ''],
        ['const cv.CAP_PROP_TRIGGER', '24', [], [], None, ''],
        ['const cv.CAP_PROP_TRIGGER_DELAY', '25', [], [], None, ''],
        ['const cv.CAP_PROP_WHITE_BALANCE_RED_V', '26', [], [], None, ''],
        ['const cv.CAP_PROP_ZOOM', '27', [], [], None, ''],
        ['const cv.CAP_PROP_FOCUS', '28', [], [], None, ''],
        ['const cv.CAP_PROP_GUID', '29', [], [], None, ''],
        ['const cv.CAP_PROP_ISO_SPEED', '30', [], [], None, ''],
        ['const cv.CAP_PROP_BACKLIGHT', '32', [], [], None, ''],
        ['const cv.CAP_PROP_PAN', '33', [], [], None, ''],
        ['const cv.CAP_PROP_TILT', '34', [], [], None, ''],
        ['const cv.CAP_PROP_ROLL', '35', [], [], None, ''],
        ['const cv.CAP_PROP_IRIS', '36', [], [], None, ''],
        ['const cv.CAP_PROP_SETTINGS', '37', [], [], None, ''],
        ['const cv.CAP_PROP_BUFFERSIZE', '38', [], [], None, ''],
        ['const cv.CAP_PROP_AUTOFOCUS', '39', [], [], None, ''],
        ['const cv.CAP_PROP_SAR_NUM', '40', [], [], None, ''],
        ['const cv.CAP_PROP_SAR_DEN', '41', [], [], None, ''],
        ['const cv.CAP_PROP_BACKEND', '42', [], [], None, ''],
        ['const cv.CAP_PROP_CHANNEL', '43', [], [], None, ''],
        ['const cv.CAP_PROP_AUTO_WB', '44', [], [], None, ''],
        ['const cv.CAP_PROP_WB_TEMPERATURE', '45', [], [], None, ''],
        ['const cv.CAP_PROP_CODEC_PIXEL_FORMAT', '46', [], [], None, ''],
        ['const cv.CAP_PROP_BITRATE', '47', [], [], None, ''],
        ['const cv.CAP_PROP_ORIENTATION_META', '48', [], [], None, ''],
        ['const cv.CAP_PROP_ORIENTATION_AUTO', '49', [], [], None, ''],
        ['const cv.CAP_PROP_HW_ACCELERATION', '50', [], [], None, ''],
        ['const cv.CAP_PROP_HW_DEVICE', '51', [], [], None, ''],
        [   'const cv.CAP_PROP_HW_ACCELERATION_USE_OPENCL',
            '52',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_OPEN_TIMEOUT_MSEC', '53', [], [], None, ''],
        ['const cv.CAP_PROP_READ_TIMEOUT_MSEC', '54', [], [], None, ''],
        ['const cv.CAP_PROP_STREAM_OPEN_TIME_USEC', '55', [], [], None, ''],
        ['const cv.CAP_PROP_VIDEO_TOTAL_CHANNELS', '56', [], [], None, ''],
        ['const cv.CAP_PROP_VIDEO_STREAM', '57', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_STREAM', '58', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_POS', '59', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_SHIFT_NSEC', '60', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_DATA_DEPTH', '61', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_SAMPLES_PER_SECOND', '62', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_BASE_INDEX', '63', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_TOTAL_CHANNELS', '64', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_TOTAL_STREAMS', '65', [], [], None, ''],
        ['const cv.CAP_PROP_AUDIO_SYNCHRONIZE', '66', [], [], None, ''],
        ['const cv.CAP_PROP_LRF_HAS_KEY_FRAME', '67', [], [], None, ''],
        ['const cv.CAP_PROP_CODEC_EXTRADATA_INDEX', '68', [], [], None, ''],
        ['const cv.CAP_PROP_FRAME_TYPE', '69', [], [], None, ''],
        ['const cv.CAP_PROP_N_THREADS', '70', [], [], None, '']],
    None]
ok: CONST CAP_PROP_POS_MSEC=0
ok: CONST CAP_PROP_POS_FRAMES=1
ok: CONST CAP_PROP_POS_AVI_RATIO=2
ok: CONST CAP_PROP_FRAME_WIDTH=3
ok: CONST CAP_PROP_FRAME_HEIGHT=4
ok: CONST CAP_PROP_FPS=5
ok: CONST CAP_PROP_FOURCC=6
ok: CONST CAP_PROP_FRAME_COUNT=7
ok: CONST CAP_PROP_FORMAT=8
ok: CONST CAP_PROP_MODE=9
ok: CONST CAP_PROP_BRIGHTNESS=10
ok: CONST CAP_PROP_CONTRAST=11
ok: CONST CAP_PROP_SATURATION=12
ok: CONST CAP_PROP_HUE=13
ok: CONST CAP_PROP_GAIN=14
ok: CONST CAP_PROP_EXPOSURE=15
ok: CONST CAP_PROP_CONVERT_RGB=16
ok: CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17
ok: CONST CAP_PROP_RECTIFICATION=18
ok: CONST CAP_PROP_MONOCHROME=19
ok: CONST CAP_PROP_SHARPNESS=20
ok: CONST CAP_PROP_AUTO_EXPOSURE=21
ok: CONST CAP_PROP_GAMMA=22
ok: CONST CAP_PROP_TEMPERATURE=23
ok: CONST CAP_PROP_TRIGGER=24
ok: CONST CAP_PROP_TRIGGER_DELAY=25
ok: CONST CAP_PROP_WHITE_BALANCE_RED_V=26
ok: CONST CAP_PROP_ZOOM=27
ok: CONST CAP_PROP_FOCUS=28
ok: CONST CAP_PROP_GUID=29
ok: CONST CAP_PROP_ISO_SPEED=30
ok: CONST CAP_PROP_BACKLIGHT=32
ok: CONST CAP_PROP_PAN=33
ok: CONST CAP_PROP_TILT=34
ok: CONST CAP_PROP_ROLL=35
ok: CONST CAP_PROP_IRIS=36
ok: CONST CAP_PROP_SETTINGS=37
ok: CONST CAP_PROP_BUFFERSIZE=38
ok: CONST CAP_PROP_AUTOFOCUS=39
ok: CONST CAP_PROP_SAR_NUM=40
ok: CONST CAP_PROP_SAR_DEN=41
ok: CONST CAP_PROP_BACKEND=42
ok: CONST CAP_PROP_CHANNEL=43
ok: CONST CAP_PROP_AUTO_WB=44
ok: CONST CAP_PROP_WB_TEMPERATURE=45
ok: CONST CAP_PROP_CODEC_PIXEL_FORMAT=46
ok: CONST CAP_PROP_BITRATE=47
ok: CONST CAP_PROP_ORIENTATION_META=48
ok: CONST CAP_PROP_ORIENTATION_AUTO=49
ok: CONST CAP_PROP_HW_ACCELERATION=50
ok: CONST CAP_PROP_HW_DEVICE=51
ok: CONST CAP_PROP_HW_ACCELERATION_USE_OPENCL=52
ok: CONST CAP_PROP_OPEN_TIMEOUT_MSEC=53
ok: CONST CAP_PROP_READ_TIMEOUT_MSEC=54
ok: CONST CAP_PROP_STREAM_OPEN_TIME_USEC=55
ok: CONST CAP_PROP_VIDEO_TOTAL_CHANNELS=56
ok: CONST CAP_PROP_VIDEO_STREAM=57
ok: CONST CAP_PROP_AUDIO_STREAM=58
ok: CONST CAP_PROP_AUDIO_POS=59
ok: CONST CAP_PROP_AUDIO_SHIFT_NSEC=60
ok: CONST CAP_PROP_AUDIO_DATA_DEPTH=61
ok: CONST CAP_PROP_AUDIO_SAMPLES_PER_SECOND=62
ok: CONST CAP_PROP_AUDIO_BASE_INDEX=63
ok: CONST CAP_PROP_AUDIO_TOTAL_CHANNELS=64
ok: CONST CAP_PROP_AUDIO_TOTAL_STREAMS=65
ok: CONST CAP_PROP_AUDIO_SYNCHRONIZE=66
ok: CONST CAP_PROP_LRF_HAS_KEY_FRAME=67
ok: CONST CAP_PROP_CODEC_EXTRADATA_INDEX=68
ok: CONST CAP_PROP_FRAME_TYPE=69
ok: CONST CAP_PROP_N_THREADS=70

--- Incoming ---
[   'enum cv.VideoWriterProperties',
    '',
    [],
    [   ['const cv.VIDEOWRITER_PROP_QUALITY', '1', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_FRAMEBYTES', '2', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_NSTRIPES', '3', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_IS_COLOR', '4', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_DEPTH', '5', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_HW_ACCELERATION', '6', [], [], None, ''],
        ['const cv.VIDEOWRITER_PROP_HW_DEVICE', '7', [], [], None, ''],
        [   'const cv.VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL',
            '8',
            [],
            [],
            None,
            '']],
    None]
ok: CONST VIDEOWRITER_PROP_QUALITY=1
ok: CONST VIDEOWRITER_PROP_FRAMEBYTES=2
ok: CONST VIDEOWRITER_PROP_NSTRIPES=3
ok: CONST VIDEOWRITER_PROP_IS_COLOR=4
ok: CONST VIDEOWRITER_PROP_DEPTH=5
ok: CONST VIDEOWRITER_PROP_HW_ACCELERATION=6
ok: CONST VIDEOWRITER_PROP_HW_DEVICE=7
ok: CONST VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL=8

--- Incoming ---
[   'enum cv.VideoAccelerationType',
    '',
    [],
    [   ['const cv.VIDEO_ACCELERATION_NONE', '0', [], [], None, ''],
        ['const cv.VIDEO_ACCELERATION_ANY', '1', [], [], None, ''],
        ['const cv.VIDEO_ACCELERATION_D3D11', '2', [], [], None, ''],
        ['const cv.VIDEO_ACCELERATION_VAAPI', '3', [], [], None, ''],
        ['const cv.VIDEO_ACCELERATION_MFX', '4', [], [], None, '']],
    None]
ok: CONST VIDEO_ACCELERATION_NONE=0
ok: CONST VIDEO_ACCELERATION_ANY=1
ok: CONST VIDEO_ACCELERATION_D3D11=2
ok: CONST VIDEO_ACCELERATION_VAAPI=3
ok: CONST VIDEO_ACCELERATION_MFX=4

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_DC1394_OFF', '-4', [], [], None, ''],
        ['const cv.CAP_PROP_DC1394_MODE_MANUAL', '-3', [], [], None, ''],
        ['const cv.CAP_PROP_DC1394_MODE_AUTO', '-2', [], [], None, ''],
        ['const cv.CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO', '-1', [], [], None, ''],
        ['const cv.CAP_PROP_DC1394_MAX', '31', [], [], None, '']],
    None]
ok: CONST CAP_PROP_DC1394_OFF=-4
ok: CONST CAP_PROP_DC1394_MODE_MANUAL=-3
ok: CONST CAP_PROP_DC1394_MODE_AUTO=-2
ok: CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1
ok: CONST CAP_PROP_DC1394_MAX=31

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_OPENNI_DEPTH_GENERATOR', '1 << 31', [], [], None, ''],
        ['const cv.CAP_OPENNI_IMAGE_GENERATOR', '1 << 30', [], [], None, ''],
        ['const cv.CAP_OPENNI_IR_GENERATOR', '1 << 29', [], [], None, ''],
        [   'const cv.CAP_OPENNI_GENERATORS_MASK',
            'CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + '
            'CAP_OPENNI_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31
ok: CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30
ok: CONST CAP_OPENNI_IR_GENERATOR=1 << 29
ok: CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_OPENNI_OUTPUT_MODE', '100', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_FRAME_MAX_DEPTH', '101', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_BASELINE', '102', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_FOCAL_LENGTH', '103', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_REGISTRATION', '104', [], [], None, ''],
        [   'const cv.CAP_PROP_OPENNI_REGISTRATION_ON',
            'CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_OPENNI_APPROX_FRAME_SYNC', '105', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_MAX_BUFFER_SIZE', '106', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_CIRCLE_BUFFER', '107', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_MAX_TIME_DURATION', '108', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI_GENERATOR_PRESENT', '109', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI2_SYNC', '110', [], [], None, ''],
        ['const cv.CAP_PROP_OPENNI2_MIRROR', '111', [], [], None, '']],
    None]
ok: CONST CAP_PROP_OPENNI_OUTPUT_MODE=100
ok: CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101
ok: CONST CAP_PROP_OPENNI_BASELINE=102
ok: CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103
ok: CONST CAP_PROP_OPENNI_REGISTRATION=104
ok: CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105
ok: CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106
ok: CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107
ok: CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108
ok: CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109
ok: CONST CAP_PROP_OPENNI2_SYNC=110
ok: CONST CAP_PROP_OPENNI2_MIRROR=111

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   [   'const cv.CAP_OPENNI_IMAGE_GENERATOR_PRESENT',
            'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE',
            'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_DEPTH_GENERATOR_PRESENT',
            'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_DEPTH_GENERATOR_BASELINE',
            'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH',
            'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON',
            'CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_OPENNI_IR_GENERATOR_PRESENT',
            'CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION
ok: CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_OPENNI_DEPTH_MAP', '0', [], [], None, ''],
        ['const cv.CAP_OPENNI_POINT_CLOUD_MAP', '1', [], [], None, ''],
        ['const cv.CAP_OPENNI_DISPARITY_MAP', '2', [], [], None, ''],
        ['const cv.CAP_OPENNI_DISPARITY_MAP_32F', '3', [], [], None, ''],
        ['const cv.CAP_OPENNI_VALID_DEPTH_MASK', '4', [], [], None, ''],
        ['const cv.CAP_OPENNI_BGR_IMAGE', '5', [], [], None, ''],
        ['const cv.CAP_OPENNI_GRAY_IMAGE', '6', [], [], None, ''],
        ['const cv.CAP_OPENNI_IR_IMAGE', '7', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_MAP=0
ok: CONST CAP_OPENNI_POINT_CLOUD_MAP=1
ok: CONST CAP_OPENNI_DISPARITY_MAP=2
ok: CONST CAP_OPENNI_DISPARITY_MAP_32F=3
ok: CONST CAP_OPENNI_VALID_DEPTH_MASK=4
ok: CONST CAP_OPENNI_BGR_IMAGE=5
ok: CONST CAP_OPENNI_GRAY_IMAGE=6
ok: CONST CAP_OPENNI_IR_IMAGE=7

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_OPENNI_VGA_30HZ', '0', [], [], None, ''],
        ['const cv.CAP_OPENNI_SXGA_15HZ', '1', [], [], None, ''],
        ['const cv.CAP_OPENNI_SXGA_30HZ', '2', [], [], None, ''],
        ['const cv.CAP_OPENNI_QVGA_30HZ', '3', [], [], None, ''],
        ['const cv.CAP_OPENNI_QVGA_60HZ', '4', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_VGA_30HZ=0
ok: CONST CAP_OPENNI_SXGA_15HZ=1
ok: CONST CAP_OPENNI_SXGA_30HZ=2
ok: CONST CAP_OPENNI_QVGA_30HZ=3
ok: CONST CAP_OPENNI_QVGA_60HZ=4

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [['const cv.CAP_PROP_GSTREAMER_QUEUE_LENGTH', '200', [], [], None, '']],
    None]
ok: CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_PVAPI_MULTICASTIP', '300', [], [], None, ''],
        [   'const cv.CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE',
            '301',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_PVAPI_DECIMATIONHORIZONTAL',
            '302',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_PVAPI_DECIMATIONVERTICAL', '303', [], [], None, ''],
        ['const cv.CAP_PROP_PVAPI_BINNINGX', '304', [], [], None, ''],
        ['const cv.CAP_PROP_PVAPI_BINNINGY', '305', [], [], None, ''],
        ['const cv.CAP_PROP_PVAPI_PIXELFORMAT', '306', [], [], None, '']],
    None]
ok: CONST CAP_PROP_PVAPI_MULTICASTIP=300
ok: CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301
ok: CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302
ok: CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303
ok: CONST CAP_PROP_PVAPI_BINNINGX=304
ok: CONST CAP_PROP_PVAPI_BINNINGY=305
ok: CONST CAP_PROP_PVAPI_PIXELFORMAT=306

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PVAPI_FSTRIGMODE_FREERUN', '0', [], [], None, ''],
        ['const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN1', '1', [], [], None, ''],
        ['const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN2', '2', [], [], None, ''],
        ['const cv.CAP_PVAPI_FSTRIGMODE_FIXEDRATE', '3', [], [], None, ''],
        ['const cv.CAP_PVAPI_FSTRIGMODE_SOFTWARE', '4', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2
ok: CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3
ok: CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PVAPI_DECIMATION_OFF', '1', [], [], None, ''],
        ['const cv.CAP_PVAPI_DECIMATION_2OUTOF4', '2', [], [], None, ''],
        ['const cv.CAP_PVAPI_DECIMATION_2OUTOF8', '4', [], [], None, ''],
        ['const cv.CAP_PVAPI_DECIMATION_2OUTOF16', '8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_DECIMATION_OFF=1
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF4=2
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF8=4
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF16=8

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PVAPI_PIXELFORMAT_MONO8', '1', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_MONO16', '2', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_BAYER8', '3', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_BAYER16', '4', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_RGB24', '5', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_BGR24', '6', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_RGBA32', '7', [], [], None, ''],
        ['const cv.CAP_PVAPI_PIXELFORMAT_BGRA32', '8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO8=1
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO16=2
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4
ok: CONST CAP_PVAPI_PIXELFORMAT_RGB24=5
ok: CONST CAP_PVAPI_PIXELFORMAT_BGR24=6
ok: CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7
ok: CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_XI_DOWNSAMPLING', '400', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DATA_FORMAT', '401', [], [], None, ''],
        ['const cv.CAP_PROP_XI_OFFSET_X', '402', [], [], None, ''],
        ['const cv.CAP_PROP_XI_OFFSET_Y', '403', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TRG_SOURCE', '404', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TRG_SOFTWARE', '405', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GPI_SELECTOR', '406', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GPI_MODE', '407', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GPI_LEVEL', '408', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GPO_SELECTOR', '409', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GPO_MODE', '410', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LED_SELECTOR', '411', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LED_MODE', '412', [], [], None, ''],
        ['const cv.CAP_PROP_XI_MANUAL_WB', '413', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AUTO_WB', '414', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG', '415', [], [], None, ''],
        ['const cv.CAP_PROP_XI_EXP_PRIORITY', '416', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AE_MAX_LIMIT', '417', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AG_MAX_LIMIT', '418', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG_LEVEL', '419', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TIMEOUT', '420', [], [], None, ''],
        ['const cv.CAP_PROP_XI_EXPOSURE', '421', [], [], None, ''],
        ['const cv.CAP_PROP_XI_EXPOSURE_BURST_COUNT', '422', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GAIN_SELECTOR', '423', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GAIN', '424', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DOWNSAMPLING_TYPE', '426', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BINNING_SELECTOR', '427', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BINNING_VERTICAL', '428', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BINNING_HORIZONTAL', '429', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BINNING_PATTERN', '430', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DECIMATION_SELECTOR', '431', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DECIMATION_VERTICAL', '432', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DECIMATION_HORIZONTAL', '433', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DECIMATION_PATTERN', '434', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR',
            '587',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_TEST_PATTERN', '588', [], [], None, ''],
        ['const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT', '435', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SHUTTER_TYPE', '436', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SENSOR_TAPS', '437', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_X', '439', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_Y', '440', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG_ROI_WIDTH', '441', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AEAG_ROI_HEIGHT', '442', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BPC', '445', [], [], None, ''],
        ['const cv.CAP_PROP_XI_WB_KR', '448', [], [], None, ''],
        ['const cv.CAP_PROP_XI_WB_KG', '449', [], [], None, ''],
        ['const cv.CAP_PROP_XI_WB_KB', '450', [], [], None, ''],
        ['const cv.CAP_PROP_XI_WIDTH', '451', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HEIGHT', '452', [], [], None, ''],
        ['const cv.CAP_PROP_XI_REGION_SELECTOR', '589', [], [], None, ''],
        ['const cv.CAP_PROP_XI_REGION_MODE', '595', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LIMIT_BANDWIDTH', '459', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH', '460', [], [], None, ''],
        ['const cv.CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH', '461', [], [], None, ''],
        ['const cv.CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH', '462', [], [], None, ''],
        ['const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING', '463', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE',
            '464',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_IS_COOLED', '465', [], [], None, ''],
        ['const cv.CAP_PROP_XI_COOLING', '466', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TARGET_TEMP', '467', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CHIP_TEMP', '468', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HOUS_TEMP', '469', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HOUS_BACK_SIDE_TEMP', '590', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SENSOR_BOARD_TEMP', '596', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CMS', '470', [], [], None, ''],
        ['const cv.CAP_PROP_XI_APPLY_CMS', '471', [], [], None, ''],
        ['const cv.CAP_PROP_XI_IMAGE_IS_COLOR', '474', [], [], None, ''],
        ['const cv.CAP_PROP_XI_COLOR_FILTER_ARRAY', '475', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GAMMAY', '476', [], [], None, ''],
        ['const cv.CAP_PROP_XI_GAMMAC', '477', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SHARPNESS', '478', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_00', '479', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_01', '480', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_02', '481', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_03', '482', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_10', '483', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_11', '484', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_12', '485', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_13', '486', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_20', '487', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_21', '488', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_22', '489', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_23', '490', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_30', '491', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_31', '492', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_32', '493', [], [], None, ''],
        ['const cv.CAP_PROP_XI_CC_MATRIX_33', '494', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEFAULT_CC_MATRIX', '495', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TRG_SELECTOR', '498', [], [], None, ''],
        ['const cv.CAP_PROP_XI_ACQ_FRAME_BURST_COUNT', '499', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEBOUNCE_EN', '507', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEBOUNCE_T0', '508', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEBOUNCE_T1', '509', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEBOUNCE_POL', '510', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_MODE', '511', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_APERTURE_VALUE', '512', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE',
            '513',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_LENS_FOCUS_MOVE', '514', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_FOCUS_DISTANCE', '515', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_FOCAL_LENGTH', '516', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_FEATURE_SELECTOR', '517', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LENS_FEATURE', '518', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEVICE_MODEL_ID', '521', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEVICE_SN', '522', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA',
            '529',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_IMAGE_PAYLOAD_SIZE', '530', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT',
            '531',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ', '532', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX',
            '533',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT',
            '534',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_FRAMERATE', '535', [], [], None, ''],
        ['const cv.CAP_PROP_XI_COUNTER_SELECTOR', '536', [], [], None, ''],
        ['const cv.CAP_PROP_XI_COUNTER_VALUE', '537', [], [], None, ''],
        ['const cv.CAP_PROP_XI_ACQ_TIMING_MODE', '538', [], [], None, ''],
        ['const cv.CAP_PROP_XI_AVAILABLE_BANDWIDTH', '539', [], [], None, ''],
        ['const cv.CAP_PROP_XI_BUFFER_POLICY', '540', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LUT_EN', '541', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LUT_INDEX', '542', [], [], None, ''],
        ['const cv.CAP_PROP_XI_LUT_VALUE', '543', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TRG_DELAY', '544', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TS_RST_MODE', '545', [], [], None, ''],
        ['const cv.CAP_PROP_XI_TS_RST_SOURCE', '546', [], [], None, ''],
        ['const cv.CAP_PROP_XI_IS_DEVICE_EXIST', '547', [], [], None, ''],
        ['const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE', '548', [], [], None, ''],
        ['const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT', '549', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE',
            '550',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_BUFFERS_QUEUE_SIZE', '551', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT',
            '552',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_RECENT_FRAME', '553', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEVICE_RESET', '554', [], [], None, ''],
        ['const cv.CAP_PROP_XI_COLUMN_FPN_CORRECTION', '555', [], [], None, ''],
        ['const cv.CAP_PROP_XI_ROW_FPN_CORRECTION', '591', [], [], None, ''],
        ['const cv.CAP_PROP_XI_SENSOR_MODE', '558', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HDR', '559', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HDR_KNEEPOINT_COUNT', '560', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HDR_T1', '561', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HDR_T2', '562', [], [], None, ''],
        ['const cv.CAP_PROP_XI_KNEEPOINT1', '563', [], [], None, ''],
        ['const cv.CAP_PROP_XI_KNEEPOINT2', '564', [], [], None, ''],
        ['const cv.CAP_PROP_XI_IMAGE_BLACK_LEVEL', '565', [], [], None, ''],
        ['const cv.CAP_PROP_XI_HW_REVISION', '571', [], [], None, ''],
        ['const cv.CAP_PROP_XI_DEBUG_LEVEL', '572', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION',
            '573',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_FFS_FILE_ID', '594', [], [], None, ''],
        ['const cv.CAP_PROP_XI_FFS_FILE_SIZE', '580', [], [], None, ''],
        ['const cv.CAP_PROP_XI_FREE_FFS_SIZE', '581', [], [], None, ''],
        ['const cv.CAP_PROP_XI_USED_FFS_SIZE', '582', [], [], None, ''],
        ['const cv.CAP_PROP_XI_FFS_ACCESS_KEY', '583', [], [], None, ''],
        [   'const cv.CAP_PROP_XI_SENSOR_FEATURE_SELECTOR',
            '585',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_XI_SENSOR_FEATURE_VALUE', '586', [], [], None, '']],
    None]
ok: CONST CAP_PROP_XI_DOWNSAMPLING=400
ok: CONST CAP_PROP_XI_DATA_FORMAT=401
ok: CONST CAP_PROP_XI_OFFSET_X=402
ok: CONST CAP_PROP_XI_OFFSET_Y=403
ok: CONST CAP_PROP_XI_TRG_SOURCE=404
ok: CONST CAP_PROP_XI_TRG_SOFTWARE=405
ok: CONST CAP_PROP_XI_GPI_SELECTOR=406
ok: CONST CAP_PROP_XI_GPI_MODE=407
ok: CONST CAP_PROP_XI_GPI_LEVEL=408
ok: CONST CAP_PROP_XI_GPO_SELECTOR=409
ok: CONST CAP_PROP_XI_GPO_MODE=410
ok: CONST CAP_PROP_XI_LED_SELECTOR=411
ok: CONST CAP_PROP_XI_LED_MODE=412
ok: CONST CAP_PROP_XI_MANUAL_WB=413
ok: CONST CAP_PROP_XI_AUTO_WB=414
ok: CONST CAP_PROP_XI_AEAG=415
ok: CONST CAP_PROP_XI_EXP_PRIORITY=416
ok: CONST CAP_PROP_XI_AE_MAX_LIMIT=417
ok: CONST CAP_PROP_XI_AG_MAX_LIMIT=418
ok: CONST CAP_PROP_XI_AEAG_LEVEL=419
ok: CONST CAP_PROP_XI_TIMEOUT=420
ok: CONST CAP_PROP_XI_EXPOSURE=421
ok: CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422
ok: CONST CAP_PROP_XI_GAIN_SELECTOR=423
ok: CONST CAP_PROP_XI_GAIN=424
ok: CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426
ok: CONST CAP_PROP_XI_BINNING_SELECTOR=427
ok: CONST CAP_PROP_XI_BINNING_VERTICAL=428
ok: CONST CAP_PROP_XI_BINNING_HORIZONTAL=429
ok: CONST CAP_PROP_XI_BINNING_PATTERN=430
ok: CONST CAP_PROP_XI_DECIMATION_SELECTOR=431
ok: CONST CAP_PROP_XI_DECIMATION_VERTICAL=432
ok: CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433
ok: CONST CAP_PROP_XI_DECIMATION_PATTERN=434
ok: CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587
ok: CONST CAP_PROP_XI_TEST_PATTERN=588
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435
ok: CONST CAP_PROP_XI_SHUTTER_TYPE=436
ok: CONST CAP_PROP_XI_SENSOR_TAPS=437
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440
ok: CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441
ok: CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442
ok: CONST CAP_PROP_XI_BPC=445
ok: CONST CAP_PROP_XI_WB_KR=448
ok: CONST CAP_PROP_XI_WB_KG=449
ok: CONST CAP_PROP_XI_WB_KB=450
ok: CONST CAP_PROP_XI_WIDTH=451
ok: CONST CAP_PROP_XI_HEIGHT=452
ok: CONST CAP_PROP_XI_REGION_SELECTOR=589
ok: CONST CAP_PROP_XI_REGION_MODE=595
ok: CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459
ok: CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460
ok: CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461
ok: CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464
ok: CONST CAP_PROP_XI_IS_COOLED=465
ok: CONST CAP_PROP_XI_COOLING=466
ok: CONST CAP_PROP_XI_TARGET_TEMP=467
ok: CONST CAP_PROP_XI_CHIP_TEMP=468
ok: CONST CAP_PROP_XI_HOUS_TEMP=469
ok: CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590
ok: CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596
ok: CONST CAP_PROP_XI_CMS=470
ok: CONST CAP_PROP_XI_APPLY_CMS=471
ok: CONST CAP_PROP_XI_IMAGE_IS_COLOR=474
ok: CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475
ok: CONST CAP_PROP_XI_GAMMAY=476
ok: CONST CAP_PROP_XI_GAMMAC=477
ok: CONST CAP_PROP_XI_SHARPNESS=478
ok: CONST CAP_PROP_XI_CC_MATRIX_00=479
ok: CONST CAP_PROP_XI_CC_MATRIX_01=480
ok: CONST CAP_PROP_XI_CC_MATRIX_02=481
ok: CONST CAP_PROP_XI_CC_MATRIX_03=482
ok: CONST CAP_PROP_XI_CC_MATRIX_10=483
ok: CONST CAP_PROP_XI_CC_MATRIX_11=484
ok: CONST CAP_PROP_XI_CC_MATRIX_12=485
ok: CONST CAP_PROP_XI_CC_MATRIX_13=486
ok: CONST CAP_PROP_XI_CC_MATRIX_20=487
ok: CONST CAP_PROP_XI_CC_MATRIX_21=488
ok: CONST CAP_PROP_XI_CC_MATRIX_22=489
ok: CONST CAP_PROP_XI_CC_MATRIX_23=490
ok: CONST CAP_PROP_XI_CC_MATRIX_30=491
ok: CONST CAP_PROP_XI_CC_MATRIX_31=492
ok: CONST CAP_PROP_XI_CC_MATRIX_32=493
ok: CONST CAP_PROP_XI_CC_MATRIX_33=494
ok: CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495
ok: CONST CAP_PROP_XI_TRG_SELECTOR=498
ok: CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499
ok: CONST CAP_PROP_XI_DEBOUNCE_EN=507
ok: CONST CAP_PROP_XI_DEBOUNCE_T0=508
ok: CONST CAP_PROP_XI_DEBOUNCE_T1=509
ok: CONST CAP_PROP_XI_DEBOUNCE_POL=510
ok: CONST CAP_PROP_XI_LENS_MODE=511
ok: CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514
ok: CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515
ok: CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516
ok: CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517
ok: CONST CAP_PROP_XI_LENS_FEATURE=518
ok: CONST CAP_PROP_XI_DEVICE_MODEL_ID=521
ok: CONST CAP_PROP_XI_DEVICE_SN=522
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529
ok: CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530
ok: CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533
ok: CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534
ok: CONST CAP_PROP_XI_FRAMERATE=535
ok: CONST CAP_PROP_XI_COUNTER_SELECTOR=536
ok: CONST CAP_PROP_XI_COUNTER_VALUE=537
ok: CONST CAP_PROP_XI_ACQ_TIMING_MODE=538
ok: CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539
ok: CONST CAP_PROP_XI_BUFFER_POLICY=540
ok: CONST CAP_PROP_XI_LUT_EN=541
ok: CONST CAP_PROP_XI_LUT_INDEX=542
ok: CONST CAP_PROP_XI_LUT_VALUE=543
ok: CONST CAP_PROP_XI_TRG_DELAY=544
ok: CONST CAP_PROP_XI_TS_RST_MODE=545
ok: CONST CAP_PROP_XI_TS_RST_SOURCE=546
ok: CONST CAP_PROP_XI_IS_DEVICE_EXIST=547
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550
ok: CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552
ok: CONST CAP_PROP_XI_RECENT_FRAME=553
ok: CONST CAP_PROP_XI_DEVICE_RESET=554
ok: CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555
ok: CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591
ok: CONST CAP_PROP_XI_SENSOR_MODE=558
ok: CONST CAP_PROP_XI_HDR=559
ok: CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560
ok: CONST CAP_PROP_XI_HDR_T1=561
ok: CONST CAP_PROP_XI_HDR_T2=562
ok: CONST CAP_PROP_XI_KNEEPOINT1=563
ok: CONST CAP_PROP_XI_KNEEPOINT2=564
ok: CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565
ok: CONST CAP_PROP_XI_HW_REVISION=571
ok: CONST CAP_PROP_XI_DEBUG_LEVEL=572
ok: CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573
ok: CONST CAP_PROP_XI_FFS_FILE_ID=594
ok: CONST CAP_PROP_XI_FFS_FILE_SIZE=580
ok: CONST CAP_PROP_XI_FREE_FFS_SIZE=581
ok: CONST CAP_PROP_XI_USED_FFS_SIZE=582
ok: CONST CAP_PROP_XI_FFS_ACCESS_KEY=583
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [['const cv.CAP_PROP_ARAVIS_AUTOTRIGGER', '600', [], [], None, '']],
    None]
ok: CONST CAP_PROP_ARAVIS_AUTOTRIGGER=600

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_IOS_DEVICE_FOCUS', '9001', [], [], None, ''],
        ['const cv.CAP_PROP_IOS_DEVICE_EXPOSURE', '9002', [], [], None, ''],
        ['const cv.CAP_PROP_IOS_DEVICE_FLASH', '9003', [], [], None, ''],
        ['const cv.CAP_PROP_IOS_DEVICE_WHITEBALANCE', '9004', [], [], None, ''],
        ['const cv.CAP_PROP_IOS_DEVICE_TORCH', '9005', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IOS_DEVICE_FOCUS=9001
ok: CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002
ok: CONST CAP_PROP_IOS_DEVICE_FLASH=9003
ok: CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004
ok: CONST CAP_PROP_IOS_DEVICE_TORCH=9005

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_GIGA_FRAME_OFFSET_X', '10001', [], [], None, ''],
        ['const cv.CAP_PROP_GIGA_FRAME_OFFSET_Y', '10002', [], [], None, ''],
        ['const cv.CAP_PROP_GIGA_FRAME_WIDTH_MAX', '10003', [], [], None, ''],
        ['const cv.CAP_PROP_GIGA_FRAME_HEIGH_MAX', '10004', [], [], None, ''],
        ['const cv.CAP_PROP_GIGA_FRAME_SENS_WIDTH', '10005', [], [], None, ''],
        ['const cv.CAP_PROP_GIGA_FRAME_SENS_HEIGH', '10006', [], [], None, '']],
    None]
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002
ok: CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003
ok: CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004
ok: CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005
ok: CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   [   'const cv.CAP_PROP_INTELPERC_PROFILE_COUNT',
            '11001',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_INTELPERC_PROFILE_IDX', '11002', [], [], None, ''],
        [   'const cv.CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE',
            '11003',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE',
            '11004',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD',
            '11005',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ',
            '11006',
            [],
            [],
            None,
            ''],
        [   'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT',
            '11007',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001
ok: CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002
ok: CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003
ok: CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004
ok: CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_INTELPERC_DEPTH_GENERATOR', '1 << 29', [], [], None, ''],
        ['const cv.CAP_INTELPERC_IMAGE_GENERATOR', '1 << 28', [], [], None, ''],
        ['const cv.CAP_INTELPERC_IR_GENERATOR', '1 << 27', [], [], None, ''],
        [   'const cv.CAP_INTELPERC_GENERATORS_MASK',
            'CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + '
            'CAP_INTELPERC_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29
ok: CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28
ok: CONST CAP_INTELPERC_IR_GENERATOR=1 << 27
ok: CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_INTELPERC_DEPTH_MAP', '0', [], [], None, ''],
        ['const cv.CAP_INTELPERC_UVDEPTH_MAP', '1', [], [], None, ''],
        ['const cv.CAP_INTELPERC_IR_MAP', '2', [], [], None, ''],
        ['const cv.CAP_INTELPERC_IMAGE', '3', [], [], None, '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_MAP=0
ok: CONST CAP_INTELPERC_UVDEPTH_MAP=1
ok: CONST CAP_INTELPERC_IR_MAP=2
ok: CONST CAP_INTELPERC_IMAGE=3

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_GPHOTO2_PREVIEW', '17001', [], [], None, ''],
        [   'const cv.CAP_PROP_GPHOTO2_WIDGET_ENUMERATE',
            '17002',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_GPHOTO2_RELOAD_CONFIG', '17003', [], [], None, ''],
        [   'const cv.CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE',
            '17004',
            [],
            [],
            None,
            ''],
        ['const cv.CAP_PROP_GPHOTO2_COLLECT_MSGS', '17005', [], [], None, ''],
        ['const cv.CAP_PROP_GPHOTO2_FLUSH_MSGS', '17006', [], [], None, ''],
        ['const cv.CAP_PROP_SPEED', '17007', [], [], None, ''],
        ['const cv.CAP_PROP_APERTURE', '17008', [], [], None, ''],
        ['const cv.CAP_PROP_EXPOSUREPROGRAM', '17009', [], [], None, ''],
        ['const cv.CAP_PROP_VIEWFINDER', '17010', [], [], None, '']],
    None]
ok: CONST CAP_PROP_GPHOTO2_PREVIEW=17001
ok: CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002
ok: CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003
ok: CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004
ok: CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005
ok: CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006
ok: CONST CAP_PROP_SPEED=17007
ok: CONST CAP_PROP_APERTURE=17008
ok: CONST CAP_PROP_EXPOSUREPROGRAM=17009
ok: CONST CAP_PROP_VIEWFINDER=17010

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CAP_PROP_IMAGES_BASE', '18000', [], [], None, ''],
        ['const cv.CAP_PROP_IMAGES_LAST', '19000', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IMAGES_BASE=18000
ok: CONST CAP_PROP_IMAGES_LAST=19000

--- Incoming ---
[   'enum cv.VideoCaptureOBSensorDataType',
    '',
    [],
    [   ['const cv.CAP_OBSENSOR_DEPTH_MAP', '0', [], [], None, ''],
        ['const cv.CAP_OBSENSOR_BGR_IMAGE', '1', [], [], None, ''],
        ['const cv.CAP_OBSENSOR_IR_IMAGE', '2', [], [], None, '']],
    None]
ok: CONST CAP_OBSENSOR_DEPTH_MAP=0
ok: CONST CAP_OBSENSOR_BGR_IMAGE=1
ok: CONST CAP_OBSENSOR_IR_IMAGE=2

--- Incoming ---
[   'enum cv.VideoCaptureOBSensorGenerators',
    '',
    [],
    [   ['const cv.CAP_OBSENSOR_DEPTH_GENERATOR', '1 << 29', [], [], None, ''],
        ['const cv.CAP_OBSENSOR_IMAGE_GENERATOR', '1 << 28', [], [], None, ''],
        ['const cv.CAP_OBSENSOR_IR_GENERATOR', '1 << 27', [], [], None, ''],
        [   'const cv.CAP_OBSENSOR_GENERATORS_MASK',
            'CAP_OBSENSOR_DEPTH_GENERATOR + CAP_OBSENSOR_IMAGE_GENERATOR + '
            'CAP_OBSENSOR_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OBSENSOR_DEPTH_GENERATOR=1 << 29
ok: CONST CAP_OBSENSOR_IMAGE_GENERATOR=1 << 28
ok: CONST CAP_OBSENSOR_IR_GENERATOR=1 << 27
ok: CONST CAP_OBSENSOR_GENERATORS_MASK=CAP_OBSENSOR_DEPTH_GENERATOR + CAP_OBSENSOR_IMAGE_GENERATOR + CAP_OBSENSOR_IR_GENERATOR

--- Incoming ---
[   'enum cv.VideoCaptureOBSensorProperties',
    '',
    [],
    [   ['const cv.CAP_PROP_OBSENSOR_INTRINSIC_FX', '26001', [], [], None, ''],
        ['const cv.CAP_PROP_OBSENSOR_INTRINSIC_FY', '26002', [], [], None, ''],
        ['const cv.CAP_PROP_OBSENSOR_INTRINSIC_CX', '26003', [], [], None, ''],
        ['const cv.CAP_PROP_OBSENSOR_INTRINSIC_CY', '26004', [], [], None, '']],
    None]
ok: CONST CAP_PROP_OBSENSOR_INTRINSIC_FX=26001
ok: CONST CAP_PROP_OBSENSOR_INTRINSIC_FY=26002
ok: CONST CAP_PROP_OBSENSOR_INTRINSIC_CX=26003
ok: CONST CAP_PROP_OBSENSOR_INTRINSIC_CY=26004

--- Incoming ---
['class cv.VideoCapture', '', [], [], None]
ok: class CLASS cv::.VideoCapture : , name: VideoCapture, base: 

--- Incoming ---
['cv.VideoCapture.VideoCapture', '', [], [], None]
ok: FUNC < cv.VideoCapture.VideoCapture []>

--- Incoming ---
[   'cv.VideoCapture.VideoCapture',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', 'CAP_ANY', []]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   'cv.VideoCapture.VideoCapture',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoCapture.VideoCapture',
    '',
    [],
    [['int', 'index', '', []], ['int', 'apiPreference', 'CAP_ANY', []]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   'cv.VideoCapture.VideoCapture',
    '',
    [],
    [   ['int', 'index', '', []],
        ['int', 'apiPreference', '', []],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoCapture.open',
    'bool',
    ['/V'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', 'CAP_ANY', []]],
    'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   'cv.VideoCapture.open',
    'bool',
    ['/V'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoCapture.open',
    'bool',
    ['/V'],
    [['int', 'index', '', []], ['int', 'apiPreference', 'CAP_ANY', []]],
    'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   'cv.VideoCapture.open',
    'bool',
    ['/V'],
    [   ['int', 'index', '', []],
        ['int', 'apiPreference', '', []],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=, ARG vector_int params=]>

--- Incoming ---
['cv.VideoCapture.isOpened', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.VideoCapture.isOpened []>

--- Incoming ---
['cv.VideoCapture.release', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.VideoCapture.release []>

--- Incoming ---
['cv.VideoCapture.grab', 'bool', ['/V'], [], 'bool']
ok: FUNC <bool cv.VideoCapture.grab []>

--- Incoming ---
[   'cv.VideoCapture.retrieve',
    'bool',
    ['/V'],
    [['Mat', 'image', '', ['/O']], ['int', 'flag', '0', []]],
    'bool']
ok: FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>

--- Incoming ---
['cv.VideoCapture.read', 'bool', ['/V'], [['Mat', 'image', '', ['/O']]], 'bool']
ok: FUNC <bool cv.VideoCapture.read [ARG Mat image=]>

--- Incoming ---
[   'cv.VideoCapture.set',
    'bool',
    ['/V'],
    [['int', 'propId', '', []], ['double', 'value', '', []]],
    'bool']
ok: FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   'cv.VideoCapture.get',
    'double',
    ['/C', '/V'],
    [['int', 'propId', '', []]],
    'double']
ok: FUNC <double cv.VideoCapture.get [ARG int propId=]>

--- Incoming ---
['cv.VideoCapture.getBackendName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.VideoCapture.getBackendName []>

--- Incoming ---
[   'cv.VideoCapture.setExceptionMode',
    'void',
    [],
    [['bool', 'enable', '', []]],
    'void']
ok: FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>

--- Incoming ---
['cv.VideoCapture.getExceptionMode', 'bool', [], [], 'bool']
ok: FUNC <bool cv.VideoCapture.getExceptionMode []>

--- Incoming ---
[   'cv.VideoCapture.waitAny',
    'bool',
    ['/S'],
    [   ['vector_VideoCapture', 'streams', '', ['/C', '/Ref']],
        ['vector_int', 'readyIndex', '', ['/O', '/Ref']],
        ['int64', 'timeoutNs', '0', []]],
    'bool']
ok: FUNC <bool cv.VideoCapture.waitAny [ARG vector_VideoCapture streams=, ARG vector_int readyIndex=, ARG int64 timeoutNs=0]>

--- Incoming ---
['class cv.VideoWriter', '', [], [], None]
ok: class CLASS cv::.VideoWriter : , name: VideoWriter, base: 

--- Incoming ---
['cv.VideoWriter.VideoWriter', '', [], [], None]
ok: FUNC < cv.VideoWriter.VideoWriter []>

--- Incoming ---
[   'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', []],
        ['bool', 'isColor', 'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', []],
        ['bool', 'isColor', 'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', ['/C', '/Ref']],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', ['/C', '/Ref']],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoWriter.open',
    'bool',
    ['/V'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', []],
        ['bool', 'isColor', 'true', []]],
    'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   'cv.VideoWriter.open',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', []],
        ['bool', 'isColor', 'true', []]],
    'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   'cv.VideoWriter.open',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', ['/C', '/Ref']],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>

--- Incoming ---
[   'cv.VideoWriter.open',
    'bool',
    [],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['int', 'apiPreference', '', []],
        ['int', 'fourcc', '', []],
        ['double', 'fps', '', []],
        ['Size', 'frameSize', '', ['/C', '/Ref']],
        ['vector_int', 'params', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>

--- Incoming ---
['cv.VideoWriter.isOpened', 'bool', ['/C', '/V'], [], 'bool']
ok: FUNC <bool cv.VideoWriter.isOpened []>

--- Incoming ---
['cv.VideoWriter.release', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.VideoWriter.release []>

--- Incoming ---
['cv.VideoWriter.write', 'void', ['/V'], [['Mat', 'image', '', []]], 'void']
ok: FUNC <void cv.VideoWriter.write [ARG Mat image=]>

--- Incoming ---
[   'cv.VideoWriter.set',
    'bool',
    ['/V'],
    [['int', 'propId', '', []], ['double', 'value', '', []]],
    'bool']
ok: FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   'cv.VideoWriter.get',
    'double',
    ['/C', '/V'],
    [['int', 'propId', '', []]],
    'double']
ok: FUNC <double cv.VideoWriter.get [ARG int propId=]>

--- Incoming ---
[   'cv.VideoWriter.fourcc',
    'int',
    ['/S'],
    [   ['char', 'c1', '', []],
        ['char', 'c2', '', []],
        ['char', 'c3', '', []],
        ['char', 'c4', '', []]],
    'int']
ok: FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>

--- Incoming ---
['cv.VideoWriter.getBackendName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.VideoWriter.getBackendName []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/registry.hpp =====
Namespaces: ['', 'cv', 'cv.internal', 'cv.videoio_registry']

--- Incoming ---
[   'cv.videoio_registry.getBackendName',
    'String',
    [],
    [['VideoCaptureAPIs', 'api', '', []]],
    'cv::String']
ok: FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>

--- Incoming ---
[   'cv.videoio_registry.getBackends',
    'vector_VideoCaptureAPIs',
    [],
    [],
    'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>

--- Incoming ---
[   'cv.videoio_registry.getCameraBackends',
    'vector_VideoCaptureAPIs',
    [],
    [],
    'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>

--- Incoming ---
[   'cv.videoio_registry.getStreamBackends',
    'vector_VideoCaptureAPIs',
    [],
    [],
    'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>

--- Incoming ---
[   'cv.videoio_registry.getWriterBackends',
    'vector_VideoCaptureAPIs',
    [],
    [],
    'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>

--- Incoming ---
[   'cv.videoio_registry.hasBackend',
    'bool',
    [],
    [['VideoCaptureAPIs', 'api', '', []]],
    'bool']
ok: FUNC <bool cv.videoio_registry..hasBackend [ARG VideoCaptureAPIs api=]>

--- Incoming ---
[   'cv.videoio_registry.isBackendBuiltIn',
    'bool',
    [],
    [['VideoCaptureAPIs', 'api', '', []]],
    'bool']
ok: FUNC <bool cv.videoio_registry..isBackendBuiltIn [ARG VideoCaptureAPIs api=]>

--- Incoming ---
[   'cv.videoio_registry.getCameraBackendPluginVersion',
    'string',
    [],
    [   ['VideoCaptureAPIs', 'api', '', []],
        ['int', 'version_ABI', '', ['/O', '/Ref']],
        ['int', 'version_API', '', ['/O', '/Ref']]],
    'std::string']
ok: FUNC <string cv.videoio_registry..getCameraBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>

--- Incoming ---
[   'cv.videoio_registry.getStreamBackendPluginVersion',
    'string',
    [],
    [   ['VideoCaptureAPIs', 'api', '', []],
        ['int', 'version_ABI', '', ['/O', '/Ref']],
        ['int', 'version_API', '', ['/O', '/Ref']]],
    'std::string']
ok: FUNC <string cv.videoio_registry..getStreamBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>

--- Incoming ---
[   'cv.videoio_registry.getWriterBackendPluginVersion',
    'string',
    [],
    [   ['VideoCaptureAPIs', 'api', '', []],
        ['int', 'version_ABI', '', ['/O', '/Ref']],
        ['int', 'version_API', '', ['/O', '/Ref']]],
    'std::string']
ok: FUNC <string cv.videoio_registry..getWriterBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio.hpp =====
Namespaces: ['', 'cv', 'cv.internal', 'cv.videoio_registry']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/videoio.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/doc/hwaccel.doc.hpp =====
Namespaces: ['', 'cv', 'cv.internal', 'cv.videoio_registry']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/videoio/include/opencv2/videoio/doc/hwaccel.doc.hpp


===== Generating... =====
CLASS cv::.VideoCapture : 
FUNC < cv.VideoCapture.VideoCapture []>
java:  VideoCapture()
FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>
java:  VideoCapture(String filename, int apiPreference)
java:  VideoCapture(String filename)
FUNC < cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=, ARG vector_int params=]>
java:  VideoCapture(String filename, int apiPreference, MatOfInt params)
FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>
java:  VideoCapture(int index, int apiPreference)
java:  VideoCapture(int index)
FUNC < cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=, ARG vector_int params=]>
java:  VideoCapture(int index, int apiPreference, MatOfInt params)
FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>
java: boolean open(String filename, int apiPreference)
java: boolean open(String filename)
FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=, ARG vector_int params=]>
java: boolean open(String filename, int apiPreference, MatOfInt params)
FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>
java: boolean open(int index, int apiPreference)
java: boolean open(int index)
FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=, ARG vector_int params=]>
java: boolean open(int index, int apiPreference, MatOfInt params)
FUNC <bool cv.VideoCapture.isOpened []>
java: boolean isOpened()
FUNC <void cv.VideoCapture.release []>
java: void release()
FUNC <bool cv.VideoCapture.grab []>
java: boolean grab()
FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>
java: boolean retrieve(Mat image, int flag)
java: boolean retrieve(Mat image)
FUNC <bool cv.VideoCapture.read [ARG Mat image=]>
java: boolean read(Mat image)
FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoCapture.get [ARG int propId=]>
java: double get(int propId)
FUNC <String cv.VideoCapture.getBackendName []>
java: String getBackendName()
FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>
java: void setExceptionMode(boolean enable)
FUNC <bool cv.VideoCapture.getExceptionMode []>
java: boolean getExceptionMode()
FUNC <bool cv.VideoCapture.waitAny [ARG vector_VideoCapture streams=, ARG vector_int readyIndex=, ARG int64 timeoutNs=0]>
SKIP:static bool cv::VideoCapture::waitAny(vector_VideoCapture streams, vector_int& readyIndex, int64 timeoutNs = 0)	 due to ARG type vector_VideoCapture/I
CLASS cv::.VideoWriter : 
FUNC < cv.VideoWriter.VideoWriter []>
java:  VideoWriter()
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize, MatOfInt params)
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize, MatOfInt params)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>
java: boolean open(String filename, int fourcc, double fps, Size frameSize, MatOfInt params)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG vector_int params=]>
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize, MatOfInt params)
FUNC <bool cv.VideoWriter.isOpened []>
java: boolean isOpened()
FUNC <void cv.VideoWriter.release []>
java: void release()
FUNC <void cv.VideoWriter.write [ARG Mat image=]>
java: void write(Mat image)
FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoWriter.get [ARG int propId=]>
java: double get(int propId)
FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>
java: int fourcc(char c1, char c2, char c3, char c4)
FUNC <String cv.VideoWriter.getBackendName []>
java: String getBackendName()
CLASS cv::.Videoio : 
[CONST CAP_PROP_DC1394_OFF=-4, CONST CAP_PROP_DC1394_MODE_MANUAL=-3, CONST CAP_PROP_DC1394_MODE_AUTO=-2, CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1, CONST CAP_PROP_DC1394_MAX=31, CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31, CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30, CONST CAP_OPENNI_IR_GENERATOR=1 << 29, CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR, CONST CAP_PROP_OPENNI_OUTPUT_MODE=100, CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101, CONST CAP_PROP_OPENNI_BASELINE=102, CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103, CONST CAP_PROP_OPENNI_REGISTRATION=104, CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION, CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105, CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106, CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107, CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108, CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109, CONST CAP_PROP_OPENNI2_SYNC=110, CONST CAP_PROP_OPENNI2_MIRROR=111, CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE, CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE, CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_MAP=0, CONST CAP_OPENNI_POINT_CLOUD_MAP=1, CONST CAP_OPENNI_DISPARITY_MAP=2, CONST CAP_OPENNI_DISPARITY_MAP_32F=3, CONST CAP_OPENNI_VALID_DEPTH_MASK=4, CONST CAP_OPENNI_BGR_IMAGE=5, CONST CAP_OPENNI_GRAY_IMAGE=6, CONST CAP_OPENNI_IR_IMAGE=7, CONST CAP_OPENNI_VGA_30HZ=0, CONST CAP_OPENNI_SXGA_15HZ=1, CONST CAP_OPENNI_SXGA_30HZ=2, CONST CAP_OPENNI_QVGA_30HZ=3, CONST CAP_OPENNI_QVGA_60HZ=4, CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200, CONST CAP_PROP_PVAPI_MULTICASTIP=300, CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301, CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302, CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303, CONST CAP_PROP_PVAPI_BINNINGX=304, CONST CAP_PROP_PVAPI_BINNINGY=305, CONST CAP_PROP_PVAPI_PIXELFORMAT=306, CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2, CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3, CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4, CONST CAP_PVAPI_DECIMATION_OFF=1, CONST CAP_PVAPI_DECIMATION_2OUTOF4=2, CONST CAP_PVAPI_DECIMATION_2OUTOF8=4, CONST CAP_PVAPI_DECIMATION_2OUTOF16=8, CONST CAP_PVAPI_PIXELFORMAT_MONO8=1, CONST CAP_PVAPI_PIXELFORMAT_MONO16=2, CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3, CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4, CONST CAP_PVAPI_PIXELFORMAT_RGB24=5, CONST CAP_PVAPI_PIXELFORMAT_BGR24=6, CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7, CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8, CONST CAP_PROP_XI_DOWNSAMPLING=400, CONST CAP_PROP_XI_DATA_FORMAT=401, CONST CAP_PROP_XI_OFFSET_X=402, CONST CAP_PROP_XI_OFFSET_Y=403, CONST CAP_PROP_XI_TRG_SOURCE=404, CONST CAP_PROP_XI_TRG_SOFTWARE=405, CONST CAP_PROP_XI_GPI_SELECTOR=406, CONST CAP_PROP_XI_GPI_MODE=407, CONST CAP_PROP_XI_GPI_LEVEL=408, CONST CAP_PROP_XI_GPO_SELECTOR=409, CONST CAP_PROP_XI_GPO_MODE=410, CONST CAP_PROP_XI_LED_SELECTOR=411, CONST CAP_PROP_XI_LED_MODE=412, CONST CAP_PROP_XI_MANUAL_WB=413, CONST CAP_PROP_XI_AUTO_WB=414, CONST CAP_PROP_XI_AEAG=415, CONST CAP_PROP_XI_EXP_PRIORITY=416, CONST CAP_PROP_XI_AE_MAX_LIMIT=417, CONST CAP_PROP_XI_AG_MAX_LIMIT=418, CONST CAP_PROP_XI_AEAG_LEVEL=419, CONST CAP_PROP_XI_TIMEOUT=420, CONST CAP_PROP_XI_EXPOSURE=421, CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422, CONST CAP_PROP_XI_GAIN_SELECTOR=423, CONST CAP_PROP_XI_GAIN=424, CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426, CONST CAP_PROP_XI_BINNING_SELECTOR=427, CONST CAP_PROP_XI_BINNING_VERTICAL=428, CONST CAP_PROP_XI_BINNING_HORIZONTAL=429, CONST CAP_PROP_XI_BINNING_PATTERN=430, CONST CAP_PROP_XI_DECIMATION_SELECTOR=431, CONST CAP_PROP_XI_DECIMATION_VERTICAL=432, CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433, CONST CAP_PROP_XI_DECIMATION_PATTERN=434, CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587, CONST CAP_PROP_XI_TEST_PATTERN=588, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435, CONST CAP_PROP_XI_SHUTTER_TYPE=436, CONST CAP_PROP_XI_SENSOR_TAPS=437, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440, CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441, CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442, CONST CAP_PROP_XI_BPC=445, CONST CAP_PROP_XI_WB_KR=448, CONST CAP_PROP_XI_WB_KG=449, CONST CAP_PROP_XI_WB_KB=450, CONST CAP_PROP_XI_WIDTH=451, CONST CAP_PROP_XI_HEIGHT=452, CONST CAP_PROP_XI_REGION_SELECTOR=589, CONST CAP_PROP_XI_REGION_MODE=595, CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459, CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460, CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461, CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464, CONST CAP_PROP_XI_IS_COOLED=465, CONST CAP_PROP_XI_COOLING=466, CONST CAP_PROP_XI_TARGET_TEMP=467, CONST CAP_PROP_XI_CHIP_TEMP=468, CONST CAP_PROP_XI_HOUS_TEMP=469, CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590, CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596, CONST CAP_PROP_XI_CMS=470, CONST CAP_PROP_XI_APPLY_CMS=471, CONST CAP_PROP_XI_IMAGE_IS_COLOR=474, CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475, CONST CAP_PROP_XI_GAMMAY=476, CONST CAP_PROP_XI_GAMMAC=477, CONST CAP_PROP_XI_SHARPNESS=478, CONST CAP_PROP_XI_CC_MATRIX_00=479, CONST CAP_PROP_XI_CC_MATRIX_01=480, CONST CAP_PROP_XI_CC_MATRIX_02=481, CONST CAP_PROP_XI_CC_MATRIX_03=482, CONST CAP_PROP_XI_CC_MATRIX_10=483, CONST CAP_PROP_XI_CC_MATRIX_11=484, CONST CAP_PROP_XI_CC_MATRIX_12=485, CONST CAP_PROP_XI_CC_MATRIX_13=486, CONST CAP_PROP_XI_CC_MATRIX_20=487, CONST CAP_PROP_XI_CC_MATRIX_21=488, CONST CAP_PROP_XI_CC_MATRIX_22=489, CONST CAP_PROP_XI_CC_MATRIX_23=490, CONST CAP_PROP_XI_CC_MATRIX_30=491, CONST CAP_PROP_XI_CC_MATRIX_31=492, CONST CAP_PROP_XI_CC_MATRIX_32=493, CONST CAP_PROP_XI_CC_MATRIX_33=494, CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495, CONST CAP_PROP_XI_TRG_SELECTOR=498, CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499, CONST CAP_PROP_XI_DEBOUNCE_EN=507, CONST CAP_PROP_XI_DEBOUNCE_T0=508, CONST CAP_PROP_XI_DEBOUNCE_T1=509, CONST CAP_PROP_XI_DEBOUNCE_POL=510, CONST CAP_PROP_XI_LENS_MODE=511, CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512, CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513, CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514, CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515, CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516, CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517, CONST CAP_PROP_XI_LENS_FEATURE=518, CONST CAP_PROP_XI_DEVICE_MODEL_ID=521, CONST CAP_PROP_XI_DEVICE_SN=522, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529, CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530, CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533, CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534, CONST CAP_PROP_XI_FRAMERATE=535, CONST CAP_PROP_XI_COUNTER_SELECTOR=536, CONST CAP_PROP_XI_COUNTER_VALUE=537, CONST CAP_PROP_XI_ACQ_TIMING_MODE=538, CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539, CONST CAP_PROP_XI_BUFFER_POLICY=540, CONST CAP_PROP_XI_LUT_EN=541, CONST CAP_PROP_XI_LUT_INDEX=542, CONST CAP_PROP_XI_LUT_VALUE=543, CONST CAP_PROP_XI_TRG_DELAY=544, CONST CAP_PROP_XI_TS_RST_MODE=545, CONST CAP_PROP_XI_TS_RST_SOURCE=546, CONST CAP_PROP_XI_IS_DEVICE_EXIST=547, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550, CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552, CONST CAP_PROP_XI_RECENT_FRAME=553, CONST CAP_PROP_XI_DEVICE_RESET=554, CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555, CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591, CONST CAP_PROP_XI_SENSOR_MODE=558, CONST CAP_PROP_XI_HDR=559, CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560, CONST CAP_PROP_XI_HDR_T1=561, CONST CAP_PROP_XI_HDR_T2=562, CONST CAP_PROP_XI_KNEEPOINT1=563, CONST CAP_PROP_XI_KNEEPOINT2=564, CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565, CONST CAP_PROP_XI_HW_REVISION=571, CONST CAP_PROP_XI_DEBUG_LEVEL=572, CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573, CONST CAP_PROP_XI_FFS_FILE_ID=594, CONST CAP_PROP_XI_FFS_FILE_SIZE=580, CONST CAP_PROP_XI_FREE_FFS_SIZE=581, CONST CAP_PROP_XI_USED_FFS_SIZE=582, CONST CAP_PROP_XI_FFS_ACCESS_KEY=583, CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585, CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586, CONST CAP_PROP_ARAVIS_AUTOTRIGGER=600, CONST CAP_PROP_IOS_DEVICE_FOCUS=9001, CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002, CONST CAP_PROP_IOS_DEVICE_FLASH=9003, CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004, CONST CAP_PROP_IOS_DEVICE_TORCH=9005, CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001, CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002, CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003, CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004, CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005, CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006, CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001, CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002, CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003, CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004, CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007, CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29, CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28, CONST CAP_INTELPERC_IR_GENERATOR=1 << 27, CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR, CONST CAP_INTELPERC_DEPTH_MAP=0, CONST CAP_INTELPERC_UVDEPTH_MAP=1, CONST CAP_INTELPERC_IR_MAP=2, CONST CAP_INTELPERC_IMAGE=3, CONST CAP_PROP_GPHOTO2_PREVIEW=17001, CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002, CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003, CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004, CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005, CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006, CONST CAP_PROP_SPEED=17007, CONST CAP_PROP_APERTURE=17008, CONST CAP_PROP_EXPOSUREPROGRAM=17009, CONST CAP_PROP_VIEWFINDER=17010, CONST CAP_PROP_IMAGES_BASE=18000, CONST CAP_PROP_IMAGES_LAST=19000]
[CONST VIDEO_ACCELERATION_NONE=0, CONST VIDEO_ACCELERATION_ANY=1, CONST VIDEO_ACCELERATION_D3D11=2, CONST VIDEO_ACCELERATION_VAAPI=3, CONST VIDEO_ACCELERATION_MFX=4]
[CONST CAP_ANY=0, CONST CAP_VFW=200, CONST CAP_V4L=200, CONST CAP_V4L2=CAP_V4L, CONST CAP_FIREWIRE=300, CONST CAP_FIREWARE=CAP_FIREWIRE, CONST CAP_IEEE1394=CAP_FIREWIRE, CONST CAP_DC1394=CAP_FIREWIRE, CONST CAP_CMU1394=CAP_FIREWIRE, CONST CAP_QT=500, CONST CAP_UNICAP=600, CONST CAP_DSHOW=700, CONST CAP_PVAPI=800, CONST CAP_OPENNI=900, CONST CAP_OPENNI_ASUS=910, CONST CAP_ANDROID=1000, CONST CAP_XIAPI=1100, CONST CAP_AVFOUNDATION=1200, CONST CAP_GIGANETIX=1300, CONST CAP_MSMF=1400, CONST CAP_WINRT=1410, CONST CAP_INTELPERC=1500, CONST CAP_REALSENSE=1500, CONST CAP_OPENNI2=1600, CONST CAP_OPENNI2_ASUS=1610, CONST CAP_OPENNI2_ASTRA=1620, CONST CAP_GPHOTO2=1700, CONST CAP_GSTREAMER=1800, CONST CAP_FFMPEG=1900, CONST CAP_IMAGES=2000, CONST CAP_ARAVIS=2100, CONST CAP_OPENCV_MJPEG=2200, CONST CAP_INTEL_MFX=2300, CONST CAP_XINE=2400, CONST CAP_UEYE=2500, CONST CAP_OBSENSOR=2600]
[CONST CAP_OBSENSOR_DEPTH_MAP=0, CONST CAP_OBSENSOR_BGR_IMAGE=1, CONST CAP_OBSENSOR_IR_IMAGE=2]
[CONST CAP_OBSENSOR_DEPTH_GENERATOR=1 << 29, CONST CAP_OBSENSOR_IMAGE_GENERATOR=1 << 28, CONST CAP_OBSENSOR_IR_GENERATOR=1 << 27, CONST CAP_OBSENSOR_GENERATORS_MASK=CAP_OBSENSOR_DEPTH_GENERATOR + CAP_OBSENSOR_IMAGE_GENERATOR + CAP_OBSENSOR_IR_GENERATOR]
[CONST CAP_PROP_OBSENSOR_INTRINSIC_FX=26001, CONST CAP_PROP_OBSENSOR_INTRINSIC_FY=26002, CONST CAP_PROP_OBSENSOR_INTRINSIC_CX=26003, CONST CAP_PROP_OBSENSOR_INTRINSIC_CY=26004]
[CONST CAP_PROP_POS_MSEC=0, CONST CAP_PROP_POS_FRAMES=1, CONST CAP_PROP_POS_AVI_RATIO=2, CONST CAP_PROP_FRAME_WIDTH=3, CONST CAP_PROP_FRAME_HEIGHT=4, CONST CAP_PROP_FPS=5, CONST CAP_PROP_FOURCC=6, CONST CAP_PROP_FRAME_COUNT=7, CONST CAP_PROP_FORMAT=8, CONST CAP_PROP_MODE=9, CONST CAP_PROP_BRIGHTNESS=10, CONST CAP_PROP_CONTRAST=11, CONST CAP_PROP_SATURATION=12, CONST CAP_PROP_HUE=13, CONST CAP_PROP_GAIN=14, CONST CAP_PROP_EXPOSURE=15, CONST CAP_PROP_CONVERT_RGB=16, CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17, CONST CAP_PROP_RECTIFICATION=18, CONST CAP_PROP_MONOCHROME=19, CONST CAP_PROP_SHARPNESS=20, CONST CAP_PROP_AUTO_EXPOSURE=21, CONST CAP_PROP_GAMMA=22, CONST CAP_PROP_TEMPERATURE=23, CONST CAP_PROP_TRIGGER=24, CONST CAP_PROP_TRIGGER_DELAY=25, CONST CAP_PROP_WHITE_BALANCE_RED_V=26, CONST CAP_PROP_ZOOM=27, CONST CAP_PROP_FOCUS=28, CONST CAP_PROP_GUID=29, CONST CAP_PROP_ISO_SPEED=30, CONST CAP_PROP_BACKLIGHT=32, CONST CAP_PROP_PAN=33, CONST CAP_PROP_TILT=34, CONST CAP_PROP_ROLL=35, CONST CAP_PROP_IRIS=36, CONST CAP_PROP_SETTINGS=37, CONST CAP_PROP_BUFFERSIZE=38, CONST CAP_PROP_AUTOFOCUS=39, CONST CAP_PROP_SAR_NUM=40, CONST CAP_PROP_SAR_DEN=41, CONST CAP_PROP_BACKEND=42, CONST CAP_PROP_CHANNEL=43, CONST CAP_PROP_AUTO_WB=44, CONST CAP_PROP_WB_TEMPERATURE=45, CONST CAP_PROP_CODEC_PIXEL_FORMAT=46, CONST CAP_PROP_BITRATE=47, CONST CAP_PROP_ORIENTATION_META=48, CONST CAP_PROP_ORIENTATION_AUTO=49, CONST CAP_PROP_HW_ACCELERATION=50, CONST CAP_PROP_HW_DEVICE=51, CONST CAP_PROP_HW_ACCELERATION_USE_OPENCL=52, CONST CAP_PROP_OPEN_TIMEOUT_MSEC=53, CONST CAP_PROP_READ_TIMEOUT_MSEC=54, CONST CAP_PROP_STREAM_OPEN_TIME_USEC=55, CONST CAP_PROP_VIDEO_TOTAL_CHANNELS=56, CONST CAP_PROP_VIDEO_STREAM=57, CONST CAP_PROP_AUDIO_STREAM=58, CONST CAP_PROP_AUDIO_POS=59, CONST CAP_PROP_AUDIO_SHIFT_NSEC=60, CONST CAP_PROP_AUDIO_DATA_DEPTH=61, CONST CAP_PROP_AUDIO_SAMPLES_PER_SECOND=62, CONST CAP_PROP_AUDIO_BASE_INDEX=63, CONST CAP_PROP_AUDIO_TOTAL_CHANNELS=64, CONST CAP_PROP_AUDIO_TOTAL_STREAMS=65, CONST CAP_PROP_AUDIO_SYNCHRONIZE=66, CONST CAP_PROP_LRF_HAS_KEY_FRAME=67, CONST CAP_PROP_CODEC_EXTRADATA_INDEX=68, CONST CAP_PROP_FRAME_TYPE=69, CONST CAP_PROP_N_THREADS=70]
[CONST VIDEOWRITER_PROP_QUALITY=1, CONST VIDEOWRITER_PROP_FRAMEBYTES=2, CONST VIDEOWRITER_PROP_NSTRIPES=3, CONST VIDEOWRITER_PROP_IS_COLOR=4, CONST VIDEOWRITER_PROP_DEPTH=5, CONST VIDEOWRITER_PROP_HW_ACCELERATION=6, CONST VIDEOWRITER_PROP_HW_DEVICE=7, CONST VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL=8]
FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>
java: String getBackendName(int api)
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getCameraBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getStreamBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getWriterBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <bool cv.videoio_registry..hasBackend [ARG VideoCaptureAPIs api=]>
java: boolean hasBackend(int api)
FUNC <bool cv.videoio_registry..isBackendBuiltIn [ARG VideoCaptureAPIs api=]>
java: boolean isBackendBuiltIn(int api)
FUNC <string cv.videoio_registry..getCameraBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>
java: String getCameraBackendPluginVersion(int api, int[] version_ABI, int[] version_API)
FUNC <string cv.videoio_registry..getStreamBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>
java: String getStreamBackendPluginVersion(int api, int[] version_ABI, int[] version_API)
FUNC <string cv.videoio_registry..getWriterBackendPluginVersion [ARG VideoCaptureAPIs api=, ARG int version_ABI=, ARG int version_API=]>
java: String getWriterBackendPluginVersion(int api, int[] version_ABI, int[] version_API)

=== MODULE: barcode (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/barcode) ===


Files (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/barcode/include/opencv2/barcode.hpp']

Common headers (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/barcode/misc/java/src/cpp/barcode_converters.hpp']
ok: class CLASS cv::.Barcode : , name: Barcode, base: 

===== Common header : /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/barcode/misc/java/src/cpp/barcode_converters.hpp =====


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/barcode/include/opencv2/barcode.hpp =====
Namespaces: ['cv', 'cv.barcode']

--- Incoming ---
[   'enum cv.barcode.BarcodeType',
    '',
    [],
    [   ['const cv.barcode.NONE', '0', [], [], None, ''],
        ['const cv.barcode.EAN_8', '1', [], [], None, ''],
        ['const cv.barcode.EAN_13', '2', [], [], None, ''],
        ['const cv.barcode.UPC_A', '3', [], [], None, ''],
        ['const cv.barcode.UPC_E', '4', [], [], None, ''],
        ['const cv.barcode.UPC_EAN_EXTENSION', '5', [], [], None, '']],
    None]
ok: CONST NONE=0
ok: CONST EAN_8=1
ok: CONST EAN_13=2
ok: CONST UPC_A=3
ok: CONST UPC_E=4
ok: CONST UPC_EAN_EXTENSION=5

--- Incoming ---
['class cv.barcode.BarcodeDetector', '', [], [], None]
ok: class CLASS cv.barcode::.BarcodeDetector : , name: BarcodeDetector, base: 

--- Incoming ---
[   'cv.barcode.BarcodeDetector.BarcodeDetector',
    '',
    [],
    [   ['string', 'prototxt_path', '""', ['/C', '/Ref']],
        ['string', 'model_path', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.barcode.BarcodeDetector.BarcodeDetector [ARG string prototxt_path="", ARG string model_path=""]>

--- Incoming ---
[   'cv.barcode.BarcodeDetector.detect',
    'bool',
    ['/C'],
    [['Mat', 'img', '', []], ['Mat', 'points', '', ['/O']]],
    'bool']
ok: FUNC <bool cv.barcode.BarcodeDetector.detect [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   'cv.barcode.BarcodeDetector.decode',
    'bool',
    ['/C'],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', '', []],
        ['vector_string', 'decoded_info', '', ['/O', '/Ref']],
        ['vector_BarcodeType', 'decoded_type', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv.barcode.BarcodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_BarcodeType decoded_type=]>

--- Incoming ---
[   'cv.barcode.BarcodeDetector.detectAndDecode',
    'bool',
    ['/C'],
    [   ['Mat', 'img', '', []],
        ['vector_string', 'decoded_info', '', ['/O', '/Ref']],
        ['vector_BarcodeType', 'decoded_type', '', ['/O', '/Ref']],
        ['Mat', 'points', 'Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.barcode.BarcodeDetector.detectAndDecode [ARG Mat img=, ARG vector_string decoded_info=, ARG vector_BarcodeType decoded_type=, ARG Mat points=Mat()]>


===== Generating... =====
CLASS cv::.Barcode : 
[CONST NONE=0, CONST EAN_8=1, CONST EAN_13=2, CONST UPC_A=3, CONST UPC_E=4, CONST UPC_EAN_EXTENSION=5]
CLASS cv.barcode::.BarcodeDetector : 
FUNC < cv.barcode.BarcodeDetector.BarcodeDetector [ARG string prototxt_path="", ARG string model_path=""]>
java:  BarcodeDetector(String prototxt_path, String model_path)
java:  BarcodeDetector(String prototxt_path)
java:  BarcodeDetector()
FUNC <bool cv.barcode.BarcodeDetector.detect [ARG Mat img=, ARG Mat points=]>
java: boolean detect(Mat img, Mat points)
FUNC <bool cv.barcode.BarcodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_BarcodeType decoded_type=]>
java: boolean decode(Mat img, Mat points, List<String> decoded_info, List<Integer> decoded_type)
FUNC <bool cv.barcode.BarcodeDetector.detectAndDecode [ARG Mat img=, ARG vector_string decoded_info=, ARG vector_BarcodeType decoded_type=, ARG Mat points=Mat()]>
java: boolean detectAndDecode(Mat img, List<String> decoded_info, List<Integer> decoded_type, Mat points)
java: boolean detectAndDecode(Mat img, List<String> decoded_info, List<Integer> decoded_type)

=== MODULE: calib3d (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d) ===


Files (3):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d/calib3d_c.h',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d/calib3d.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Calib3d : , name: Calib3d, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d/calib3d_c.h =====
Namespaces: ['']

--- Incoming ---
[   'enum <unnamed>',
    '',
    [],
    [   ['const CV_ITERATIVE', '0', [], [], None, ''],
        ['const CV_EPNP', '1', [], [], None, ''],
        ['const CV_P3P', '2', [], [], None, ''],
        ['const CV_DLS', '3', [], [], None, '']],
    None]
ok: CONST CV_ITERATIVE=0
ok: CONST CV_EPNP=1
ok: CONST CV_P3P=2
ok: CONST CV_DLS=3

--- Incoming ---
[   'enum CvLevMarq.<unnamed>',
    '',
    [],
    [   ['const CvLevMarq.DONE', '0', [], [], None, ''],
        ['const CvLevMarq.STARTED', '1', [], [], None, ''],
        ['const CvLevMarq.CALC_J', '2', [], [], None, ''],
        ['const CvLevMarq.CHECK_ERR', '3', [], [], None, '']],
    None]
class not found: CONST DONE=0
ok: CONST CvLevMarq_DONE=0
class not found: CONST STARTED=1
ok: CONST CvLevMarq_STARTED=1
class not found: CONST CALC_J=2
ok: CONST CvLevMarq_CALC_J=2
class not found: CONST CHECK_ERR=3
ok: CONST CvLevMarq_CHECK_ERR=3


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d.hpp =====
Namespaces: ['', 'cv', 'cv.fisheye']

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.LMEDS', '4', [], [], None, ''],
        ['const cv.RANSAC', '8', [], [], None, ''],
        ['const cv.RHO', '16', [], [], None, ''],
        ['const cv.USAC_DEFAULT', '32', [], [], None, ''],
        ['const cv.USAC_PARALLEL', '33', [], [], None, ''],
        ['const cv.USAC_FM_8PTS', '34', [], [], None, ''],
        ['const cv.USAC_FAST', '35', [], [], None, ''],
        ['const cv.USAC_ACCURATE', '36', [], [], None, ''],
        ['const cv.USAC_PROSAC', '37', [], [], None, ''],
        ['const cv.USAC_MAGSAC', '38', [], [], None, '']],
    None]
ok: CONST LMEDS=4
ok: CONST RANSAC=8
ok: CONST RHO=16
ok: CONST USAC_DEFAULT=32
ok: CONST USAC_PARALLEL=33
ok: CONST USAC_FM_8PTS=34
ok: CONST USAC_FAST=35
ok: CONST USAC_ACCURATE=36
ok: CONST USAC_PROSAC=37
ok: CONST USAC_MAGSAC=38

--- Incoming ---
[   'enum cv.SolvePnPMethod',
    '',
    [],
    [   ['const cv.SOLVEPNP_ITERATIVE', '0', [], [], None, ''],
        ['const cv.SOLVEPNP_EPNP', '1', [], [], None, ''],
        ['const cv.SOLVEPNP_P3P', '2', [], [], None, ''],
        ['const cv.SOLVEPNP_DLS', '3', [], [], None, ''],
        ['const cv.SOLVEPNP_UPNP', '4', [], [], None, ''],
        ['const cv.SOLVEPNP_AP3P', '5', [], [], None, ''],
        ['const cv.SOLVEPNP_IPPE', '6', [], [], None, ''],
        ['const cv.SOLVEPNP_IPPE_SQUARE', '7', [], [], None, ''],
        ['const cv.SOLVEPNP_SQPNP', '8', [], [], None, ''],
        ['const cv.SOLVEPNP_MAX_COUNT', '8+1', [], [], None, '']],
    None]
ok: CONST SOLVEPNP_ITERATIVE=0
ok: CONST SOLVEPNP_EPNP=1
ok: CONST SOLVEPNP_P3P=2
ok: CONST SOLVEPNP_DLS=3
ok: CONST SOLVEPNP_UPNP=4
ok: CONST SOLVEPNP_AP3P=5
ok: CONST SOLVEPNP_IPPE=6
ok: CONST SOLVEPNP_IPPE_SQUARE=7
ok: CONST SOLVEPNP_SQPNP=8
ok: CONST SOLVEPNP_MAX_COUNT=8+1

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_CB_ADAPTIVE_THRESH', '1', [], [], None, ''],
        ['const cv.CALIB_CB_NORMALIZE_IMAGE', '2', [], [], None, ''],
        ['const cv.CALIB_CB_FILTER_QUADS', '4', [], [], None, ''],
        ['const cv.CALIB_CB_FAST_CHECK', '8', [], [], None, ''],
        ['const cv.CALIB_CB_EXHAUSTIVE', '16', [], [], None, ''],
        ['const cv.CALIB_CB_ACCURACY', '32', [], [], None, ''],
        ['const cv.CALIB_CB_LARGER', '64', [], [], None, ''],
        ['const cv.CALIB_CB_MARKER', '128', [], [], None, '']],
    None]
ok: CONST CALIB_CB_ADAPTIVE_THRESH=1
ok: CONST CALIB_CB_NORMALIZE_IMAGE=2
ok: CONST CALIB_CB_FILTER_QUADS=4
ok: CONST CALIB_CB_FAST_CHECK=8
ok: CONST CALIB_CB_EXHAUSTIVE=16
ok: CONST CALIB_CB_ACCURACY=32
ok: CONST CALIB_CB_LARGER=64
ok: CONST CALIB_CB_MARKER=128

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_CB_SYMMETRIC_GRID', '1', [], [], None, ''],
        ['const cv.CALIB_CB_ASYMMETRIC_GRID', '2', [], [], None, ''],
        ['const cv.CALIB_CB_CLUSTERING', '4', [], [], None, '']],
    None]
ok: CONST CALIB_CB_SYMMETRIC_GRID=1
ok: CONST CALIB_CB_ASYMMETRIC_GRID=2
ok: CONST CALIB_CB_CLUSTERING=4

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CALIB_NINTRINSIC', '18', [], [], None, ''],
        ['const cv.CALIB_USE_INTRINSIC_GUESS', '0x00001', [], [], None, ''],
        ['const cv.CALIB_FIX_ASPECT_RATIO', '0x00002', [], [], None, ''],
        ['const cv.CALIB_FIX_PRINCIPAL_POINT', '0x00004', [], [], None, ''],
        ['const cv.CALIB_ZERO_TANGENT_DIST', '0x00008', [], [], None, ''],
        ['const cv.CALIB_FIX_FOCAL_LENGTH', '0x00010', [], [], None, ''],
        ['const cv.CALIB_FIX_K1', '0x00020', [], [], None, ''],
        ['const cv.CALIB_FIX_K2', '0x00040', [], [], None, ''],
        ['const cv.CALIB_FIX_K3', '0x00080', [], [], None, ''],
        ['const cv.CALIB_FIX_K4', '0x00800', [], [], None, ''],
        ['const cv.CALIB_FIX_K5', '0x01000', [], [], None, ''],
        ['const cv.CALIB_FIX_K6', '0x02000', [], [], None, ''],
        ['const cv.CALIB_RATIONAL_MODEL', '0x04000', [], [], None, ''],
        ['const cv.CALIB_THIN_PRISM_MODEL', '0x08000', [], [], None, ''],
        ['const cv.CALIB_FIX_S1_S2_S3_S4', '0x10000', [], [], None, ''],
        ['const cv.CALIB_TILTED_MODEL', '0x40000', [], [], None, ''],
        ['const cv.CALIB_FIX_TAUX_TAUY', '0x80000', [], [], None, ''],
        ['const cv.CALIB_USE_QR', '0x100000', [], [], None, ''],
        ['const cv.CALIB_FIX_TANGENT_DIST', '0x200000', [], [], None, ''],
        ['const cv.CALIB_FIX_INTRINSIC', '0x00100', [], [], None, ''],
        ['const cv.CALIB_SAME_FOCAL_LENGTH', '0x00200', [], [], None, ''],
        ['const cv.CALIB_ZERO_DISPARITY', '0x00400', [], [], None, ''],
        ['const cv.CALIB_USE_LU', '(1 << 17)', [], [], None, ''],
        ['const cv.CALIB_USE_EXTRINSIC_GUESS', '(1 << 22)', [], [], None, '']],
    None]
ok: CONST CALIB_NINTRINSIC=18
ok: CONST CALIB_USE_INTRINSIC_GUESS=0x00001
ok: CONST CALIB_FIX_ASPECT_RATIO=0x00002
ok: CONST CALIB_FIX_PRINCIPAL_POINT=0x00004
ok: CONST CALIB_ZERO_TANGENT_DIST=0x00008
ok: CONST CALIB_FIX_FOCAL_LENGTH=0x00010
ok: CONST CALIB_FIX_K1=0x00020
ok: CONST CALIB_FIX_K2=0x00040
ok: CONST CALIB_FIX_K3=0x00080
ok: CONST CALIB_FIX_K4=0x00800
ok: CONST CALIB_FIX_K5=0x01000
ok: CONST CALIB_FIX_K6=0x02000
ok: CONST CALIB_RATIONAL_MODEL=0x04000
ok: CONST CALIB_THIN_PRISM_MODEL=0x08000
ok: CONST CALIB_FIX_S1_S2_S3_S4=0x10000
ok: CONST CALIB_TILTED_MODEL=0x40000
ok: CONST CALIB_FIX_TAUX_TAUY=0x80000
ok: CONST CALIB_USE_QR=0x100000
ok: CONST CALIB_FIX_TANGENT_DIST=0x200000
ok: CONST CALIB_FIX_INTRINSIC=0x00100
ok: CONST CALIB_SAME_FOCAL_LENGTH=0x00200
ok: CONST CALIB_ZERO_DISPARITY=0x00400
ok: CONST CALIB_USE_LU=(1 << 17)
ok: CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22)

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.FM_7POINT', '1', [], [], None, ''],
        ['const cv.FM_8POINT', '2', [], [], None, ''],
        ['const cv.FM_LMEDS', '4', [], [], None, ''],
        ['const cv.FM_RANSAC', '8', [], [], None, '']],
    None]
ok: CONST FM_7POINT=1
ok: CONST FM_8POINT=2
ok: CONST FM_LMEDS=4
ok: CONST FM_RANSAC=8

--- Incoming ---
[   'enum cv.HandEyeCalibrationMethod',
    '',
    [],
    [   ['const cv.CALIB_HAND_EYE_TSAI', '0', [], [], None, ''],
        ['const cv.CALIB_HAND_EYE_PARK', '1', [], [], None, ''],
        ['const cv.CALIB_HAND_EYE_HORAUD', '2', [], [], None, ''],
        ['const cv.CALIB_HAND_EYE_ANDREFF', '3', [], [], None, ''],
        ['const cv.CALIB_HAND_EYE_DANIILIDIS', '4', [], [], None, '']],
    None]
ok: CONST CALIB_HAND_EYE_TSAI=0
ok: CONST CALIB_HAND_EYE_PARK=1
ok: CONST CALIB_HAND_EYE_HORAUD=2
ok: CONST CALIB_HAND_EYE_ANDREFF=3
ok: CONST CALIB_HAND_EYE_DANIILIDIS=4

--- Incoming ---
[   'enum cv.RobotWorldHandEyeCalibrationMethod',
    '',
    [],
    [   ['const cv.CALIB_ROBOT_WORLD_HAND_EYE_SHAH', '0', [], [], None, ''],
        ['const cv.CALIB_ROBOT_WORLD_HAND_EYE_LI', '1', [], [], None, '']],
    None]
ok: CONST CALIB_ROBOT_WORLD_HAND_EYE_SHAH=0
ok: CONST CALIB_ROBOT_WORLD_HAND_EYE_LI=1

--- Incoming ---
[   'enum cv.SamplingMethod',
    '',
    [],
    [   ['const cv.SAMPLING_UNIFORM', '0', [], [], None, ''],
        ['const cv.SAMPLING_PROGRESSIVE_NAPSAC', '1', [], [], None, ''],
        ['const cv.SAMPLING_NAPSAC', '2', [], [], None, ''],
        ['const cv.SAMPLING_PROSAC', '3', [], [], None, '']],
    None]
ok: CONST SAMPLING_UNIFORM=0
ok: CONST SAMPLING_PROGRESSIVE_NAPSAC=1
ok: CONST SAMPLING_NAPSAC=2
ok: CONST SAMPLING_PROSAC=3

--- Incoming ---
[   'enum cv.LocalOptimMethod',
    '',
    [],
    [   ['const cv.LOCAL_OPTIM_NULL', '0', [], [], None, ''],
        ['const cv.LOCAL_OPTIM_INNER_LO', '1', [], [], None, ''],
        ['const cv.LOCAL_OPTIM_INNER_AND_ITER_LO', '2', [], [], None, ''],
        ['const cv.LOCAL_OPTIM_GC', '3', [], [], None, ''],
        ['const cv.LOCAL_OPTIM_SIGMA', '4', [], [], None, '']],
    None]
ok: CONST LOCAL_OPTIM_NULL=0
ok: CONST LOCAL_OPTIM_INNER_LO=1
ok: CONST LOCAL_OPTIM_INNER_AND_ITER_LO=2
ok: CONST LOCAL_OPTIM_GC=3
ok: CONST LOCAL_OPTIM_SIGMA=4

--- Incoming ---
[   'enum cv.ScoreMethod',
    '',
    [],
    [   ['const cv.SCORE_METHOD_RANSAC', '0', [], [], None, ''],
        ['const cv.SCORE_METHOD_MSAC', '1', [], [], None, ''],
        ['const cv.SCORE_METHOD_MAGSAC', '2', [], [], None, ''],
        ['const cv.SCORE_METHOD_LMEDS', '3', [], [], None, '']],
    None]
ok: CONST SCORE_METHOD_RANSAC=0
ok: CONST SCORE_METHOD_MSAC=1
ok: CONST SCORE_METHOD_MAGSAC=2
ok: CONST SCORE_METHOD_LMEDS=3

--- Incoming ---
[   'enum cv.NeighborSearchMethod',
    '',
    [],
    [   ['const cv.NEIGH_FLANN_KNN', '0', [], [], None, ''],
        ['const cv.NEIGH_GRID', '1', [], [], None, ''],
        ['const cv.NEIGH_FLANN_RADIUS', '2', [], [], None, '']],
    None]
ok: CONST NEIGH_FLANN_KNN=0
ok: CONST NEIGH_GRID=1
ok: CONST NEIGH_FLANN_RADIUS=2

--- Incoming ---
[   'struct cv.UsacParams',
    '',
    ['/Simple'],
    [   ['double', 'confidence', '', ['/RW']],
        ['bool', 'isParallel', '', ['/RW']],
        ['int', 'loIterations', '', ['/RW']],
        ['LocalOptimMethod', 'loMethod', '', ['/RW']],
        ['int', 'loSampleSize', '', ['/RW']],
        ['int', 'maxIterations', '', ['/RW']],
        ['NeighborSearchMethod', 'neighborsSearch', '', ['/RW']],
        ['int', 'randomGeneratorState', '', ['/RW']],
        ['SamplingMethod', 'sampler', '', ['/RW']],
        ['ScoreMethod', 'score', '', ['/RW']],
        ['double', 'threshold', '', ['/RW']]],
    None]
ok: class CLASS cv::.UsacParams : , name: UsacParams, base: 

--- Incoming ---
['cv.UsacParams.UsacParams', '', [], [], None]
ok: FUNC < cv.UsacParams.UsacParams []>

--- Incoming ---
[   'cv.Rodrigues',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'jacobian', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   'cv.findHomography',
    'Mat',
    [],
    [   ['Mat', 'srcPoints', '', []],
        ['Mat', 'dstPoints', '', []],
        ['int', 'method', '0', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['Mat', 'mask', 'Mat()', ['/O']],
        ['int', 'maxIters', '2000', ['/C']],
        ['double', 'confidence', '0.995', ['/C']]],
    'Mat']
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>

--- Incoming ---
[   'cv.findHomography',
    'Mat',
    [],
    [   ['Mat', 'srcPoints', '', []],
        ['Mat', 'dstPoints', '', []],
        ['Mat', 'mask', '', ['/O']],
        ['UsacParams', 'params', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG Mat mask=, ARG UsacParams params=]>

--- Incoming ---
[   'cv.RQDecomp3x3',
    'Vec3d',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mtxR', '', ['/O']],
        ['Mat', 'mtxQ', '', ['/O']],
        ['Mat', 'Qx', 'Mat()', ['/O']],
        ['Mat', 'Qy', 'Mat()', ['/O']],
        ['Mat', 'Qz', 'Mat()', ['/O']]],
    'Vec3d']
ok: FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>

--- Incoming ---
[   'cv.decomposeProjectionMatrix',
    'void',
    [],
    [   ['Mat', 'projMatrix', '', []],
        ['Mat', 'cameraMatrix', '', ['/O']],
        ['Mat', 'rotMatrix', '', ['/O']],
        ['Mat', 'transVect', '', ['/O']],
        ['Mat', 'rotMatrixX', 'Mat()', ['/O']],
        ['Mat', 'rotMatrixY', 'Mat()', ['/O']],
        ['Mat', 'rotMatrixZ', 'Mat()', ['/O']],
        ['Mat', 'eulerAngles', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>

--- Incoming ---
[   'cv.matMulDeriv',
    'void',
    [],
    [   ['Mat', 'A', '', []],
        ['Mat', 'B', '', []],
        ['Mat', 'dABdA', '', ['/O']],
        ['Mat', 'dABdB', '', ['/O']]],
    'void']
ok: FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>

--- Incoming ---
[   'cv.composeRT',
    'void',
    [],
    [   ['Mat', 'rvec1', '', []],
        ['Mat', 'tvec1', '', []],
        ['Mat', 'rvec2', '', []],
        ['Mat', 'tvec2', '', []],
        ['Mat', 'rvec3', '', ['/O']],
        ['Mat', 'tvec3', '', ['/O']],
        ['Mat', 'dr3dr1', 'Mat()', ['/O']],
        ['Mat', 'dr3dt1', 'Mat()', ['/O']],
        ['Mat', 'dr3dr2', 'Mat()', ['/O']],
        ['Mat', 'dr3dt2', 'Mat()', ['/O']],
        ['Mat', 'dt3dr1', 'Mat()', ['/O']],
        ['Mat', 'dt3dt1', 'Mat()', ['/O']],
        ['Mat', 'dt3dr2', 'Mat()', ['/O']],
        ['Mat', 'dt3dt2', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>

--- Incoming ---
[   'cv.projectPoints',
    'void',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'rvec', '', []],
        ['Mat', 'tvec', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'imagePoints', '', ['/O']],
        ['Mat', 'jacobian', 'Mat()', ['/O']],
        ['double', 'aspectRatio', '0', []]],
    'void']
ok: FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>

--- Incoming ---
[   'cv.solvePnP',
    'bool',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/O']],
        ['Mat', 'tvec', '', ['/O']],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]],
    'bool']
ok: FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   'cv.solvePnPRansac',
    'bool',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/O']],
        ['Mat', 'tvec', '', ['/O']],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'iterationsCount', '100', []],
        ['float', 'reprojectionError', '8.0', []],
        ['double', 'confidence', '0.99', []],
        ['Mat', 'inliers', 'Mat()', ['/O']],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]],
    'bool']
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   'cv.solvePnPRansac',
    'bool',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/O']],
        ['Mat', 'tvec', '', ['/O']],
        ['Mat', 'inliers', '', ['/O']],
        ['UsacParams', 'params', 'UsacParams()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat inliers=, ARG UsacParams params=UsacParams()]>

--- Incoming ---
[   'cv.solveP3P',
    'int',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['int', 'flags', '', []]],
    'int']
ok: FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>

--- Incoming ---
[   'cv.solvePnPRefineLM',
    'void',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/IO']],
        ['Mat', 'tvec', '', ['/IO']],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, '
            'FLT_EPSILON)',
            []]],
    'void']
ok: FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>

--- Incoming ---
[   'cv.solvePnPRefineVVS',
    'void',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/IO']],
        ['Mat', 'tvec', '', ['/IO']],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, '
            'FLT_EPSILON)',
            []],
        ['double', 'VVSlambda', '1', []]],
    'void']
ok: FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>

--- Incoming ---
[   'cv.solvePnPGeneric',
    'int',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['SolvePnPMethod', 'flags', 'SOLVEPNP_ITERATIVE', []],
        ['Mat', 'rvec', 'Mat()', []],
        ['Mat', 'tvec', 'Mat()', []],
        ['Mat', 'reprojectionError', 'Mat()', ['/O']]],
    'int']
ok: FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>

--- Incoming ---
[   'cv.initCameraMatrix2D',
    'Mat',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'aspectRatio', '1.0', []]],
    'Mat']
ok: FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>

--- Incoming ---
[   'cv.findChessboardCorners',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', ['/O']],
        [   'int',
            'flags',
            'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]],
    'bool']
ok: FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>

--- Incoming ---
[   'cv.checkChessboard',
    'bool',
    [],
    [['Mat', 'img', '', []], ['Size', 'size', '', []]],
    'bool']
ok: FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>

--- Incoming ---
[   'cv.findChessboardCornersSB',
    'bool',
    ['=findChessboardCornersSBWithMeta'],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', ['/O']],
        ['int', 'flags', '', []],
        ['Mat', 'meta', '', ['/O']]],
    'bool']
ok: FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=, ARG Mat meta=]>

--- Incoming ---
[   'cv.findChessboardCornersSB',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', ['/O']],
        ['int', 'flags', '0', []]],
    'bool']
ok: FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>

--- Incoming ---
[   'cv.estimateChessboardSharpness',
    'Scalar',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', []],
        ['float', 'rise_distance', '0.8F', []],
        ['bool', 'vertical', 'false', []],
        ['Mat', 'sharpness', 'Mat()', ['/O']]],
    'Scalar']
ok: FUNC <Scalar cv..estimateChessboardSharpness [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG float rise_distance=0.8F, ARG bool vertical=false, ARG Mat sharpness=Mat()]>

--- Incoming ---
[   'cv.find4QuadCornerSubpix',
    'bool',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'corners', '', ['/IO']],
        ['Size', 'region_size', '', []]],
    'bool']
ok: FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>

--- Incoming ---
[   'cv.drawChessboardCorners',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', []],
        ['bool', 'patternWasFound', '', []]],
    'void']
ok: FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>

--- Incoming ---
[   'cv.drawFrameAxes',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', []],
        ['Mat', 'tvec', '', []],
        ['float', 'length', '', []],
        ['int', 'thickness', '3', []]],
    'void']
ok: FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>

--- Incoming ---
[   'struct cv.CirclesGridFinderParameters',
    '',
    ['/Simple'],
    [   ['Size2f', 'densityNeighborhoodSize', '', ['/RW']],
        ['float', 'minDensity', '', ['/RW']],
        ['int', 'kmeansAttempts', '', ['/RW']],
        ['int', 'minDistanceToAddKeypoint', '', ['/RW']],
        ['int', 'keypointScale', '', ['/RW']],
        ['float', 'minGraphConfidence', '', ['/RW']],
        ['float', 'vertexGain', '', ['/RW']],
        ['float', 'vertexPenalty', '', ['/RW']],
        ['float', 'existingVertexGain', '', ['/RW']],
        ['float', 'edgeGain', '', ['/RW']],
        ['float', 'edgePenalty', '', ['/RW']],
        ['float', 'convexHullFactor', '', ['/RW']],
        ['float', 'minRNGEdgeSwitchDist', '', ['/RW']],
        ['float', 'squareSize', '', ['/RW']],
        ['float', 'maxRectifiedDistance', '', ['/RW']]],
    None]
ignored: CLASS cv::.CirclesGridFinderParameters : 

--- Incoming ---
['cv.CirclesGridFinderParameters.CirclesGridFinderParameters', '', [], [], None]
ignored: FUNC < cv.CirclesGridFinderParameters.CirclesGridFinderParameters []>

--- Incoming ---
[   'enum cv.CirclesGridFinderParameters.GridType',
    '',
    [],
    [   [   'const cv.CirclesGridFinderParameters.SYMMETRIC_GRID',
            '0',
            [],
            [],
            None,
            ''],
        [   'const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID',
            '1',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST SYMMETRIC_GRID=0
ok: CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0
class not found: CONST ASYMMETRIC_GRID=1
ok: CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1

--- Incoming ---
[   'cv.findCirclesGrid',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'centers', '', ['/O']],
        ['int', 'flags', '', []],
        ['Ptr_FeatureDetector', 'blobDetector', '', ['/C', '/Ref']],
        ['CirclesGridFinderParameters', 'parameters', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>

--- Incoming ---
[   'cv.findCirclesGrid',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'centers', '', ['/O']],
        ['int', 'flags', 'CALIB_CB_SYMMETRIC_GRID', []],
        [   'Ptr_FeatureDetector',
            'blobDetector',
            'SimpleBlobDetector::create()',
            ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>

--- Incoming ---
[   'cv.calibrateCamera',
    'double',
    ['=calibrateCameraExtended'],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', 'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.calibrateCamera',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.calibrateCameraRO',
    'double',
    ['=calibrateCameraROExtended'],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'iFixedPoint', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'newObjPoints', '', ['/O']],
        ['Mat', 'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', 'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', 'stdDeviationsObjPoints', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.calibrateCameraRO',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['int', 'iFixedPoint', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'newObjPoints', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.calibrationMatrixValues',
    'void',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'apertureWidth', '', []],
        ['double', 'apertureHeight', '', []],
        ['double', 'fovx', '', ['/O', '/Ref']],
        ['double', 'fovy', '', ['/O', '/Ref']],
        ['double', 'focalLength', '', ['/O', '/Ref']],
        ['Point2d', 'principalPoint', '', ['/O', '/Ref']],
        ['double', 'aspectRatio', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    ['=stereoCalibrateExtended'],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'cameraMatrix1', '', ['/IO']],
        ['Mat', 'distCoeffs1', '', ['/IO']],
        ['Mat', 'cameraMatrix2', '', ['/IO']],
        ['Mat', 'distCoeffs2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/IO']],
        ['Mat', 'T', '', ['/IO']],
        ['Mat', 'E', '', ['/O']],
        ['Mat', 'F', '', ['/O']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'cameraMatrix1', '', ['/IO']],
        ['Mat', 'distCoeffs1', '', ['/IO']],
        ['Mat', 'cameraMatrix2', '', ['/IO']],
        ['Mat', 'distCoeffs2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 'T', '', ['/O']],
        ['Mat', 'E', '', ['/O']],
        ['Mat', 'F', '', ['/O']],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'cameraMatrix1', '', ['/IO']],
        ['Mat', 'distCoeffs1', '', ['/IO']],
        ['Mat', 'cameraMatrix2', '', ['/IO']],
        ['Mat', 'distCoeffs2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/IO']],
        ['Mat', 'T', '', ['/IO']],
        ['Mat', 'E', '', ['/O']],
        ['Mat', 'F', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   'cv.stereoRectify',
    'void',
    [],
    [   ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'T', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 'P1', '', ['/O']],
        ['Mat', 'P2', '', ['/O']],
        ['Mat', 'Q', '', ['/O']],
        ['int', 'flags', 'CALIB_ZERO_DISPARITY', []],
        ['double', 'alpha', '-1', []],
        ['Size', 'newImageSize', 'Size()', []],
        ['Rect*', 'validPixROI1', '0', ['/O']],
        ['Rect*', 'validPixROI2', '0', ['/O']]],
    'void']
ok: FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>

--- Incoming ---
[   'cv.stereoRectifyUncalibrated',
    'bool',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'F', '', []],
        ['Size', 'imgSize', '', []],
        ['Mat', 'H1', '', ['/O']],
        ['Mat', 'H2', '', ['/O']],
        ['double', 'threshold', '5', []]],
    'bool']
ok: FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>

--- Incoming ---
[   'cv.rectify3Collinear',
    'float',
    [],
    [   ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['Mat', 'cameraMatrix3', '', []],
        ['Mat', 'distCoeffs3', '', []],
        ['vector_Mat', 'imgpt1', '', []],
        ['vector_Mat', 'imgpt3', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R12', '', []],
        ['Mat', 'T12', '', []],
        ['Mat', 'R13', '', []],
        ['Mat', 'T13', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 'R3', '', ['/O']],
        ['Mat', 'P1', '', ['/O']],
        ['Mat', 'P2', '', ['/O']],
        ['Mat', 'P3', '', ['/O']],
        ['Mat', 'Q', '', ['/O']],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', '', []],
        ['Rect*', 'roi1', '', ['/O']],
        ['Rect*', 'roi2', '', ['/O']],
        ['int', 'flags', '', []]],
    'float']
ok: FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>

--- Incoming ---
[   'cv.getOptimalNewCameraMatrix',
    'Mat',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', 'Size()', []],
        ['Rect*', 'validPixROI', '0', ['/O']],
        ['bool', 'centerPrincipalPoint', 'false', []]],
    'Mat']
ok: FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   'cv.calibrateHandEye',
    'void',
    [],
    [   ['vector_Mat', 'R_gripper2base', '', []],
        ['vector_Mat', 't_gripper2base', '', []],
        ['vector_Mat', 'R_target2cam', '', []],
        ['vector_Mat', 't_target2cam', '', []],
        ['Mat', 'R_cam2gripper', '', ['/O']],
        ['Mat', 't_cam2gripper', '', ['/O']],
        ['HandEyeCalibrationMethod', 'method', 'CALIB_HAND_EYE_TSAI', []]],
    'void']
ok: FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>

--- Incoming ---
[   'cv.calibrateRobotWorldHandEye',
    'void',
    [],
    [   ['vector_Mat', 'R_world2cam', '', []],
        ['vector_Mat', 't_world2cam', '', []],
        ['vector_Mat', 'R_base2gripper', '', []],
        ['vector_Mat', 't_base2gripper', '', []],
        ['Mat', 'R_base2world', '', ['/O']],
        ['Mat', 't_base2world', '', ['/O']],
        ['Mat', 'R_gripper2cam', '', ['/O']],
        ['Mat', 't_gripper2cam', '', ['/O']],
        [   'RobotWorldHandEyeCalibrationMethod',
            'method',
            'CALIB_ROBOT_WORLD_HAND_EYE_SHAH',
            []]],
    'void']
ok: FUNC <void cv..calibrateRobotWorldHandEye [ARG vector_Mat R_world2cam=, ARG vector_Mat t_world2cam=, ARG vector_Mat R_base2gripper=, ARG vector_Mat t_base2gripper=, ARG Mat R_base2world=, ARG Mat t_base2world=, ARG Mat R_gripper2cam=, ARG Mat t_gripper2cam=, ARG RobotWorldHandEyeCalibrationMethod method=CALIB_ROBOT_WORLD_HAND_EYE_SHAH]>

--- Incoming ---
[   'cv.convertPointsToHomogeneous',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.convertPointsFromHomogeneous',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['int', 'method', '', []],
        ['double', 'ransacReprojThreshold', '', []],
        ['double', 'confidence', '', []],
        ['int', 'maxIters', '', []],
        ['Mat', 'mask', 'Mat()', ['/O']]],
    'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=, ARG double ransacReprojThreshold=, ARG double confidence=, ARG int maxIters=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['int', 'method', 'FM_RANSAC', []],
        ['double', 'ransacReprojThreshold', '3.', []],
        ['double', 'confidence', '0.99', []],
        ['Mat', 'mask', 'Mat()', ['/O']]],
    'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'mask', '', ['/O']],
        ['UsacParams', 'params', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG Mat mask=, ARG UsacParams params=]>

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['int', 'maxIters', '1000', []],
        ['Mat', 'mask', 'Mat()', ['/O']]],
    'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG int maxIters=1000, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['int', 'maxIters', '1000', []],
        ['Mat', 'mask', 'Mat()', ['/O']]],
    'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG int maxIters=1000, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['Mat', 'mask', 'Mat()', ['/O']]],
    'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'dist_coeff1', '', []],
        ['Mat', 'dist_coeff2', '', []],
        ['Mat', 'mask', '', ['/O']],
        ['UsacParams', 'params', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat cameraMatrix2=, ARG Mat dist_coeff1=, ARG Mat dist_coeff2=, ARG Mat mask=, ARG UsacParams params=]>

--- Incoming ---
[   'cv.decomposeEssentialMat',
    'void',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 't', '', ['/O']]],
    'void']
ok: FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['Mat', 'E', '', ['/O']],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 't', '', ['/O']],
        ['int', 'method', 'cv::RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['Mat', 'mask', 'Mat()', ['/IO']]],
    'int']
ok: FUNC <int cv..recoverPose [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat E=, ARG Mat R=, ARG Mat t=, ARG int method=cv::RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 't', '', ['/O']],
        ['Mat', 'mask', 'Mat()', ['/IO']]],
    'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 't', '', ['/O']],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['Mat', 'mask', 'Mat()', ['/IO']]],
    'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 't', '', ['/O']],
        ['double', 'distanceThresh', '', []],
        ['Mat', 'mask', 'Mat()', ['/IO']],
        ['Mat', 'triangulatedPoints', 'Mat()', ['/O']]],
    'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>

--- Incoming ---
[   'cv.computeCorrespondEpilines',
    'void',
    [],
    [   ['Mat', 'points', '', []],
        ['int', 'whichImage', '', []],
        ['Mat', 'F', '', []],
        ['Mat', 'lines', '', ['/O']]],
    'void']
ok: FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>

--- Incoming ---
[   'cv.triangulatePoints',
    'void',
    [],
    [   ['Mat', 'projMatr1', '', []],
        ['Mat', 'projMatr2', '', []],
        ['Mat', 'projPoints1', '', []],
        ['Mat', 'projPoints2', '', []],
        ['Mat', 'points4D', '', ['/O']]],
    'void']
ok: FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>

--- Incoming ---
[   'cv.correctMatches',
    'void',
    [],
    [   ['Mat', 'F', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'newPoints1', '', ['/O']],
        ['Mat', 'newPoints2', '', ['/O']]],
    'void']
ok: FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>

--- Incoming ---
[   'cv.filterSpeckles',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['double', 'newVal', '', []],
        ['int', 'maxSpeckleSize', '', []],
        ['double', 'maxDiff', '', []],
        ['Mat', 'buf', 'Mat()', ['/IO']]],
    'void']
ok: FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>

--- Incoming ---
[   'cv.getValidDisparityROI',
    'Rect',
    [],
    [   ['Rect', 'roi1', '', []],
        ['Rect', 'roi2', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'blockSize', '', []]],
    'Rect']
ok: FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int blockSize=]>

--- Incoming ---
[   'cv.validateDisparity',
    'void',
    [],
    [   ['Mat', 'disparity', '', ['/IO']],
        ['Mat', 'cost', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'disp12MaxDisp', '1', []]],
    'void']
ok: FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>

--- Incoming ---
[   'cv.reprojectImageTo3D',
    'void',
    [],
    [   ['Mat', 'disparity', '', []],
        ['Mat', '_3dImage', '', ['/O']],
        ['Mat', 'Q', '', []],
        ['bool', 'handleMissingValues', 'false', []],
        ['int', 'ddepth', '-1', []]],
    'void']
ok: FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>

--- Incoming ---
[   'cv.sampsonDistance',
    'double',
    [],
    [['Mat', 'pt1', '', []], ['Mat', 'pt2', '', []], ['Mat', 'F', '', []]],
    'double']
ok: FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>

--- Incoming ---
[   'cv.estimateAffine3D',
    'int',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['Mat', 'out', '', ['/O']],
        ['Mat', 'inliers', '', ['/O']],
        ['double', 'ransacThreshold', '3', []],
        ['double', 'confidence', '0.99', []]],
    'int']
ok: FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   'cv.estimateAffine3D',
    'Mat',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['double*', 'scale', 'nullptr', ['/O']],
        ['bool', 'force_rotation', 'true', []]],
    'cv::Mat']
ok: FUNC <Mat cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG double * scale=nullptr, ARG bool force_rotation=true]>

--- Incoming ---
[   'cv.estimateTranslation3D',
    'int',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['Mat', 'out', '', ['/O']],
        ['Mat', 'inliers', '', ['/O']],
        ['double', 'ransacThreshold', '3', []],
        ['double', 'confidence', '0.99', []]],
    'int']
ok: FUNC <int cv..estimateTranslation3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   'cv.estimateAffine2D',
    'Mat',
    [],
    [   ['Mat', 'from', '', []],
        ['Mat', 'to', '', []],
        ['Mat', 'inliers', 'Mat()', ['/O']],
        ['int', 'method', 'RANSAC', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['size_t', 'maxIters', '2000', []],
        ['double', 'confidence', '0.99', []],
        ['size_t', 'refineIters', '10', []]],
    'cv::Mat']
ok: FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   'cv.estimateAffine2D',
    'Mat',
    [],
    [   ['Mat', 'pts1', '', []],
        ['Mat', 'pts2', '', []],
        ['Mat', 'inliers', '', ['/O']],
        ['UsacParams', 'params', '', ['/C', '/Ref']]],
    'cv::Mat']
ok: FUNC <Mat cv..estimateAffine2D [ARG Mat pts1=, ARG Mat pts2=, ARG Mat inliers=, ARG UsacParams params=]>

--- Incoming ---
[   'cv.estimateAffinePartial2D',
    'Mat',
    [],
    [   ['Mat', 'from', '', []],
        ['Mat', 'to', '', []],
        ['Mat', 'inliers', 'Mat()', ['/O']],
        ['int', 'method', 'RANSAC', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['size_t', 'maxIters', '2000', []],
        ['double', 'confidence', '0.99', []],
        ['size_t', 'refineIters', '10', []]],
    'cv::Mat']
ok: FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   'cv.decomposeHomographyMat',
    'int',
    [],
    [   ['Mat', 'H', '', []],
        ['Mat', 'K', '', []],
        ['vector_Mat', 'rotations', '', ['/O']],
        ['vector_Mat', 'translations', '', ['/O']],
        ['vector_Mat', 'normals', '', ['/O']]],
    'int']
ok: FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>

--- Incoming ---
[   'cv.filterHomographyDecompByVisibleRefpoints',
    'void',
    [],
    [   ['vector_Mat', 'rotations', '', []],
        ['vector_Mat', 'normals', '', []],
        ['Mat', 'beforePoints', '', []],
        ['Mat', 'afterPoints', '', []],
        ['Mat', 'possibleSolutions', '', ['/O']],
        ['Mat', 'pointsMask', 'Mat()', []]],
    'void']
ok: FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>

--- Incoming ---
['class cv.StereoMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.StereoMatcher : Algorithm, name: StereoMatcher, base: Algorithm

--- Incoming ---
[   'enum cv.StereoMatcher.<unnamed>',
    '',
    [],
    [   ['const cv.StereoMatcher.DISP_SHIFT', '4', [], [], None, ''],
        [   'const cv.StereoMatcher.DISP_SCALE',
            '(1 << DISP_SHIFT)',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DISP_SHIFT=4
ok: CONST DISP_SCALE=(1 << DISP_SHIFT)

--- Incoming ---
[   'cv.StereoMatcher.compute',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'left', '', []],
        ['Mat', 'right', '', []],
        ['Mat', 'disparity', '', ['/O']]],
    'void']
ok: FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>

--- Incoming ---
['cv.StereoMatcher.getMinDisparity', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getMinDisparity []>

--- Incoming ---
[   'cv.StereoMatcher.setMinDisparity',
    'void',
    ['/V', '/PV'],
    [['int', 'minDisparity', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>

--- Incoming ---
['cv.StereoMatcher.getNumDisparities', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getNumDisparities []>

--- Incoming ---
[   'cv.StereoMatcher.setNumDisparities',
    'void',
    ['/V', '/PV'],
    [['int', 'numDisparities', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>

--- Incoming ---
['cv.StereoMatcher.getBlockSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getBlockSize []>

--- Incoming ---
[   'cv.StereoMatcher.setBlockSize',
    'void',
    ['/V', '/PV'],
    [['int', 'blockSize', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>

--- Incoming ---
['cv.StereoMatcher.getSpeckleWindowSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleWindowSize',
    'void',
    ['/V', '/PV'],
    [['int', 'speckleWindowSize', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>

--- Incoming ---
['cv.StereoMatcher.getSpeckleRange', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleRange []>

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleRange',
    'void',
    ['/V', '/PV'],
    [['int', 'speckleRange', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>

--- Incoming ---
['cv.StereoMatcher.getDisp12MaxDiff', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>

--- Incoming ---
[   'cv.StereoMatcher.setDisp12MaxDiff',
    'void',
    ['/V', '/PV'],
    [['int', 'disp12MaxDiff', '', []]],
    'void']
ok: FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>

--- Incoming ---
['class cv.StereoBM', ': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoBM : StereoMatcher, name: StereoBM, base: StereoMatcher

--- Incoming ---
[   'enum cv.StereoBM.<unnamed>',
    '',
    [],
    [   [   'const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE',
            '0',
            [],
            [],
            None,
            ''],
        ['const cv.StereoBM.PREFILTER_XSOBEL', '1', [], [], None, '']],
    None]
ok: CONST PREFILTER_NORMALIZED_RESPONSE=0
ok: CONST PREFILTER_XSOBEL=1

--- Incoming ---
['cv.StereoBM.getPreFilterType', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getPreFilterType []>

--- Incoming ---
[   'cv.StereoBM.setPreFilterType',
    'void',
    ['/V', '/PV'],
    [['int', 'preFilterType', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>

--- Incoming ---
['cv.StereoBM.getPreFilterSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getPreFilterSize []>

--- Incoming ---
[   'cv.StereoBM.setPreFilterSize',
    'void',
    ['/V', '/PV'],
    [['int', 'preFilterSize', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>

--- Incoming ---
['cv.StereoBM.getPreFilterCap', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getPreFilterCap []>

--- Incoming ---
[   'cv.StereoBM.setPreFilterCap',
    'void',
    ['/V', '/PV'],
    [['int', 'preFilterCap', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
['cv.StereoBM.getTextureThreshold', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getTextureThreshold []>

--- Incoming ---
[   'cv.StereoBM.setTextureThreshold',
    'void',
    ['/V', '/PV'],
    [['int', 'textureThreshold', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>

--- Incoming ---
['cv.StereoBM.getUniquenessRatio', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getUniquenessRatio []>

--- Incoming ---
[   'cv.StereoBM.setUniquenessRatio',
    'void',
    ['/V', '/PV'],
    [['int', 'uniquenessRatio', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
['cv.StereoBM.getSmallerBlockSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoBM.getSmallerBlockSize []>

--- Incoming ---
[   'cv.StereoBM.setSmallerBlockSize',
    'void',
    ['/V', '/PV'],
    [['int', 'blockSize', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>

--- Incoming ---
['cv.StereoBM.getROI1', 'Rect', ['/C', '/V', '/PV'], [], 'Rect']
ok: FUNC <Rect cv.StereoBM.getROI1 []>

--- Incoming ---
[   'cv.StereoBM.setROI1',
    'void',
    ['/V', '/PV'],
    [['Rect', 'roi1', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>

--- Incoming ---
['cv.StereoBM.getROI2', 'Rect', ['/C', '/V', '/PV'], [], 'Rect']
ok: FUNC <Rect cv.StereoBM.getROI2 []>

--- Incoming ---
[   'cv.StereoBM.setROI2',
    'void',
    ['/V', '/PV'],
    [['Rect', 'roi2', '', []]],
    'void']
ok: FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>

--- Incoming ---
[   'cv.StereoBM.create',
    'Ptr_StereoBM',
    ['/S'],
    [['int', 'numDisparities', '0', []], ['int', 'blockSize', '21', []]],
    'Ptr<StereoBM>']
ok: FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>

--- Incoming ---
['class cv.StereoSGBM', ': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoSGBM : StereoMatcher, name: StereoSGBM, base: StereoMatcher

--- Incoming ---
[   'enum cv.StereoSGBM.<unnamed>',
    '',
    [],
    [   ['const cv.StereoSGBM.MODE_SGBM', '0', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_HH', '1', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_SGBM_3WAY', '2', [], [], None, ''],
        ['const cv.StereoSGBM.MODE_HH4', '3', [], [], None, '']],
    None]
ok: CONST MODE_SGBM=0
ok: CONST MODE_HH=1
ok: CONST MODE_SGBM_3WAY=2
ok: CONST MODE_HH4=3

--- Incoming ---
['cv.StereoSGBM.getPreFilterCap', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoSGBM.getPreFilterCap []>

--- Incoming ---
[   'cv.StereoSGBM.setPreFilterCap',
    'void',
    ['/V', '/PV'],
    [['int', 'preFilterCap', '', []]],
    'void']
ok: FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
['cv.StereoSGBM.getUniquenessRatio', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoSGBM.getUniquenessRatio []>

--- Incoming ---
[   'cv.StereoSGBM.setUniquenessRatio',
    'void',
    ['/V', '/PV'],
    [['int', 'uniquenessRatio', '', []]],
    'void']
ok: FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
['cv.StereoSGBM.getP1', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoSGBM.getP1 []>

--- Incoming ---
['cv.StereoSGBM.setP1', 'void', ['/V', '/PV'], [['int', 'P1', '', []]], 'void']
ok: FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>

--- Incoming ---
['cv.StereoSGBM.getP2', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoSGBM.getP2 []>

--- Incoming ---
['cv.StereoSGBM.setP2', 'void', ['/V', '/PV'], [['int', 'P2', '', []]], 'void']
ok: FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>

--- Incoming ---
['cv.StereoSGBM.getMode', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.StereoSGBM.getMode []>

--- Incoming ---
[   'cv.StereoSGBM.setMode',
    'void',
    ['/V', '/PV'],
    [['int', 'mode', '', []]],
    'void']
ok: FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>

--- Incoming ---
[   'cv.StereoSGBM.create',
    'Ptr_StereoSGBM',
    ['/S'],
    [   ['int', 'minDisparity', '0', []],
        ['int', 'numDisparities', '16', []],
        ['int', 'blockSize', '3', []],
        ['int', 'P1', '0', []],
        ['int', 'P2', '0', []],
        ['int', 'disp12MaxDiff', '0', []],
        ['int', 'preFilterCap', '0', []],
        ['int', 'uniquenessRatio', '0', []],
        ['int', 'speckleWindowSize', '0', []],
        ['int', 'speckleRange', '0', []],
        ['int', 'mode', 'StereoSGBM::MODE_SGBM', []]],
    'Ptr<StereoSGBM>']
ok: FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>

--- Incoming ---
[   'enum cv.UndistortTypes',
    '',
    [],
    [   ['const cv.PROJ_SPHERICAL_ORTHO', '0', [], [], None, ''],
        ['const cv.PROJ_SPHERICAL_EQRECT', '1', [], [], None, '']],
    None]
ok: CONST PROJ_SPHERICAL_ORTHO=0
ok: CONST PROJ_SPHERICAL_EQRECT=1

--- Incoming ---
[   'cv.undistort',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'newCameraMatrix', 'Mat()', []]],
    'void']
ok: FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>

--- Incoming ---
[   'cv.initUndistortRectifyMap',
    'void',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'newCameraMatrix', '', []],
        ['Size', 'size', '', []],
        ['int', 'm1type', '', []],
        ['Mat', 'map1', '', ['/O']],
        ['Mat', 'map2', '', ['/O']]],
    'void']
ok: FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   'cv.initInverseRectificationMap',
    'void',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'newCameraMatrix', '', []],
        ['Size', 'size', '', ['/C', '/Ref']],
        ['int', 'm1type', '', []],
        ['Mat', 'map1', '', ['/O']],
        ['Mat', 'map2', '', ['/O']]],
    'void']
ok: FUNC <void cv..initInverseRectificationMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   'cv.getDefaultNewCameraMatrix',
    'Mat',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Size', 'imgsize', 'Size()', []],
        ['bool', 'centerPrincipalPoint', 'false', []]],
    'Mat']
ok: FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   'cv.undistortPoints',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'R', 'Mat()', []],
        ['Mat', 'P', 'Mat()', []]],
    'void']
ok: FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   'cv.undistortPoints',
    'void',
    ['=undistortPointsIter'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'P', '', []],
        ['TermCriteria', 'criteria', '', []]],
    'void']
ok: FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>

--- Incoming ---
[   'cv.undistortImagePoints',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        [   'TermCriteria',
            'arg1',
            'TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01)',
            []]],
    'void']
ok: FUNC <void cv..undistortImagePoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01)]>

--- Incoming ---
[   'enum cv.fisheye.<unnamed>',
    '',
    [],
    [   [   'const cv.fisheye.CALIB_USE_INTRINSIC_GUESS',
            '1 << 0',
            [],
            [],
            None,
            ''],
        [   'const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC',
            '1 << 1',
            [],
            [],
            None,
            ''],
        ['const cv.fisheye.CALIB_CHECK_COND', '1 << 2', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_SKEW', '1 << 3', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K1', '1 << 4', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K2', '1 << 5', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K3', '1 << 6', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_K4', '1 << 7', [], [], None, ''],
        ['const cv.fisheye.CALIB_FIX_INTRINSIC', '1 << 8', [], [], None, ''],
        [   'const cv.fisheye.CALIB_FIX_PRINCIPAL_POINT',
            '1 << 9',
            [],
            [],
            None,
            ''],
        ['const cv.fisheye.CALIB_ZERO_DISPARITY', '1 << 10', [], [], None, ''],
        [   'const cv.fisheye.CALIB_FIX_FOCAL_LENGTH',
            '1 << 11',
            [],
            [],
            None,
            '']],
    None]
ok: CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0
ok: CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1
ok: CONST fisheye_CALIB_CHECK_COND=1 << 2
ok: CONST fisheye_CALIB_FIX_SKEW=1 << 3
ok: CONST fisheye_CALIB_FIX_K1=1 << 4
ok: CONST fisheye_CALIB_FIX_K2=1 << 5
ok: CONST fisheye_CALIB_FIX_K3=1 << 6
ok: CONST fisheye_CALIB_FIX_K4=1 << 7
ok: CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8
ok: CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9
ok: CONST fisheye_CALIB_ZERO_DISPARITY=1 << 10
ok: CONST fisheye_CALIB_FIX_FOCAL_LENGTH=1 << 11

--- Incoming ---
[   'cv.fisheye.projectPoints',
    'void',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', ['/O']],
        ['Mat', 'rvec', '', []],
        ['Mat', 'tvec', '', []],
        ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['double', 'alpha', '0', []],
        ['Mat', 'jacobian', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   'cv.fisheye.distortPoints',
    'void',
    [],
    [   ['Mat', 'undistorted', '', []],
        ['Mat', 'distorted', '', ['/O']],
        ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['double', 'alpha', '0', []]],
    'void']
ok: FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>

--- Incoming ---
[   'cv.fisheye.undistortPoints',
    'void',
    [],
    [   ['Mat', 'distorted', '', []],
        ['Mat', 'undistorted', '', ['/O']],
        ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['Mat', 'R', 'Mat()', []],
        ['Mat', 'P', 'Mat()', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, '
            '1e-8)',
            []]],
    'void']
ok: FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat(), ARG TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8)]>

--- Incoming ---
[   'cv.fisheye.initUndistortRectifyMap',
    'void',
    [],
    [   ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'P', '', []],
        ['Size', 'size', '', ['/C', '/Ref']],
        ['int', 'm1type', '', []],
        ['Mat', 'map1', '', ['/O']],
        ['Mat', 'map2', '', ['/O']]],
    'void']
ok: FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   'cv.fisheye.undistortImage',
    'void',
    [],
    [   ['Mat', 'distorted', '', []],
        ['Mat', 'undistorted', '', ['/O']],
        ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['Mat', 'Knew', 'cv::Mat()', []],
        ['Size', 'new_size', 'Size()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>

--- Incoming ---
[   'cv.fisheye.estimateNewCameraMatrixForUndistortRectify',
    'void',
    [],
    [   ['Mat', 'K', '', []],
        ['Mat', 'D', '', []],
        ['Size', 'image_size', '', ['/C', '/Ref']],
        ['Mat', 'R', '', []],
        ['Mat', 'P', '', ['/O']],
        ['double', 'balance', '0.0', []],
        ['Size', 'new_size', 'Size()', ['/C', '/Ref']],
        ['double', 'fov_scale', '1.0', []]],
    'void']
ok: FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>

--- Incoming ---
[   'cv.fisheye.calibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'image_size', '', ['/C', '/Ref']],
        ['Mat', 'K', '', ['/IO']],
        ['Mat', 'D', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   'cv.fisheye.stereoRectify',
    'void',
    [],
    [   ['Mat', 'K1', '', []],
        ['Mat', 'D1', '', []],
        ['Mat', 'K2', '', []],
        ['Mat', 'D2', '', []],
        ['Size', 'imageSize', '', ['/C', '/Ref']],
        ['Mat', 'R', '', []],
        ['Mat', 'tvec', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 'P1', '', ['/O']],
        ['Mat', 'P2', '', ['/O']],
        ['Mat', 'Q', '', ['/O']],
        ['int', 'flags', '', []],
        ['Size', 'newImageSize', 'Size()', ['/C', '/Ref']],
        ['double', 'balance', '0.0', []],
        ['double', 'fov_scale', '1.0', []]],
    'void']
ok: FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>

--- Incoming ---
[   'cv.fisheye.stereoCalibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'K1', '', ['/IO']],
        ['Mat', 'D1', '', ['/IO']],
        ['Mat', 'K2', '', ['/IO']],
        ['Mat', 'D2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 'T', '', ['/O']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['int', 'flags', 'fisheye::CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   'cv.fisheye.stereoCalibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'K1', '', ['/IO']],
        ['Mat', 'D1', '', ['/IO']],
        ['Mat', 'K2', '', ['/IO']],
        ['Mat', 'D2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 'T', '', ['/O']],
        ['int', 'flags', 'fisheye::CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, '
            'DBL_EPSILON)',
            []]],
    'double']
ok: FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d/calib3d.hpp =====
Namespaces: ['', 'cv', 'cv.fisheye']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/calib3d/include/opencv2/calib3d/calib3d.hpp


===== Generating... =====
CLASS cv::.Calib3d : 
[CONST CV_ITERATIVE=0, CONST CV_EPNP=1, CONST CV_P3P=2, CONST CV_DLS=3, CONST CvLevMarq_DONE=0, CONST CvLevMarq_STARTED=1, CONST CvLevMarq_CALC_J=2, CONST CvLevMarq_CHECK_ERR=3, CONST LMEDS=4, CONST RANSAC=8, CONST RHO=16, CONST USAC_DEFAULT=32, CONST USAC_PARALLEL=33, CONST USAC_FM_8PTS=34, CONST USAC_FAST=35, CONST USAC_ACCURATE=36, CONST USAC_PROSAC=37, CONST USAC_MAGSAC=38, CONST CALIB_CB_ADAPTIVE_THRESH=1, CONST CALIB_CB_NORMALIZE_IMAGE=2, CONST CALIB_CB_FILTER_QUADS=4, CONST CALIB_CB_FAST_CHECK=8, CONST CALIB_CB_EXHAUSTIVE=16, CONST CALIB_CB_ACCURACY=32, CONST CALIB_CB_LARGER=64, CONST CALIB_CB_MARKER=128, CONST CALIB_CB_SYMMETRIC_GRID=1, CONST CALIB_CB_ASYMMETRIC_GRID=2, CONST CALIB_CB_CLUSTERING=4, CONST CALIB_NINTRINSIC=18, CONST CALIB_USE_INTRINSIC_GUESS=0x00001, CONST CALIB_FIX_ASPECT_RATIO=0x00002, CONST CALIB_FIX_PRINCIPAL_POINT=0x00004, CONST CALIB_ZERO_TANGENT_DIST=0x00008, CONST CALIB_FIX_FOCAL_LENGTH=0x00010, CONST CALIB_FIX_K1=0x00020, CONST CALIB_FIX_K2=0x00040, CONST CALIB_FIX_K3=0x00080, CONST CALIB_FIX_K4=0x00800, CONST CALIB_FIX_K5=0x01000, CONST CALIB_FIX_K6=0x02000, CONST CALIB_RATIONAL_MODEL=0x04000, CONST CALIB_THIN_PRISM_MODEL=0x08000, CONST CALIB_FIX_S1_S2_S3_S4=0x10000, CONST CALIB_TILTED_MODEL=0x40000, CONST CALIB_FIX_TAUX_TAUY=0x80000, CONST CALIB_USE_QR=0x100000, CONST CALIB_FIX_TANGENT_DIST=0x200000, CONST CALIB_FIX_INTRINSIC=0x00100, CONST CALIB_SAME_FOCAL_LENGTH=0x00200, CONST CALIB_ZERO_DISPARITY=0x00400, CONST CALIB_USE_LU=(1 << 17), CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22), CONST FM_7POINT=1, CONST FM_8POINT=2, CONST FM_LMEDS=4, CONST FM_RANSAC=8, CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0, CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1, CONST fisheye_CALIB_CHECK_COND=1 << 2, CONST fisheye_CALIB_FIX_SKEW=1 << 3, CONST fisheye_CALIB_FIX_K1=1 << 4, CONST fisheye_CALIB_FIX_K2=1 << 5, CONST fisheye_CALIB_FIX_K3=1 << 6, CONST fisheye_CALIB_FIX_K4=1 << 7, CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8, CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9, CONST fisheye_CALIB_ZERO_DISPARITY=1 << 10, CONST fisheye_CALIB_FIX_FOCAL_LENGTH=1 << 11]
[CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0, CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1]
[CONST CALIB_HAND_EYE_TSAI=0, CONST CALIB_HAND_EYE_PARK=1, CONST CALIB_HAND_EYE_HORAUD=2, CONST CALIB_HAND_EYE_ANDREFF=3, CONST CALIB_HAND_EYE_DANIILIDIS=4]
[CONST LOCAL_OPTIM_NULL=0, CONST LOCAL_OPTIM_INNER_LO=1, CONST LOCAL_OPTIM_INNER_AND_ITER_LO=2, CONST LOCAL_OPTIM_GC=3, CONST LOCAL_OPTIM_SIGMA=4]
[CONST NEIGH_FLANN_KNN=0, CONST NEIGH_GRID=1, CONST NEIGH_FLANN_RADIUS=2]
[CONST CALIB_ROBOT_WORLD_HAND_EYE_SHAH=0, CONST CALIB_ROBOT_WORLD_HAND_EYE_LI=1]
[CONST SAMPLING_UNIFORM=0, CONST SAMPLING_PROGRESSIVE_NAPSAC=1, CONST SAMPLING_NAPSAC=2, CONST SAMPLING_PROSAC=3]
[CONST SCORE_METHOD_RANSAC=0, CONST SCORE_METHOD_MSAC=1, CONST SCORE_METHOD_MAGSAC=2, CONST SCORE_METHOD_LMEDS=3]
[CONST SOLVEPNP_ITERATIVE=0, CONST SOLVEPNP_EPNP=1, CONST SOLVEPNP_P3P=2, CONST SOLVEPNP_DLS=3, CONST SOLVEPNP_UPNP=4, CONST SOLVEPNP_AP3P=5, CONST SOLVEPNP_IPPE=6, CONST SOLVEPNP_IPPE_SQUARE=7, CONST SOLVEPNP_SQPNP=8, CONST SOLVEPNP_MAX_COUNT=8+1]
[CONST PROJ_SPHERICAL_ORTHO=0, CONST PROJ_SPHERICAL_EQRECT=1]
FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>
java: void Rodrigues(Mat src, Mat dst, Mat jacobian)
java: void Rodrigues(Mat src, Mat dst)
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters, double confidence)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints)
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG Mat mask=, ARG UsacParams params=]>
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, Mat mask, UsacParams params)
FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy, Mat Qz)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ)
FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ, Mat eulerAngles)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect)
FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>
java: void matMulDeriv(Mat A, Mat B, Mat dABdA, Mat dABdB)
FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2, Mat dt3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3)
FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian, double aspectRatio)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints)
FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int flags)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers, int flags)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat inliers=, ARG UsacParams params=UsacParams()]>
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, Mat inliers, UsacParams params)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, Mat inliers)
FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>
java: int solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria, double VVSlambda)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec, Mat reprojectionError)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize, double aspectRatio)
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize)
FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, int flags)
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners)
FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>
java: boolean checkChessboard(Mat img, Size size)
FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=, ARG Mat meta=]>
java: boolean findChessboardCornersSBWithMeta(Mat image, Size patternSize, Mat corners, int flags, Mat meta)
FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners, int flags)
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners)
FUNC <Scalar cv..estimateChessboardSharpness [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG float rise_distance=0.8F, ARG bool vertical=false, ARG Mat sharpness=Mat()]>
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical, Mat sharpness)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners)
FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>
java: boolean find4QuadCornerSubpix(Mat img, Mat corners, Size region_size)
FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>
java: void drawChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, boolean patternWasFound)
FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness)
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length)
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>
SKIP:bool cv::findCirclesGrid(Mat image, Size patternSize, Mat& centers, int flags, Ptr_FeatureDetector blobDetector, CirclesGridFinderParameters parameters)	 due to ARG type Ptr_FeatureDetector/I
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags, TermCriteria criteria)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints)
FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>
java: void calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double[] fovx, double[] fovy, double[] focalLength, Point principalPoint, double[] aspectRatio)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, List<Mat> rvecs, List<Mat> tvecs, Mat perViewErrors, int flags, TermCriteria criteria)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, List<Mat> rvecs, List<Mat> tvecs, Mat perViewErrors, int flags)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, List<Mat> rvecs, List<Mat> tvecs, Mat perViewErrors)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags, TermCriteria criteria)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags, TermCriteria criteria)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors)
FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1, Rect validPixROI2)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q)
FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2, double threshold)
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2)
FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>
java: float rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, List<Mat> imgpt1, List<Mat> imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat R1, Mat R2, Mat R3, Mat P1, Mat P2, Mat P3, Mat Q, double alpha, Size newImgSize, Rect roi1, Rect roi2, int flags)
FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI, boolean centerPrincipalPoint)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha)
FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper, int method)
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper)
FUNC <void cv..calibrateRobotWorldHandEye [ARG vector_Mat R_world2cam=, ARG vector_Mat t_world2cam=, ARG vector_Mat R_base2gripper=, ARG vector_Mat t_base2gripper=, ARG Mat R_base2world=, ARG Mat t_base2world=, ARG Mat R_gripper2cam=, ARG Mat t_gripper2cam=, ARG RobotWorldHandEyeCalibrationMethod method=CALIB_ROBOT_WORLD_HAND_EYE_SHAH]>
java: void calibrateRobotWorldHandEye(List<Mat> R_world2cam, List<Mat> t_world2cam, List<Mat> R_base2gripper, List<Mat> t_base2gripper, Mat R_base2world, Mat t_base2world, Mat R_gripper2cam, Mat t_gripper2cam, int method)
java: void calibrateRobotWorldHandEye(List<Mat> R_world2cam, List<Mat> t_world2cam, List<Mat> R_base2gripper, List<Mat> t_base2gripper, Mat R_base2world, Mat t_base2world, Mat R_gripper2cam, Mat t_gripper2cam)
FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsToHomogeneous(Mat src, Mat dst)
FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsFromHomogeneous(Mat src, Mat dst)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=, ARG double ransacReprojThreshold=, ARG double confidence=, ARG int maxIters=, ARG Mat mask=Mat()]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters, Mat mask)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, Mat mask)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG Mat mask=, ARG UsacParams params=]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, Mat mask, UsacParams params)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG int maxIters=1000, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold, int maxIters, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold, int maxIters)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG int maxIters=1000, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold, int maxIters, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold, int maxIters)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal)
java: Mat findEssentialMat(Mat points1, Mat points2)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob, double threshold, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat cameraMatrix2=, ARG Mat dist_coeff1=, ARG Mat dist_coeff2=, ARG Mat mask=, ARG UsacParams params=]>
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix1, Mat cameraMatrix2, Mat dist_coeff1, Mat dist_coeff2, Mat mask, UsacParams params)
FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>
java: void decomposeEssentialMat(Mat E, Mat R1, Mat R2, Mat t)
FUNC <int cv..recoverPose [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat E=, ARG Mat R=, ARG Mat t=, ARG int method=cv::RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: int recoverPose(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat E, Mat R, Mat t, int method, double prob, double threshold, Mat mask)
java: int recoverPose(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat E, Mat R, Mat t, int method, double prob, double threshold)
java: int recoverPose(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat E, Mat R, Mat t, int method, double prob)
java: int recoverPose(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat E, Mat R, Mat t, int method)
java: int recoverPose(Mat points1, Mat points2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat E, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask, Mat triangulatedPoints)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh)
FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>
java: void computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat lines)
FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>
java: void triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat points4D)
FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>
java: void correctMatches(Mat F, Mat points1, Mat points2, Mat newPoints1, Mat newPoints2)
FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff, Mat buf)
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff)
FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int blockSize=]>
java: Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int blockSize)
FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp)
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities)
FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues, int ddepth)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q)
FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>
java: double sampsonDistance(Mat pt1, Mat pt2, Mat F)
FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers)
FUNC <Mat cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG double * scale=nullptr, ARG bool force_rotation=true]>
java: Mat estimateAffine3D(Mat src, Mat dst, double[] scale, boolean force_rotation)
java: Mat estimateAffine3D(Mat src, Mat dst, double[] scale)
java: Mat estimateAffine3D(Mat src, Mat dst)
FUNC <int cv..estimateTranslation3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
java: int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence)
java: int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold)
java: int estimateTranslation3D(Mat src, Mat dst, Mat out, Mat inliers)
FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffine2D(Mat from, Mat to)
FUNC <Mat cv..estimateAffine2D [ARG Mat pts1=, ARG Mat pts2=, ARG Mat inliers=, ARG UsacParams params=]>
java: Mat estimateAffine2D(Mat pts1, Mat pts2, Mat inliers, UsacParams params)
FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffinePartial2D(Mat from, Mat to)
FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>
java: int decomposeHomographyMat(Mat H, Mat K, List<Mat> rotations, List<Mat> translations, List<Mat> normals)
FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions, Mat pointsMask)
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions)
FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix)
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv..initInverseRectificationMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void initInverseRectificationMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2)
FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize, boolean centerPrincipalPoint)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix)
FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>
java: void undistortPointsIter(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)
FUNC <void cv..undistortImagePoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01)]>
java: void undistortImagePoints(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, TermCriteria arg1)
java: void undistortImagePoints(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha, Mat jacobian)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D)
FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D, double alpha)
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D)
FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat(), ARG TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8)]>
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R, Mat P, TermCriteria criteria)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R, Mat P)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D)
FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void fisheye_initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew, Size new_size)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D)
FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size, double fov_scale)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P)
FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs)
FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance, double fov_scale)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags, TermCriteria criteria)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T)
CLASS cv::.StereoBM : StereoMatcher
[CONST PREFILTER_NORMALIZED_RESPONSE=0, CONST PREFILTER_XSOBEL=1]
FUNC <int cv.StereoBM.getPreFilterType []>
java: int getPreFilterType()
FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>
java: void setPreFilterType(int preFilterType)
FUNC <int cv.StereoBM.getPreFilterSize []>
java: int getPreFilterSize()
FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>
java: void setPreFilterSize(int preFilterSize)
FUNC <int cv.StereoBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <int cv.StereoBM.getTextureThreshold []>
java: int getTextureThreshold()
FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>
java: void setTextureThreshold(int textureThreshold)
FUNC <int cv.StereoBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
FUNC <int cv.StereoBM.getSmallerBlockSize []>
java: int getSmallerBlockSize()
FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>
java: void setSmallerBlockSize(int blockSize)
FUNC <Rect cv.StereoBM.getROI1 []>
java: Rect getROI1()
FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>
java: void setROI1(Rect roi1)
FUNC <Rect cv.StereoBM.getROI2 []>
java: Rect getROI2()
FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>
java: void setROI2(Rect roi2)
FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>
java: StereoBM create(int numDisparities, int blockSize)
java: StereoBM create(int numDisparities)
java: StereoBM create()
CLASS cv::.StereoMatcher : Algorithm
[CONST DISP_SHIFT=4, CONST DISP_SCALE=(1 << DISP_SHIFT)]
FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>
java: void compute(Mat left, Mat right, Mat disparity)
FUNC <int cv.StereoMatcher.getMinDisparity []>
java: int getMinDisparity()
FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>
java: void setMinDisparity(int minDisparity)
FUNC <int cv.StereoMatcher.getNumDisparities []>
java: int getNumDisparities()
FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>
java: void setNumDisparities(int numDisparities)
FUNC <int cv.StereoMatcher.getBlockSize []>
java: int getBlockSize()
FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>
java: int getSpeckleWindowSize()
FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>
java: void setSpeckleWindowSize(int speckleWindowSize)
FUNC <int cv.StereoMatcher.getSpeckleRange []>
java: int getSpeckleRange()
FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>
java: void setSpeckleRange(int speckleRange)
FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>
java: int getDisp12MaxDiff()
FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>
java: void setDisp12MaxDiff(int disp12MaxDiff)
CLASS cv::.StereoSGBM : StereoMatcher
[CONST MODE_SGBM=0, CONST MODE_HH=1, CONST MODE_SGBM_3WAY=2, CONST MODE_HH4=3]
FUNC <int cv.StereoSGBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <int cv.StereoSGBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
FUNC <int cv.StereoSGBM.getP1 []>
java: int getP1()
FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>
java: void setP1(int P1)
FUNC <int cv.StereoSGBM.getP2 []>
java: int getP2()
FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>
java: void setP2(int P2)
FUNC <int cv.StereoSGBM.getMode []>
java: int getMode()
FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>
java: void setMode(int mode)
FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, int mode)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize)
java: StereoSGBM create(int minDisparity, int numDisparities)
java: StereoSGBM create(int minDisparity)
java: StereoSGBM create()
CLASS cv::.UsacParams : 
FUNC < cv.UsacParams.UsacParams []>
java:  UsacParams()
FUNC <double cv.UsacParams.get_confidence []>
java: double get_confidence()
FUNC <void cv.UsacParams.set_confidence [ARG double confidence=]>
java: void set_confidence(double confidence)
FUNC <bool cv.UsacParams.get_isParallel []>
java: boolean get_isParallel()
FUNC <void cv.UsacParams.set_isParallel [ARG bool isParallel=]>
java: void set_isParallel(boolean isParallel)
FUNC <int cv.UsacParams.get_loIterations []>
java: int get_loIterations()
FUNC <void cv.UsacParams.set_loIterations [ARG int loIterations=]>
java: void set_loIterations(int loIterations)
FUNC <LocalOptimMethod cv.UsacParams.get_loMethod []>
java: int get_loMethod()
FUNC <void cv.UsacParams.set_loMethod [ARG LocalOptimMethod loMethod=]>
java: void set_loMethod(int loMethod)
FUNC <int cv.UsacParams.get_loSampleSize []>
java: int get_loSampleSize()
FUNC <void cv.UsacParams.set_loSampleSize [ARG int loSampleSize=]>
java: void set_loSampleSize(int loSampleSize)
FUNC <int cv.UsacParams.get_maxIterations []>
java: int get_maxIterations()
FUNC <void cv.UsacParams.set_maxIterations [ARG int maxIterations=]>
java: void set_maxIterations(int maxIterations)
FUNC <NeighborSearchMethod cv.UsacParams.get_neighborsSearch []>
java: int get_neighborsSearch()
FUNC <void cv.UsacParams.set_neighborsSearch [ARG NeighborSearchMethod neighborsSearch=]>
java: void set_neighborsSearch(int neighborsSearch)
FUNC <int cv.UsacParams.get_randomGeneratorState []>
java: int get_randomGeneratorState()
FUNC <void cv.UsacParams.set_randomGeneratorState [ARG int randomGeneratorState=]>
java: void set_randomGeneratorState(int randomGeneratorState)
FUNC <SamplingMethod cv.UsacParams.get_sampler []>
java: int get_sampler()
FUNC <void cv.UsacParams.set_sampler [ARG SamplingMethod sampler=]>
java: void set_sampler(int sampler)
FUNC <ScoreMethod cv.UsacParams.get_score []>
java: int get_score()
FUNC <void cv.UsacParams.set_score [ARG ScoreMethod score=]>
java: void set_score(int score)
FUNC <double cv.UsacParams.get_threshold []>
java: double get_threshold()
FUNC <void cv.UsacParams.set_threshold [ARG double threshold=]>
java: void set_threshold(double threshold)

=== MODULE: highgui (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/highgui) ===


Files (0):
[]

Common headers (0):
[]
No generated code for module: highgui

=== MODULE: objdetect (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect) ===


Files (8):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_detector.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/charuco_detector.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_board.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_dictionary.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/objdetect.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/face.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Objdetect : , name: Objdetect, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect.hpp =====
Namespaces: ['cv']

--- Incoming ---
[   'cv.groupRectangles',
    'void',
    [],
    [   ['vector_Rect', 'rectList', '', ['/IO', '/Ref']],
        ['vector_int', 'weights', '', ['/O', '/Ref']],
        ['int', 'groupThreshold', '', []],
        ['double', 'eps', '0.2', []]],
    'void']
ok: FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.CASCADE_DO_CANNY_PRUNING', '1', [], [], None, ''],
        ['const cv.CASCADE_SCALE_IMAGE', '2', [], [], None, ''],
        ['const cv.CASCADE_FIND_BIGGEST_OBJECT', '4', [], [], None, ''],
        ['const cv.CASCADE_DO_ROUGH_SEARCH', '8', [], [], None, '']],
    None]
ok: CONST CASCADE_DO_CANNY_PRUNING=1
ok: CONST CASCADE_SCALE_IMAGE=2
ok: CONST CASCADE_FIND_BIGGEST_OBJECT=4
ok: CONST CASCADE_DO_ROUGH_SEARCH=8

--- Incoming ---
['class cv.BaseCascadeClassifier', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BaseCascadeClassifier : Algorithm, name: BaseCascadeClassifier, base: Algorithm

--- Incoming ---
['class cv.CascadeClassifier', '', [], [], None]
ok: class CLASS cv::.CascadeClassifier : , name: CascadeClassifier, base: 

--- Incoming ---
['cv.CascadeClassifier.CascadeClassifier', '', [], [], None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier []>

--- Incoming ---
[   'cv.CascadeClassifier.CascadeClassifier',
    '',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>

--- Incoming ---
['cv.CascadeClassifier.empty', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.CascadeClassifier.empty []>

--- Incoming ---
[   'cv.CascadeClassifier.load',
    'bool',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>

--- Incoming ---
[   'cv.CascadeClassifier.read',
    'bool',
    [],
    [['FileNode', 'node', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>

--- Incoming ---
[   'cv.CascadeClassifier.detectMultiScale',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['vector_Rect', 'objects', '', ['/O', '/Ref']],
        ['double', 'scaleFactor', '1.1', []],
        ['int', 'minNeighbors', '3', []],
        ['int', 'flags', '0', []],
        ['Size', 'minSize', 'Size()', []],
        ['Size', 'maxSize', 'Size()', []]],
    'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   'cv.CascadeClassifier.detectMultiScale',
    'void',
    ['=detectMultiScale2'],
    [   ['Mat', 'image', '', []],
        ['vector_Rect', 'objects', '', ['/O', '/Ref']],
        ['vector_int', 'numDetections', '', ['/O', '/Ref']],
        ['double', 'scaleFactor', '1.1', []],
        ['int', 'minNeighbors', '3', []],
        ['int', 'flags', '0', []],
        ['Size', 'minSize', 'Size()', []],
        ['Size', 'maxSize', 'Size()', []]],
    'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   'cv.CascadeClassifier.detectMultiScale',
    'void',
    ['=detectMultiScale3'],
    [   ['Mat', 'image', '', []],
        ['vector_Rect', 'objects', '', ['/O', '/Ref']],
        ['vector_int', 'rejectLevels', '', ['/O', '/Ref']],
        ['vector_double', 'levelWeights', '', ['/O', '/Ref']],
        ['double', 'scaleFactor', '1.1', []],
        ['int', 'minNeighbors', '3', []],
        ['int', 'flags', '0', []],
        ['Size', 'minSize', 'Size()', []],
        ['Size', 'maxSize', 'Size()', []],
        ['bool', 'outputRejectLevels', 'false', []]],
    'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>

--- Incoming ---
['cv.CascadeClassifier.isOldFormatCascade', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>

--- Incoming ---
['cv.CascadeClassifier.getOriginalWindowSize', 'Size', ['/C'], [], 'Size']
ok: FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>

--- Incoming ---
['cv.CascadeClassifier.getFeatureType', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.CascadeClassifier.getFeatureType []>

--- Incoming ---
[   'cv.CascadeClassifier.convert',
    'bool',
    ['/S'],
    [   ['String', 'oldcascade', '', ['/C', '/Ref']],
        ['String', 'newcascade', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>

--- Incoming ---
[   'struct cv.HOGDescriptor',
    '',
    [],
    [   ['Size', 'winSize', '', []],
        ['Size', 'blockSize', '', []],
        ['Size', 'blockStride', '', []],
        ['Size', 'cellSize', '', []],
        ['int', 'nbins', '', []],
        ['int', 'derivAperture', '', []],
        ['double', 'winSigma', '', []],
        ['HOGDescriptor_HistogramNormType', 'histogramNormType', '', []],
        ['double', 'L2HysThreshold', '', []],
        ['bool', 'gammaCorrection', '', []],
        ['vector_float', 'svmDetector', '', []],
        ['int', 'nlevels', '', []],
        ['bool', 'signedGradient', '', []]],
    None]
ok: class CLASS cv::.HOGDescriptor : , name: HOGDescriptor, base: 

--- Incoming ---
[   'enum cv.HOGDescriptor.HistogramNormType',
    '',
    [],
    [['const cv.HOGDescriptor.L2Hys', '0', [], [], None, '']],
    None]
ok: CONST L2Hys=0

--- Incoming ---
[   'enum cv.HOGDescriptor.<unnamed>',
    '',
    [],
    [['const cv.HOGDescriptor.DEFAULT_NLEVELS', '64', [], [], None, '']],
    None]
ok: CONST DEFAULT_NLEVELS=64

--- Incoming ---
[   'enum cv.HOGDescriptor.DescriptorStorageFormat',
    '',
    [],
    [   [   'const cv.HOGDescriptor.DESCR_FORMAT_COL_BY_COL',
            '0',
            [],
            [],
            None,
            ''],
        [   'const cv.HOGDescriptor.DESCR_FORMAT_ROW_BY_ROW',
            '1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DESCR_FORMAT_COL_BY_COL=0
ok: CONST DESCR_FORMAT_ROW_BY_ROW=1

--- Incoming ---
['cv.HOGDescriptor.HOGDescriptor', '', [], [], None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor []>

--- Incoming ---
[   'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [   ['Size', '_winSize', '', []],
        ['Size', '_blockSize', '', []],
        ['Size', '_blockStride', '', []],
        ['Size', '_cellSize', '', []],
        ['int', '_nbins', '', []],
        ['int', '_derivAperture', '1', []],
        ['double', '_winSigma', '-1', []],
        [   'HOGDescriptor_HistogramNormType',
            '_histogramNormType',
            'HOGDescriptor::L2Hys',
            []],
        ['double', '_L2HysThreshold', '0.2', []],
        ['bool', '_gammaCorrection', 'false', []],
        ['int', '_nlevels', 'HOGDescriptor::DEFAULT_NLEVELS', []],
        ['bool', '_signedGradient', 'false', []]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>

--- Incoming ---
[   'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [['String', 'filename', '', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>

--- Incoming ---
['cv.HOGDescriptor.getDescriptorSize', 'size_t', ['/C'], [], 'size_t']
ok: FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>

--- Incoming ---
['cv.HOGDescriptor.checkDetectorSize', 'bool', ['/C'], [], 'bool']
ok: FUNC <bool cv.HOGDescriptor.checkDetectorSize []>

--- Incoming ---
['cv.HOGDescriptor.getWinSigma', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.HOGDescriptor.getWinSigma []>

--- Incoming ---
[   'cv.HOGDescriptor.setSVMDetector',
    'void',
    ['/V'],
    [['Mat', 'svmdetector', '', []]],
    'void']
ok: FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>

--- Incoming ---
[   'cv.HOGDescriptor.load',
    'bool',
    ['/V'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['String', 'objname', 'String()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   'cv.HOGDescriptor.save',
    'void',
    ['/C', '/V'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['String', 'objname', 'String()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   'cv.HOGDescriptor.compute',
    'void',
    ['/C', '/V'],
    [   ['Mat', 'img', '', []],
        ['vector_float', 'descriptors', '', ['/O', '/Ref']],
        ['Size', 'winStride', 'Size()', []],
        ['Size', 'padding', 'Size()', []],
        ['vector_Point', 'locations', 'std::vector<Point>()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>

--- Incoming ---
[   'cv.HOGDescriptor.detect',
    'void',
    ['/C', '/V'],
    [   ['Mat', 'img', '', []],
        ['vector_Point', 'foundLocations', '', ['/O', '/Ref']],
        ['vector_double', 'weights', '', ['/O', '/Ref']],
        ['double', 'hitThreshold', '0', []],
        ['Size', 'winStride', 'Size()', []],
        ['Size', 'padding', 'Size()', []],
        [   'vector_Point',
            'searchLocations',
            'std::vector<Point>()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>

--- Incoming ---
[   'cv.HOGDescriptor.detectMultiScale',
    'void',
    ['/C', '/V'],
    [   ['Mat', 'img', '', []],
        ['vector_Rect', 'foundLocations', '', ['/O', '/Ref']],
        ['vector_double', 'foundWeights', '', ['/O', '/Ref']],
        ['double', 'hitThreshold', '0', []],
        ['Size', 'winStride', 'Size()', []],
        ['Size', 'padding', 'Size()', []],
        ['double', 'scale', '1.05', []],
        ['double', 'groupThreshold', '2.0', []],
        ['bool', 'useMeanshiftGrouping', 'false', []]],
    'void']
ok: FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double groupThreshold=2.0, ARG bool useMeanshiftGrouping=false]>

--- Incoming ---
[   'cv.HOGDescriptor.computeGradient',
    'void',
    ['/C', '/V'],
    [   ['Mat', 'img', '', []],
        ['Mat', 'grad', '', ['/IO']],
        ['Mat', 'angleOfs', '', ['/IO']],
        ['Size', 'paddingTL', 'Size()', []],
        ['Size', 'paddingBR', 'Size()', []]],
    'void']
ok: FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>

--- Incoming ---
[   'cv.HOGDescriptor.getDefaultPeopleDetector',
    'vector_float',
    ['/S'],
    [],
    'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>

--- Incoming ---
[   'cv.HOGDescriptor.getDaimlerPeopleDetector',
    'vector_float',
    ['/S'],
    [],
    'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>

--- Incoming ---
['class cv.QRCodeEncoder', '', [], [], None]
ok: class CLASS cv::.QRCodeEncoder : , name: QRCodeEncoder, base: 

--- Incoming ---
[   'enum cv.QRCodeEncoder.EncodeMode',
    '',
    [],
    [   ['const cv.QRCodeEncoder.MODE_AUTO', '-1', [], [], None, ''],
        ['const cv.QRCodeEncoder.MODE_NUMERIC', '1', [], [], None, ''],
        ['const cv.QRCodeEncoder.MODE_ALPHANUMERIC', '2', [], [], None, ''],
        ['const cv.QRCodeEncoder.MODE_BYTE', '4', [], [], None, ''],
        ['const cv.QRCodeEncoder.MODE_ECI', '7', [], [], None, ''],
        ['const cv.QRCodeEncoder.MODE_KANJI', '8', [], [], None, ''],
        [   'const cv.QRCodeEncoder.MODE_STRUCTURED_APPEND',
            '3',
            [],
            [],
            None,
            '']],
    None]
ok: CONST MODE_AUTO=-1
ok: CONST MODE_NUMERIC=1
ok: CONST MODE_ALPHANUMERIC=2
ok: CONST MODE_BYTE=4
ok: CONST MODE_ECI=7
ok: CONST MODE_KANJI=8
ok: CONST MODE_STRUCTURED_APPEND=3

--- Incoming ---
[   'enum cv.QRCodeEncoder.CorrectionLevel',
    '',
    [],
    [   ['const cv.QRCodeEncoder.CORRECT_LEVEL_L', '0', [], [], None, ''],
        ['const cv.QRCodeEncoder.CORRECT_LEVEL_M', '1', [], [], None, ''],
        ['const cv.QRCodeEncoder.CORRECT_LEVEL_Q', '2', [], [], None, ''],
        ['const cv.QRCodeEncoder.CORRECT_LEVEL_H', '3', [], [], None, '']],
    None]
ok: CONST CORRECT_LEVEL_L=0
ok: CONST CORRECT_LEVEL_M=1
ok: CONST CORRECT_LEVEL_Q=2
ok: CONST CORRECT_LEVEL_H=3

--- Incoming ---
[   'enum cv.QRCodeEncoder.ECIEncodings',
    '',
    [],
    [['const cv.QRCodeEncoder.ECI_UTF8', '26', [], [], None, '']],
    None]
ok: CONST ECI_UTF8=26

--- Incoming ---
[   'struct cv.QRCodeEncoder.Params',
    '',
    ['/Simple'],
    [   ['int', 'version', '', ['/RW']],
        ['CorrectionLevel', 'correction_level', '', ['/RW']],
        ['EncodeMode', 'mode', '', ['/RW']],
        ['int', 'structure_number', '', ['/RW']]],
    None]
ok: class CLASS cv::QRCodeEncoder.QRCodeEncoder_Params : , name: QRCodeEncoder_Params, base: 

--- Incoming ---
['cv.QRCodeEncoder.Params.Params', '', [], [], None]
ok: FUNC < cv.QRCodeEncoder.Params.QRCodeEncoder_Params []>

--- Incoming ---
[   'cv.QRCodeEncoder.create',
    'Ptr_QRCodeEncoder',
    ['/S'],
    [   [   'QRCodeEncoder_Params',
            'parameters',
            'QRCodeEncoder::Params()',
            ['/C', '/Ref']]],
    'Ptr<QRCodeEncoder>']
ok: FUNC <Ptr_QRCodeEncoder cv.QRCodeEncoder.create [ARG QRCodeEncoder_Params parameters=QRCodeEncoder::Params()]>

--- Incoming ---
[   'cv.QRCodeEncoder.encode',
    'void',
    ['/V', '/PV'],
    [   ['String', 'encoded_info', '', ['/C', '/Ref']],
        ['Mat', 'qrcode', '', ['/O']]],
    'void']
ok: FUNC <void cv.QRCodeEncoder.encode [ARG String encoded_info=, ARG Mat qrcode=]>

--- Incoming ---
[   'cv.QRCodeEncoder.encodeStructuredAppend',
    'void',
    ['/V', '/PV'],
    [   ['String', 'encoded_info', '', ['/C', '/Ref']],
        ['vector_Mat', 'qrcodes', '', ['/O']]],
    'void']
ok: FUNC <void cv.QRCodeEncoder.encodeStructuredAppend [ARG String encoded_info=, ARG vector_Mat qrcodes=]>

--- Incoming ---
['class cv.QRCodeDetector', '', [], [], None]
ok: class CLASS cv::.QRCodeDetector : , name: QRCodeDetector, base: 

--- Incoming ---
['cv.QRCodeDetector.QRCodeDetector', '', [], [], None]
ok: FUNC < cv.QRCodeDetector.QRCodeDetector []>

--- Incoming ---
['cv.QRCodeDetector.setEpsX', 'void', [], [['double', 'epsX', '', []]], 'void']
ok: FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>

--- Incoming ---
['cv.QRCodeDetector.setEpsY', 'void', [], [['double', 'epsY', '', []]], 'void']
ok: FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>

--- Incoming ---
[   'cv.QRCodeDetector.setUseAlignmentMarkers',
    'void',
    [],
    [['bool', 'useAlignmentMarkers', '', []]],
    'void']
ok: FUNC <void cv.QRCodeDetector.setUseAlignmentMarkers [ARG bool useAlignmentMarkers=]>

--- Incoming ---
[   'cv.QRCodeDetector.detect',
    'bool',
    ['/C'],
    [['Mat', 'img', '', []], ['Mat', 'points', '', ['/O']]],
    'bool']
ok: FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   'cv.QRCodeDetector.decode',
    'string',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', '', []],
        ['Mat', 'straight_qrcode', 'Mat()', ['/O']]],
    'std::string']
ok: FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   'cv.QRCodeDetector.decodeCurved',
    'String',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', '', []],
        ['Mat', 'straight_qrcode', 'Mat()', ['/O']]],
    'cv::String']
ok: FUNC <String cv.QRCodeDetector.decodeCurved [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   'cv.QRCodeDetector.detectAndDecode',
    'string',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', 'Mat()', ['/O']],
        ['Mat', 'straight_qrcode', 'Mat()', ['/O']]],
    'std::string']
ok: FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   'cv.QRCodeDetector.detectAndDecodeCurved',
    'string',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', 'Mat()', ['/O']],
        ['Mat', 'straight_qrcode', 'Mat()', ['/O']]],
    'std::string']
ok: FUNC <string cv.QRCodeDetector.detectAndDecodeCurved [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   'cv.QRCodeDetector.detectMulti',
    'bool',
    ['/C'],
    [['Mat', 'img', '', []], ['Mat', 'points', '', ['/O']]],
    'bool']
ok: FUNC <bool cv.QRCodeDetector.detectMulti [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   'cv.QRCodeDetector.decodeMulti',
    'bool',
    ['/C'],
    [   ['Mat', 'img', '', []],
        ['Mat', 'points', '', []],
        ['vector_string', 'decoded_info', '', ['/O', '/Ref']],
        ['vector_Mat', 'straight_qrcode', 'vector_Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.QRCodeDetector.decodeMulti [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_Mat straight_qrcode=vector_Mat()]>

--- Incoming ---
[   'cv.QRCodeDetector.detectAndDecodeMulti',
    'bool',
    ['/C'],
    [   ['Mat', 'img', '', []],
        ['vector_string', 'decoded_info', '', ['/O', '/Ref']],
        ['Mat', 'points', 'Mat()', ['/O']],
        ['vector_Mat', 'straight_qrcode', 'vector_Mat()', ['/O']]],
    'bool']
ok: FUNC <bool cv.QRCodeDetector.detectAndDecodeMulti [ARG Mat img=, ARG vector_string decoded_info=, ARG Mat points=Mat(), ARG vector_Mat straight_qrcode=vector_Mat()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_detector.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'enum cv.aruco.CornerRefineMethod',
    '',
    [],
    [   ['const cv.aruco.CORNER_REFINE_NONE', '0', [], [], None, ''],
        ['const cv.aruco.CORNER_REFINE_SUBPIX', '1', [], [], None, ''],
        ['const cv.aruco.CORNER_REFINE_CONTOUR', '2', [], [], None, ''],
        ['const cv.aruco.CORNER_REFINE_APRILTAG', '3', [], [], None, '']],
    None]
ok: CONST CORNER_REFINE_NONE=0
ok: CONST CORNER_REFINE_SUBPIX=1
ok: CONST CORNER_REFINE_CONTOUR=2
ok: CONST CORNER_REFINE_APRILTAG=3

--- Incoming ---
[   'struct cv.aruco.DetectorParameters',
    '',
    ['/Simple'],
    [   ['int', 'adaptiveThreshWinSizeMin', '', ['/RW']],
        ['int', 'adaptiveThreshWinSizeMax', '', ['/RW']],
        ['int', 'adaptiveThreshWinSizeStep', '', ['/RW']],
        ['double', 'adaptiveThreshConstant', '', ['/RW']],
        ['double', 'minMarkerPerimeterRate', '', ['/RW']],
        ['double', 'maxMarkerPerimeterRate', '', ['/RW']],
        ['double', 'polygonalApproxAccuracyRate', '', ['/RW']],
        ['double', 'minCornerDistanceRate', '', ['/RW']],
        ['int', 'minDistanceToBorder', '', ['/RW']],
        ['double', 'minMarkerDistanceRate', '', ['/RW']],
        ['CornerRefineMethod', 'cornerRefinementMethod', '', ['/RW']],
        ['int', 'cornerRefinementWinSize', '', ['/RW']],
        ['int', 'cornerRefinementMaxIterations', '', ['/RW']],
        ['double', 'cornerRefinementMinAccuracy', '', ['/RW']],
        ['int', 'markerBorderBits', '', ['/RW']],
        ['int', 'perspectiveRemovePixelPerCell', '', ['/RW']],
        ['double', 'perspectiveRemoveIgnoredMarginPerCell', '', ['/RW']],
        ['double', 'maxErroneousBitsInBorderRate', '', ['/RW']],
        ['double', 'minOtsuStdDev', '', ['/RW']],
        ['double', 'errorCorrectionRate', '', ['/RW']],
        ['float', 'aprilTagQuadDecimate', '', ['/RW']],
        ['float', 'aprilTagQuadSigma', '', ['/RW']],
        ['int', 'aprilTagMinClusterPixels', '', ['/RW']],
        ['int', 'aprilTagMaxNmaxima', '', ['/RW']],
        ['float', 'aprilTagCriticalRad', '', ['/RW']],
        ['float', 'aprilTagMaxLineFitMse', '', ['/RW']],
        ['int', 'aprilTagMinWhiteBlackDiff', '', ['/RW']],
        ['int', 'aprilTagDeglitch', '', ['/RW']],
        ['bool', 'detectInvertedMarker', '', ['/RW']],
        ['bool', 'useAruco3Detection', '', ['/RW']],
        ['int', 'minSideLengthCanonicalImg', '', ['/RW']],
        ['float', 'minMarkerLengthRatioOriginalImg', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.DetectorParameters : , name: DetectorParameters, base: 

--- Incoming ---
['cv.aruco.DetectorParameters.DetectorParameters', '', [], [], None]
ok: FUNC < cv.aruco.DetectorParameters.DetectorParameters []>

--- Incoming ---
[   'cv.aruco.DetectorParameters.readDetectorParameters',
    'bool',
    [],
    [['FileNode', 'fn', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.aruco.DetectorParameters.readDetectorParameters [ARG FileNode fn=]>

--- Incoming ---
[   'cv.aruco.DetectorParameters.writeDetectorParameters',
    'bool',
    [],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', 'String()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.aruco.DetectorParameters.writeDetectorParameters [ARG FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[   'struct cv.aruco.RefineParameters',
    '',
    ['/Simple'],
    [   ['float', 'minRepDistance', '', ['/RW']],
        ['float', 'errorCorrectionRate', '', ['/RW']],
        ['bool', 'checkAllOrders', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.RefineParameters : , name: RefineParameters, base: 

--- Incoming ---
[   'cv.aruco.RefineParameters.RefineParameters',
    '',
    [],
    [   ['float', 'minRepDistance', '10.f', []],
        ['float', 'errorCorrectionRate', '3.f', []],
        ['bool', 'checkAllOrders', 'true', []]],
    None]
ok: FUNC < cv.aruco.RefineParameters.RefineParameters [ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true]>

--- Incoming ---
[   'cv.aruco.RefineParameters.readRefineParameters',
    'bool',
    [],
    [['FileNode', 'fn', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.aruco.RefineParameters.readRefineParameters [ARG FileNode fn=]>

--- Incoming ---
[   'cv.aruco.RefineParameters.writeRefineParameters',
    'bool',
    [],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', 'String()', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.aruco.RefineParameters.writeRefineParameters [ARG FileStorage fs=, ARG String name=String()]>

--- Incoming ---
['class cv.aruco.ArucoDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.aruco::.ArucoDetector : Algorithm, name: ArucoDetector, base: Algorithm

--- Incoming ---
[   'cv.aruco.ArucoDetector.ArucoDetector',
    '',
    [],
    [   [   'Dictionary',
            'dictionary',
            'getPredefinedDictionary(cv::aruco::DICT_4X4_50)',
            ['/C', '/Ref']],
        [   'DetectorParameters',
            'detectorParams',
            'DetectorParameters()',
            ['/C', '/Ref']],
        [   'RefineParameters',
            'refineParams',
            'RefineParameters()',
            ['/C', '/Ref']]],
    None]
ok: FUNC < cv.aruco.ArucoDetector.ArucoDetector [ARG Dictionary dictionary=getPredefinedDictionary(cv::aruco::DICT_4X4_50), ARG DetectorParameters detectorParams=DetectorParameters(), ARG RefineParameters refineParams=RefineParameters()]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.detectMarkers',
    'void',
    ['/C'],
    [   ['Mat', 'image', '', []],
        ['vector_Mat', 'corners', '', ['/O']],
        ['Mat', 'ids', '', ['/O']],
        ['vector_Mat', 'rejectedImgPoints', 'vector_Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.detectMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=, ARG vector_Mat rejectedImgPoints=vector_Mat()]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.refineDetectedMarkers',
    'void',
    ['/C'],
    [   ['Mat', 'image', '', []],
        ['Board', 'board', '', ['/C', '/Ref']],
        ['vector_Mat', 'detectedCorners', '', ['/IO']],
        ['Mat', 'detectedIds', '', ['/IO']],
        ['vector_Mat', 'rejectedCorners', '', ['/IO']],
        ['Mat', 'cameraMatrix', 'Mat()', []],
        ['Mat', 'distCoeffs', 'Mat()', []],
        ['Mat', 'recoveredIdxs', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.refineDetectedMarkers [ARG Mat image=, ARG Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG Mat recoveredIdxs=Mat()]>

--- Incoming ---
['cv.aruco.ArucoDetector.getDictionary', 'Dictionary', ['/C'], [], 'Dictionary']
ok: FUNC <Dictionary cv.aruco.ArucoDetector.getDictionary []>

--- Incoming ---
[   'cv.aruco.ArucoDetector.setDictionary',
    'void',
    [],
    [['Dictionary', 'dictionary', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.setDictionary [ARG Dictionary dictionary=]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.getDetectorParameters',
    'DetectorParameters',
    ['/C'],
    [],
    'DetectorParameters']
ok: FUNC <DetectorParameters cv.aruco.ArucoDetector.getDetectorParameters []>

--- Incoming ---
[   'cv.aruco.ArucoDetector.setDetectorParameters',
    'void',
    [],
    [['DetectorParameters', 'detectorParameters', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.setDetectorParameters [ARG DetectorParameters detectorParameters=]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.getRefineParameters',
    'RefineParameters',
    ['/C'],
    [],
    'RefineParameters']
ok: FUNC <RefineParameters cv.aruco.ArucoDetector.getRefineParameters []>

--- Incoming ---
[   'cv.aruco.ArucoDetector.setRefineParameters',
    'void',
    [],
    [['RefineParameters', 'refineParameters', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.setRefineParameters [ARG RefineParameters refineParameters=]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.write',
    'void',
    [],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.write [ARG FileStorage fs=, ARG String name=]>

--- Incoming ---
[   'cv.aruco.ArucoDetector.read',
    'void',
    ['/V'],
    [['FileNode', 'fn', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.ArucoDetector.read [ARG FileNode fn=]>

--- Incoming ---
[   'cv.aruco.drawDetectedMarkers',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['vector_Mat', 'corners', '', []],
        ['Mat', 'ids', 'Mat()', []],
        ['Scalar', 'borderColor', 'Scalar(0, 255, 0)', []]],
    'void']
ok: FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>

--- Incoming ---
[   'cv.aruco.generateImageMarker',
    'void',
    [],
    [   ['Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['int', 'id', '', []],
        ['int', 'sidePixels', '', []],
        ['Mat', 'img', '', ['/O']],
        ['int', 'borderBits', '1', []]],
    'void']
ok: FUNC <void cv.aruco..generateImageMarker [ARG Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/charuco_detector.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'struct cv.aruco.CharucoParameters',
    '',
    ['/Simple'],
    [   ['Mat', 'cameraMatrix', '', ['/RW']],
        ['Mat', 'distCoeffs', '', ['/RW']],
        ['int', 'minMarkers', '', ['/RW']],
        ['bool', 'tryRefineMarkers', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.CharucoParameters : , name: CharucoParameters, base: 

--- Incoming ---
['class cv.aruco.CharucoDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.aruco::.CharucoDetector : Algorithm, name: CharucoDetector, base: Algorithm

--- Incoming ---
[   'cv.aruco.CharucoDetector.CharucoDetector',
    '',
    [],
    [   ['CharucoBoard', 'board', '', ['/C', '/Ref']],
        [   'CharucoParameters',
            'charucoParams',
            'CharucoParameters()',
            ['/C', '/Ref']],
        [   'DetectorParameters',
            'detectorParams',
            'DetectorParameters()',
            ['/C', '/Ref']],
        [   'RefineParameters',
            'refineParams',
            'RefineParameters()',
            ['/C', '/Ref']]],
    None]
ok: FUNC < cv.aruco.CharucoDetector.CharucoDetector [ARG CharucoBoard board=, ARG CharucoParameters charucoParams=CharucoParameters(), ARG DetectorParameters detectorParams=DetectorParameters(), ARG RefineParameters refineParams=RefineParameters()]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.getBoard',
    'CharucoBoard',
    ['/C'],
    [],
    'CharucoBoard']
ok: FUNC <CharucoBoard cv.aruco.CharucoDetector.getBoard []>

--- Incoming ---
[   'cv.aruco.CharucoDetector.setBoard',
    'void',
    [],
    [['CharucoBoard', 'board', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.setBoard [ARG CharucoBoard board=]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.getCharucoParameters',
    'CharucoParameters',
    ['/C'],
    [],
    'CharucoParameters']
ok: FUNC <CharucoParameters cv.aruco.CharucoDetector.getCharucoParameters []>

--- Incoming ---
[   'cv.aruco.CharucoDetector.setCharucoParameters',
    'void',
    [],
    [['CharucoParameters', 'charucoParameters', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.setCharucoParameters [ARG CharucoParameters charucoParameters=]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.getDetectorParameters',
    'DetectorParameters',
    ['/C'],
    [],
    'DetectorParameters']
ok: FUNC <DetectorParameters cv.aruco.CharucoDetector.getDetectorParameters []>

--- Incoming ---
[   'cv.aruco.CharucoDetector.setDetectorParameters',
    'void',
    [],
    [['DetectorParameters', 'detectorParameters', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.setDetectorParameters [ARG DetectorParameters detectorParameters=]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.getRefineParameters',
    'RefineParameters',
    ['/C'],
    [],
    'RefineParameters']
ok: FUNC <RefineParameters cv.aruco.CharucoDetector.getRefineParameters []>

--- Incoming ---
[   'cv.aruco.CharucoDetector.setRefineParameters',
    'void',
    [],
    [['RefineParameters', 'refineParameters', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.setRefineParameters [ARG RefineParameters refineParameters=]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.detectBoard',
    'void',
    ['/C'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'charucoCorners', '', ['/O']],
        ['Mat', 'charucoIds', '', ['/O']],
        ['vector_Mat', 'markerCorners', 'vector_Mat()', ['/IO']],
        ['Mat', 'markerIds', 'Mat()', ['/IO']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.detectBoard [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG vector_Mat markerCorners=vector_Mat(), ARG Mat markerIds=Mat()]>

--- Incoming ---
[   'cv.aruco.CharucoDetector.detectDiamonds',
    'void',
    ['/C'],
    [   ['Mat', 'image', '', []],
        ['vector_Mat', 'diamondCorners', '', ['/O']],
        ['Mat', 'diamondIds', '', ['/O']],
        ['vector_Mat', 'markerCorners', 'vector_Mat()', ['/IO']],
        ['vector_Mat', 'markerIds', 'vector_Mat()', ['/IO']]],
    'void']
ok: FUNC <void cv.aruco.CharucoDetector.detectDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG vector_Mat markerCorners=vector_Mat(), ARG vector_Mat markerIds=vector_Mat()]>

--- Incoming ---
[   'cv.aruco.drawDetectedCornersCharuco',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Mat', 'charucoCorners', '', []],
        ['Mat', 'charucoIds', 'Mat()', []],
        ['Scalar', 'cornerColor', 'Scalar(255, 0, 0)', []]],
    'void']
ok: FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>

--- Incoming ---
[   'cv.aruco.drawDetectedDiamonds',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['vector_Mat', 'diamondCorners', '', []],
        ['Mat', 'diamondIds', 'Mat()', []],
        ['Scalar', 'borderColor', 'Scalar(0, 0, 255)', []]],
    'void']
ok: FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_board.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
['class cv.aruco.Board', '', ['/Simple'], [], None]
ok: class CLASS cv.aruco::.Board : , name: Board, base: 

--- Incoming ---
[   'cv.aruco.Board.Board',
    '',
    [],
    [   ['vector_Mat', 'objPoints', '', []],
        ['Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['Mat', 'ids', '', []]],
    None]
ok: FUNC < cv.aruco.Board.Board [ARG vector_Mat objPoints=, ARG Dictionary dictionary=, ARG Mat ids=]>

--- Incoming ---
['cv.aruco.Board.getDictionary', 'Dictionary', ['/C'], [], 'Dictionary']
ok: FUNC <Dictionary cv.aruco.Board.getDictionary []>

--- Incoming ---
[   'cv.aruco.Board.getObjPoints',
    'vector_vector_Point3f',
    ['/C'],
    [],
    'std::vector<std::vector<Point3f> >']
ok: FUNC <vector_vector_Point3f cv.aruco.Board.getObjPoints []>

--- Incoming ---
['cv.aruco.Board.getIds', 'vector_int', ['/C'], [], 'std::vector<int>']
ok: FUNC <vector_int cv.aruco.Board.getIds []>

--- Incoming ---
['cv.aruco.Board.getRightBottomCorner', 'Point3f', ['/C'], [], 'Point3f']
ok: FUNC <Point3f cv.aruco.Board.getRightBottomCorner []>

--- Incoming ---
[   'cv.aruco.Board.matchImagePoints',
    'void',
    ['/C'],
    [   ['vector_Mat', 'detectedCorners', '', []],
        ['Mat', 'detectedIds', '', []],
        ['Mat', 'objPoints', '', ['/O']],
        ['Mat', 'imgPoints', '', ['/O']]],
    'void']
ok: FUNC <void cv.aruco.Board.matchImagePoints [ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>

--- Incoming ---
[   'cv.aruco.Board.generateImage',
    'void',
    ['/C'],
    [   ['Size', 'outSize', '', []],
        ['Mat', 'img', '', ['/O']],
        ['int', 'marginSize', '0', []],
        ['int', 'borderBits', '1', []]],
    'void']
ok: FUNC <void cv.aruco.Board.generateImage [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>

--- Incoming ---
['class cv.aruco.GridBoard', ': cv::aruco::Board', ['/Simple'], [], None]
ok: class CLASS cv.aruco::.GridBoard : Board, name: GridBoard, base: Board

--- Incoming ---
[   'cv.aruco.GridBoard.GridBoard',
    '',
    [],
    [   ['Size', 'size', '', ['/C', '/Ref']],
        ['float', 'markerLength', '', []],
        ['float', 'markerSeparation', '', []],
        ['Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['Mat', 'ids', 'Mat()', []]],
    None]
ok: FUNC < cv.aruco.GridBoard.GridBoard [ARG Size size=, ARG float markerLength=, ARG float markerSeparation=, ARG Dictionary dictionary=, ARG Mat ids=Mat()]>

--- Incoming ---
['cv.aruco.GridBoard.getGridSize', 'Size', ['/C'], [], 'Size']
ok: FUNC <Size cv.aruco.GridBoard.getGridSize []>

--- Incoming ---
['cv.aruco.GridBoard.getMarkerLength', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.aruco.GridBoard.getMarkerLength []>

--- Incoming ---
['cv.aruco.GridBoard.getMarkerSeparation', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>

--- Incoming ---
['class cv.aruco.CharucoBoard', ': cv::aruco::Board', ['/Simple'], [], None]
ok: class CLASS cv.aruco::.CharucoBoard : Board, name: CharucoBoard, base: Board

--- Incoming ---
[   'cv.aruco.CharucoBoard.CharucoBoard',
    '',
    [],
    [   ['Size', 'size', '', ['/C', '/Ref']],
        ['float', 'squareLength', '', []],
        ['float', 'markerLength', '', []],
        ['Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['Mat', 'ids', 'Mat()', []]],
    None]
ok: FUNC < cv.aruco.CharucoBoard.CharucoBoard [ARG Size size=, ARG float squareLength=, ARG float markerLength=, ARG Dictionary dictionary=, ARG Mat ids=Mat()]>

--- Incoming ---
['cv.aruco.CharucoBoard.getChessboardSize', 'Size', ['/C'], [], 'Size']
ok: FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>

--- Incoming ---
['cv.aruco.CharucoBoard.getSquareLength', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.aruco.CharucoBoard.getSquareLength []>

--- Incoming ---
['cv.aruco.CharucoBoard.getMarkerLength', 'float', ['/C'], [], 'float']
ok: FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>

--- Incoming ---
[   'cv.aruco.CharucoBoard.getChessboardCorners',
    'vector_Point3f',
    ['/C'],
    [],
    'std::vector<Point3f>']
ok: FUNC <vector_Point3f cv.aruco.CharucoBoard.getChessboardCorners []>

--- Incoming ---
[   'cv.aruco.CharucoBoard.checkCharucoCornersCollinear',
    'bool',
    ['/C'],
    [['Mat', 'charucoIds', '', []]],
    'bool']
ok: FUNC <bool cv.aruco.CharucoBoard.checkCharucoCornersCollinear [ARG Mat charucoIds=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/aruco_dictionary.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'class cv.aruco.Dictionary',
    '',
    ['/Simple'],
    [   ['Mat', 'bytesList', '', ['/RW']],
        ['int', 'markerSize', '', ['/RW']],
        ['int', 'maxCorrectionBits', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.Dictionary : , name: Dictionary, base: 

--- Incoming ---
['cv.aruco.Dictionary.Dictionary', '', [], [], None]
ok: FUNC < cv.aruco.Dictionary.Dictionary []>

--- Incoming ---
[   'cv.aruco.Dictionary.Dictionary',
    '',
    [],
    [   ['Mat', 'bytesList', '', ['/C', '/Ref']],
        ['int', '_markerSize', '', []],
        ['int', 'maxcorr', '0', []]],
    None]
ok: FUNC < cv.aruco.Dictionary.Dictionary [ARG Mat bytesList=, ARG int _markerSize=, ARG int maxcorr=0]>

--- Incoming ---
[   'cv.aruco.Dictionary.readDictionary',
    'bool',
    [],
    [['FileNode', 'fn', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.aruco.Dictionary.readDictionary [ARG FileNode fn=]>

--- Incoming ---
[   'cv.aruco.Dictionary.writeDictionary',
    'void',
    [],
    [   ['FileStorage', 'fs', '', ['/Ref']],
        ['String', 'name', 'String()', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco.Dictionary.writeDictionary [ARG FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[   'cv.aruco.Dictionary.identify',
    'bool',
    ['/C'],
    [   ['Mat', 'onlyBits', '', ['/C', '/Ref']],
        ['int', 'idx', '', ['/O', '/Ref']],
        ['int', 'rotation', '', ['/O', '/Ref']],
        ['double', 'maxCorrectionRate', '', []]],
    'bool']
ok: FUNC <bool cv.aruco.Dictionary.identify [ARG Mat onlyBits=, ARG int idx=, ARG int rotation=, ARG double maxCorrectionRate=]>

--- Incoming ---
[   'cv.aruco.Dictionary.getDistanceToId',
    'int',
    ['/C'],
    [   ['Mat', 'bits', '', []],
        ['int', 'id', '', []],
        ['bool', 'allRotations', 'true', []]],
    'int']
ok: FUNC <int cv.aruco.Dictionary.getDistanceToId [ARG Mat bits=, ARG int id=, ARG bool allRotations=true]>

--- Incoming ---
[   'cv.aruco.Dictionary.generateImageMarker',
    'void',
    ['/C'],
    [   ['int', 'id', '', []],
        ['int', 'sidePixels', '', []],
        ['Mat', '_img', '', ['/O']],
        ['int', 'borderBits', '1', []]],
    'void']
ok: FUNC <void cv.aruco.Dictionary.generateImageMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>

--- Incoming ---
[   'cv.aruco.Dictionary.getByteListFromBits',
    'Mat',
    ['/S'],
    [['Mat', 'bits', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.aruco.Dictionary.getByteListFromBits [ARG Mat bits=]>

--- Incoming ---
[   'cv.aruco.Dictionary.getBitsFromByteList',
    'Mat',
    ['/S'],
    [['Mat', 'byteList', '', ['/C', '/Ref']], ['int', 'markerSize', '', []]],
    'Mat']
ok: FUNC <Mat cv.aruco.Dictionary.getBitsFromByteList [ARG Mat byteList=, ARG int markerSize=]>

--- Incoming ---
[   'enum cv.aruco.PredefinedDictionaryType',
    '',
    [],
    [   ['const cv.aruco.DICT_4X4_50', '0', [], [], None, ''],
        ['const cv.aruco.DICT_4X4_100', '0+1', [], [], None, ''],
        ['const cv.aruco.DICT_4X4_250', '0+2', [], [], None, ''],
        ['const cv.aruco.DICT_4X4_1000', '0+3', [], [], None, ''],
        ['const cv.aruco.DICT_5X5_50', '0+4', [], [], None, ''],
        ['const cv.aruco.DICT_5X5_100', '0+5', [], [], None, ''],
        ['const cv.aruco.DICT_5X5_250', '0+6', [], [], None, ''],
        ['const cv.aruco.DICT_5X5_1000', '0+7', [], [], None, ''],
        ['const cv.aruco.DICT_6X6_50', '0+8', [], [], None, ''],
        ['const cv.aruco.DICT_6X6_100', '0+9', [], [], None, ''],
        ['const cv.aruco.DICT_6X6_250', '0+10', [], [], None, ''],
        ['const cv.aruco.DICT_6X6_1000', '0+11', [], [], None, ''],
        ['const cv.aruco.DICT_7X7_50', '0+12', [], [], None, ''],
        ['const cv.aruco.DICT_7X7_100', '0+13', [], [], None, ''],
        ['const cv.aruco.DICT_7X7_250', '0+14', [], [], None, ''],
        ['const cv.aruco.DICT_7X7_1000', '0+15', [], [], None, ''],
        ['const cv.aruco.DICT_ARUCO_ORIGINAL', '0+16', [], [], None, ''],
        ['const cv.aruco.DICT_APRILTAG_16h5', '0+17', [], [], None, ''],
        ['const cv.aruco.DICT_APRILTAG_25h9', '0+18', [], [], None, ''],
        ['const cv.aruco.DICT_APRILTAG_36h10', '0+19', [], [], None, ''],
        ['const cv.aruco.DICT_APRILTAG_36h11', '0+20', [], [], None, '']],
    None]
ok: CONST DICT_4X4_50=0
ok: CONST DICT_4X4_100=0+1
ok: CONST DICT_4X4_250=0+2
ok: CONST DICT_4X4_1000=0+3
ok: CONST DICT_5X5_50=0+4
ok: CONST DICT_5X5_100=0+5
ok: CONST DICT_5X5_250=0+6
ok: CONST DICT_5X5_1000=0+7
ok: CONST DICT_6X6_50=0+8
ok: CONST DICT_6X6_100=0+9
ok: CONST DICT_6X6_250=0+10
ok: CONST DICT_6X6_1000=0+11
ok: CONST DICT_7X7_50=0+12
ok: CONST DICT_7X7_100=0+13
ok: CONST DICT_7X7_250=0+14
ok: CONST DICT_7X7_1000=0+15
ok: CONST DICT_ARUCO_ORIGINAL=0+16
ok: CONST DICT_APRILTAG_16h5=0+17
ok: CONST DICT_APRILTAG_25h9=0+18
ok: CONST DICT_APRILTAG_36h10=0+19
ok: CONST DICT_APRILTAG_36h11=0+20

--- Incoming ---
[   'cv.aruco.getPredefinedDictionary',
    'Dictionary',
    [],
    [['int', 'dict', '', []]],
    'Dictionary']
ok: FUNC <Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>

--- Incoming ---
[   'cv.aruco.extendDictionary',
    'Dictionary',
    [],
    [   ['int', 'nMarkers', '', []],
        ['int', 'markerSize', '', []],
        ['Dictionary', 'baseDictionary', 'Dictionary()', ['/C', '/Ref']],
        ['int', 'randomSeed', '0', []]],
    'Dictionary']
ok: FUNC <Dictionary cv.aruco..extendDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Dictionary baseDictionary=Dictionary(), ARG int randomSeed=0]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'enum cv.DetectionBasedTracker.ObjectStatus',
    '',
    [],
    [   [   'const cv.DetectionBasedTracker.DETECTED_NOT_SHOWN_YET',
            '0',
            [],
            [],
            None,
            ''],
        ['const cv.DetectionBasedTracker.DETECTED', '1', [], [], None, ''],
        [   'const cv.DetectionBasedTracker.DETECTED_TEMPORARY_LOST',
            '2',
            [],
            [],
            None,
            ''],
        ['const cv.DetectionBasedTracker.WRONG_OBJECT', '3', [], [], None, '']],
    None]
class not found: CONST DETECTED_NOT_SHOWN_YET=0
ok: CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0
class not found: CONST DETECTED=1
ok: CONST DetectionBasedTracker_DETECTED=1
class not found: CONST DETECTED_TEMPORARY_LOST=2
ok: CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2
class not found: CONST WRONG_OBJECT=3
ok: CONST DetectionBasedTracker_WRONG_OBJECT=3


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/objdetect.hpp =====
Namespaces: ['cv', 'cv.aruco']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/objdetect.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/objdetect/include/opencv2/objdetect/face.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
['class cv.FaceDetectorYN', '', [], [], None]
ok: class CLASS cv::.FaceDetectorYN : , name: FaceDetectorYN, base: 

--- Incoming ---
[   'cv.FaceDetectorYN.setInputSize',
    'void',
    ['/V', '/PV'],
    [['Size', 'input_size', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.FaceDetectorYN.setInputSize [ARG Size input_size=]>

--- Incoming ---
['cv.FaceDetectorYN.getInputSize', 'Size', ['/V', '/PV'], [], 'Size']
ok: FUNC <Size cv.FaceDetectorYN.getInputSize []>

--- Incoming ---
[   'cv.FaceDetectorYN.setScoreThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'score_threshold', '', []]],
    'void']
ok: FUNC <void cv.FaceDetectorYN.setScoreThreshold [ARG float score_threshold=]>

--- Incoming ---
['cv.FaceDetectorYN.getScoreThreshold', 'float', ['/V', '/PV'], [], 'float']
ok: FUNC <float cv.FaceDetectorYN.getScoreThreshold []>

--- Incoming ---
[   'cv.FaceDetectorYN.setNMSThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'nms_threshold', '', []]],
    'void']
ok: FUNC <void cv.FaceDetectorYN.setNMSThreshold [ARG float nms_threshold=]>

--- Incoming ---
['cv.FaceDetectorYN.getNMSThreshold', 'float', ['/V', '/PV'], [], 'float']
ok: FUNC <float cv.FaceDetectorYN.getNMSThreshold []>

--- Incoming ---
[   'cv.FaceDetectorYN.setTopK',
    'void',
    ['/V', '/PV'],
    [['int', 'top_k', '', []]],
    'void']
ok: FUNC <void cv.FaceDetectorYN.setTopK [ARG int top_k=]>

--- Incoming ---
['cv.FaceDetectorYN.getTopK', 'int', ['/V', '/PV'], [], 'int']
ok: FUNC <int cv.FaceDetectorYN.getTopK []>

--- Incoming ---
[   'cv.FaceDetectorYN.detect',
    'int',
    ['/V', '/PV'],
    [['Mat', 'image', '', []], ['Mat', 'faces', '', ['/O']]],
    'int']
ok: FUNC <int cv.FaceDetectorYN.detect [ARG Mat image=, ARG Mat faces=]>

--- Incoming ---
[   'cv.FaceDetectorYN.create',
    'Ptr_FaceDetectorYN',
    ['/S'],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '', ['/C', '/Ref']],
        ['Size', 'input_size', '', ['/C', '/Ref']],
        ['float', 'score_threshold', '0.9f', []],
        ['float', 'nms_threshold', '0.3f', []],
        ['int', 'top_k', '5000', []],
        ['int', 'backend_id', '0', []],
        ['int', 'target_id', '0', []]],
    'Ptr<FaceDetectorYN>']
ok: FUNC <Ptr_FaceDetectorYN cv.FaceDetectorYN.create [ARG String model=, ARG String config=, ARG Size input_size=, ARG float score_threshold=0.9f, ARG float nms_threshold=0.3f, ARG int top_k=5000, ARG int backend_id=0, ARG int target_id=0]>

--- Incoming ---
['class cv.FaceRecognizerSF', '', [], [], None]
ok: class CLASS cv::.FaceRecognizerSF : , name: FaceRecognizerSF, base: 

--- Incoming ---
[   'enum cv.FaceRecognizerSF.DisType',
    '',
    [],
    [   ['const cv.FaceRecognizerSF.FR_COSINE', '0', [], [], None, ''],
        ['const cv.FaceRecognizerSF.FR_NORM_L2', '1', [], [], None, '']],
    None]
ok: CONST FR_COSINE=0
ok: CONST FR_NORM_L2=1

--- Incoming ---
[   'cv.FaceRecognizerSF.alignCrop',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'src_img', '', []],
        ['Mat', 'face_box', '', []],
        ['Mat', 'aligned_img', '', ['/O']]],
    'void']
ok: FUNC <void cv.FaceRecognizerSF.alignCrop [ARG Mat src_img=, ARG Mat face_box=, ARG Mat aligned_img=]>

--- Incoming ---
[   'cv.FaceRecognizerSF.feature',
    'void',
    ['/V', '/PV'],
    [['Mat', 'aligned_img', '', []], ['Mat', 'face_feature', '', ['/O']]],
    'void']
ok: FUNC <void cv.FaceRecognizerSF.feature [ARG Mat aligned_img=, ARG Mat face_feature=]>

--- Incoming ---
[   'cv.FaceRecognizerSF.match',
    'double',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'face_feature1', '', []],
        ['Mat', 'face_feature2', '', []],
        ['int', 'dis_type', 'FaceRecognizerSF::FR_COSINE', []]],
    'double']
ok: FUNC <double cv.FaceRecognizerSF.match [ARG Mat face_feature1=, ARG Mat face_feature2=, ARG int dis_type=FaceRecognizerSF::FR_COSINE]>

--- Incoming ---
[   'cv.FaceRecognizerSF.create',
    'Ptr_FaceRecognizerSF',
    ['/S'],
    [   ['String', 'model', '', ['/C', '/Ref']],
        ['String', 'config', '', ['/C', '/Ref']],
        ['int', 'backend_id', '0', []],
        ['int', 'target_id', '0', []]],
    'Ptr<FaceRecognizerSF>']
ok: FUNC <Ptr_FaceRecognizerSF cv.FaceRecognizerSF.create [ARG String model=, ARG String config=, ARG int backend_id=0, ARG int target_id=0]>


===== Generating... =====
CLASS cv::.BaseCascadeClassifier : Algorithm
CLASS cv::.CascadeClassifier : 
FUNC < cv.CascadeClassifier.CascadeClassifier []>
java:  CascadeClassifier()
FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>
java:  CascadeClassifier(String filename)
FUNC <bool cv.CascadeClassifier.empty []>
java: boolean empty()
FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>
java: boolean load(String filename)
FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>
SKIP:bool cv::CascadeClassifier::read(FileNode node)	 due to ARG type FileNode/I
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor)
java: void detectMultiScale(Mat image, MatOfRect objects)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, boolean outputRejectLevels)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights)
FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>
java: boolean isOldFormatCascade()
FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>
java: Size getOriginalWindowSize()
FUNC <int cv.CascadeClassifier.getFeatureType []>
java: int getFeatureType()
FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>
java: boolean convert(String oldcascade, String newcascade)
CLASS cv::.FaceDetectorYN : 
FUNC <void cv.FaceDetectorYN.setInputSize [ARG Size input_size=]>
java: void setInputSize(Size input_size)
FUNC <Size cv.FaceDetectorYN.getInputSize []>
java: Size getInputSize()
FUNC <void cv.FaceDetectorYN.setScoreThreshold [ARG float score_threshold=]>
java: void setScoreThreshold(float score_threshold)
FUNC <float cv.FaceDetectorYN.getScoreThreshold []>
java: float getScoreThreshold()
FUNC <void cv.FaceDetectorYN.setNMSThreshold [ARG float nms_threshold=]>
java: void setNMSThreshold(float nms_threshold)
FUNC <float cv.FaceDetectorYN.getNMSThreshold []>
java: float getNMSThreshold()
FUNC <void cv.FaceDetectorYN.setTopK [ARG int top_k=]>
java: void setTopK(int top_k)
FUNC <int cv.FaceDetectorYN.getTopK []>
java: int getTopK()
FUNC <int cv.FaceDetectorYN.detect [ARG Mat image=, ARG Mat faces=]>
java: int detect(Mat image, Mat faces)
FUNC <Ptr_FaceDetectorYN cv.FaceDetectorYN.create [ARG String model=, ARG String config=, ARG Size input_size=, ARG float score_threshold=0.9f, ARG float nms_threshold=0.3f, ARG int top_k=5000, ARG int backend_id=0, ARG int target_id=0]>
java: FaceDetectorYN create(String model, String config, Size input_size, float score_threshold, float nms_threshold, int top_k, int backend_id, int target_id)
java: FaceDetectorYN create(String model, String config, Size input_size, float score_threshold, float nms_threshold, int top_k, int backend_id)
java: FaceDetectorYN create(String model, String config, Size input_size, float score_threshold, float nms_threshold, int top_k)
java: FaceDetectorYN create(String model, String config, Size input_size, float score_threshold, float nms_threshold)
java: FaceDetectorYN create(String model, String config, Size input_size, float score_threshold)
java: FaceDetectorYN create(String model, String config, Size input_size)
CLASS cv::.FaceRecognizerSF : 
[CONST FR_COSINE=0, CONST FR_NORM_L2=1]
FUNC <void cv.FaceRecognizerSF.alignCrop [ARG Mat src_img=, ARG Mat face_box=, ARG Mat aligned_img=]>
java: void alignCrop(Mat src_img, Mat face_box, Mat aligned_img)
FUNC <void cv.FaceRecognizerSF.feature [ARG Mat aligned_img=, ARG Mat face_feature=]>
java: void feature(Mat aligned_img, Mat face_feature)
FUNC <double cv.FaceRecognizerSF.match [ARG Mat face_feature1=, ARG Mat face_feature2=, ARG int dis_type=FaceRecognizerSF::FR_COSINE]>
java: double match(Mat face_feature1, Mat face_feature2, int dis_type)
java: double match(Mat face_feature1, Mat face_feature2)
FUNC <Ptr_FaceRecognizerSF cv.FaceRecognizerSF.create [ARG String model=, ARG String config=, ARG int backend_id=0, ARG int target_id=0]>
java: FaceRecognizerSF create(String model, String config, int backend_id, int target_id)
java: FaceRecognizerSF create(String model, String config, int backend_id)
java: FaceRecognizerSF create(String model, String config)
CLASS cv::.HOGDescriptor : 
[CONST DEFAULT_NLEVELS=64]
[CONST DESCR_FORMAT_COL_BY_COL=0, CONST DESCR_FORMAT_ROW_BY_ROW=1]
[CONST L2Hys=0]
FUNC < cv.HOGDescriptor.HOGDescriptor []>
java:  HOGDescriptor()
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins)
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>
java:  HOGDescriptor(String filename)
FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>
java: long getDescriptorSize()
FUNC <bool cv.HOGDescriptor.checkDetectorSize []>
java: boolean checkDetectorSize()
FUNC <double cv.HOGDescriptor.getWinSigma []>
java: double getWinSigma()
FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>
java: void setSVMDetector(Mat svmdetector)
FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>
java: boolean load(String filename, String objname)
java: boolean load(String filename)
FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>
java: void save(String filename, String objname)
java: void save(String filename)
FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding, MatOfPoint locations)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride)
java: void compute(Mat img, MatOfFloat descriptors)
FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding, MatOfPoint searchLocations)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights)
FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double groupThreshold=2.0, ARG bool useMeanshiftGrouping=false]>
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double groupThreshold, boolean useMeanshiftGrouping)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double groupThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights)
FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL, Size paddingBR)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs)
FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>
java: MatOfFloat getDefaultPeopleDetector()
FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>
java: MatOfFloat getDaimlerPeopleDetector()
FUNC <Size cv.HOGDescriptor.get_winSize []>
java: Size get_winSize()
FUNC <Size cv.HOGDescriptor.get_blockSize []>
java: Size get_blockSize()
FUNC <Size cv.HOGDescriptor.get_blockStride []>
java: Size get_blockStride()
FUNC <Size cv.HOGDescriptor.get_cellSize []>
java: Size get_cellSize()
FUNC <int cv.HOGDescriptor.get_nbins []>
java: int get_nbins()
FUNC <int cv.HOGDescriptor.get_derivAperture []>
java: int get_derivAperture()
FUNC <double cv.HOGDescriptor.get_winSigma []>
java: double get_winSigma()
FUNC <HOGDescriptor_HistogramNormType cv.HOGDescriptor.get_histogramNormType []>
java: int get_histogramNormType()
FUNC <double cv.HOGDescriptor.get_L2HysThreshold []>
java: double get_L2HysThreshold()
FUNC <bool cv.HOGDescriptor.get_gammaCorrection []>
java: boolean get_gammaCorrection()
FUNC <vector_float cv.HOGDescriptor.get_svmDetector []>
java: MatOfFloat get_svmDetector()
FUNC <int cv.HOGDescriptor.get_nlevels []>
java: int get_nlevels()
FUNC <bool cv.HOGDescriptor.get_signedGradient []>
java: boolean get_signedGradient()
CLASS cv::.Objdetect : 
[CONST CASCADE_DO_CANNY_PRUNING=1, CONST CASCADE_SCALE_IMAGE=2, CONST CASCADE_FIND_BIGGEST_OBJECT=4, CONST CASCADE_DO_ROUGH_SEARCH=8]
[CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0, CONST DetectionBasedTracker_DETECTED=1, CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2, CONST DetectionBasedTracker_WRONG_OBJECT=3]
[CONST CORNER_REFINE_NONE=0, CONST CORNER_REFINE_SUBPIX=1, CONST CORNER_REFINE_CONTOUR=2, CONST CORNER_REFINE_APRILTAG=3]
[CONST DICT_4X4_50=0, CONST DICT_4X4_100=0+1, CONST DICT_4X4_250=0+2, CONST DICT_4X4_1000=0+3, CONST DICT_5X5_50=0+4, CONST DICT_5X5_100=0+5, CONST DICT_5X5_250=0+6, CONST DICT_5X5_1000=0+7, CONST DICT_6X6_50=0+8, CONST DICT_6X6_100=0+9, CONST DICT_6X6_250=0+10, CONST DICT_6X6_1000=0+11, CONST DICT_7X7_50=0+12, CONST DICT_7X7_100=0+13, CONST DICT_7X7_250=0+14, CONST DICT_7X7_1000=0+15, CONST DICT_ARUCO_ORIGINAL=0+16, CONST DICT_APRILTAG_16h5=0+17, CONST DICT_APRILTAG_25h9=0+18, CONST DICT_APRILTAG_36h10=0+19, CONST DICT_APRILTAG_36h11=0+20]
FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold, double eps)
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold)
FUNC <void cv.aruco..drawDetectedMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=Mat(), ARG Scalar borderColor=Scalar(0, 255, 0)]>
java: void drawDetectedMarkers(Mat image, List<Mat> corners, Mat ids, Scalar borderColor)
java: void drawDetectedMarkers(Mat image, List<Mat> corners, Mat ids)
java: void drawDetectedMarkers(Mat image, List<Mat> corners)
FUNC <void cv.aruco..generateImageMarker [ARG Dictionary dictionary=, ARG int id=, ARG int sidePixels=, ARG Mat img=, ARG int borderBits=1]>
java: void generateImageMarker(Dictionary dictionary, int id, int sidePixels, Mat img, int borderBits)
java: void generateImageMarker(Dictionary dictionary, int id, int sidePixels, Mat img)
FUNC <void cv.aruco..drawDetectedCornersCharuco [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=Mat(), ARG Scalar cornerColor=Scalar(255, 0, 0)]>
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners, Mat charucoIds, Scalar cornerColor)
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners, Mat charucoIds)
java: void drawDetectedCornersCharuco(Mat image, Mat charucoCorners)
FUNC <void cv.aruco..drawDetectedDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=Mat(), ARG Scalar borderColor=Scalar(0, 0, 255)]>
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds, Scalar borderColor)
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds)
java: void drawDetectedDiamonds(Mat image, List<Mat> diamondCorners)
FUNC <Dictionary cv.aruco..getPredefinedDictionary [ARG int dict=]>
java: Dictionary getPredefinedDictionary(int dict)
FUNC <Dictionary cv.aruco..extendDictionary [ARG int nMarkers=, ARG int markerSize=, ARG Dictionary baseDictionary=Dictionary(), ARG int randomSeed=0]>
java: Dictionary extendDictionary(int nMarkers, int markerSize, Dictionary baseDictionary, int randomSeed)
java: Dictionary extendDictionary(int nMarkers, int markerSize, Dictionary baseDictionary)
java: Dictionary extendDictionary(int nMarkers, int markerSize)
CLASS cv::.QRCodeDetector : 
FUNC < cv.QRCodeDetector.QRCodeDetector []>
java:  QRCodeDetector()
FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>
java: void setEpsX(double epsX)
FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>
java: void setEpsY(double epsY)
FUNC <void cv.QRCodeDetector.setUseAlignmentMarkers [ARG bool useAlignmentMarkers=]>
java: void setUseAlignmentMarkers(boolean useAlignmentMarkers)
FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>
java: boolean detect(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>
java: String decode(Mat img, Mat points, Mat straight_qrcode)
java: String decode(Mat img, Mat points)
FUNC <String cv.QRCodeDetector.decodeCurved [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>
java: String decodeCurved(Mat img, Mat points, Mat straight_qrcode)
java: String decodeCurved(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>
java: String detectAndDecode(Mat img, Mat points, Mat straight_qrcode)
java: String detectAndDecode(Mat img, Mat points)
java: String detectAndDecode(Mat img)
FUNC <string cv.QRCodeDetector.detectAndDecodeCurved [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>
java: String detectAndDecodeCurved(Mat img, Mat points, Mat straight_qrcode)
java: String detectAndDecodeCurved(Mat img, Mat points)
java: String detectAndDecodeCurved(Mat img)
FUNC <bool cv.QRCodeDetector.detectMulti [ARG Mat img=, ARG Mat points=]>
java: boolean detectMulti(Mat img, Mat points)
FUNC <bool cv.QRCodeDetector.decodeMulti [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_Mat straight_qrcode=vector_Mat()]>
java: boolean decodeMulti(Mat img, Mat points, List<String> decoded_info, List<Mat> straight_qrcode)
java: boolean decodeMulti(Mat img, Mat points, List<String> decoded_info)
FUNC <bool cv.QRCodeDetector.detectAndDecodeMulti [ARG Mat img=, ARG vector_string decoded_info=, ARG Mat points=Mat(), ARG vector_Mat straight_qrcode=vector_Mat()]>
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info, Mat points, List<Mat> straight_qrcode)
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info, Mat points)
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info)
CLASS cv::.QRCodeEncoder : 
[CONST CORRECT_LEVEL_L=0, CONST CORRECT_LEVEL_M=1, CONST CORRECT_LEVEL_Q=2, CONST CORRECT_LEVEL_H=3]
[CONST ECI_UTF8=26]
[CONST MODE_AUTO=-1, CONST MODE_NUMERIC=1, CONST MODE_ALPHANUMERIC=2, CONST MODE_BYTE=4, CONST MODE_ECI=7, CONST MODE_KANJI=8, CONST MODE_STRUCTURED_APPEND=3]
FUNC <Ptr_QRCodeEncoder cv.QRCodeEncoder.create [ARG QRCodeEncoder_Params parameters=QRCodeEncoder::Params()]>
java: QRCodeEncoder create(QRCodeEncoder_Params parameters)
java: QRCodeEncoder create()
FUNC <void cv.QRCodeEncoder.encode [ARG String encoded_info=, ARG Mat qrcode=]>
java: void encode(String encoded_info, Mat qrcode)
FUNC <void cv.QRCodeEncoder.encodeStructuredAppend [ARG String encoded_info=, ARG vector_Mat qrcodes=]>
java: void encodeStructuredAppend(String encoded_info, List<Mat> qrcodes)
CLASS cv::QRCodeEncoder.QRCodeEncoder_Params : 
FUNC < cv.QRCodeEncoder.Params.QRCodeEncoder_Params []>
java:  QRCodeEncoder_Params()
FUNC <int cv.QRCodeEncoder.Params.get_version []>
java: int get_version()
FUNC <void cv.QRCodeEncoder.Params.set_version [ARG int version=]>
java: void set_version(int version)
FUNC <CorrectionLevel cv.QRCodeEncoder.Params.get_correction_level []>
SKIP:CorrectionLevel QRCodeEncoder_Params::correction_level	 due to RET type CorrectionLevel
FUNC <void cv.QRCodeEncoder.Params.set_correction_level [ARG CorrectionLevel correction_level=]>
SKIP:void QRCodeEncoder_Params::correction_level	 due to ARG type CorrectionLevel/I
FUNC <EncodeMode cv.QRCodeEncoder.Params.get_mode []>
SKIP:EncodeMode QRCodeEncoder_Params::mode	 due to RET type EncodeMode
FUNC <void cv.QRCodeEncoder.Params.set_mode [ARG EncodeMode mode=]>
SKIP:void QRCodeEncoder_Params::mode	 due to ARG type EncodeMode/I
FUNC <int cv.QRCodeEncoder.Params.get_structure_number []>
java: int get_structure_number()
FUNC <void cv.QRCodeEncoder.Params.set_structure_number [ARG int structure_number=]>
java: void set_structure_number(int structure_number)
CLASS cv.aruco::.ArucoDetector : Algorithm
FUNC < cv.aruco.ArucoDetector.ArucoDetector [ARG Dictionary dictionary=getPredefinedDictionary(cv::aruco::DICT_4X4_50), ARG DetectorParameters detectorParams=DetectorParameters(), ARG RefineParameters refineParams=RefineParameters()]>
java:  ArucoDetector(Dictionary dictionary, DetectorParameters detectorParams, RefineParameters refineParams)
java:  ArucoDetector(Dictionary dictionary, DetectorParameters detectorParams)
java:  ArucoDetector(Dictionary dictionary)
java:  ArucoDetector()
FUNC <void cv.aruco.ArucoDetector.detectMarkers [ARG Mat image=, ARG vector_Mat corners=, ARG Mat ids=, ARG vector_Mat rejectedImgPoints=vector_Mat()]>
java: void detectMarkers(Mat image, List<Mat> corners, Mat ids, List<Mat> rejectedImgPoints)
java: void detectMarkers(Mat image, List<Mat> corners, Mat ids)
FUNC <void cv.aruco.ArucoDetector.refineDetectedMarkers [ARG Mat image=, ARG Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG Mat recoveredIdxs=Mat()]>
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, Mat recoveredIdxs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners)
FUNC <Dictionary cv.aruco.ArucoDetector.getDictionary []>
java: Dictionary getDictionary()
FUNC <void cv.aruco.ArucoDetector.setDictionary [ARG Dictionary dictionary=]>
java: void setDictionary(Dictionary dictionary)
FUNC <DetectorParameters cv.aruco.ArucoDetector.getDetectorParameters []>
java: DetectorParameters getDetectorParameters()
FUNC <void cv.aruco.ArucoDetector.setDetectorParameters [ARG DetectorParameters detectorParameters=]>
java: void setDetectorParameters(DetectorParameters detectorParameters)
FUNC <RefineParameters cv.aruco.ArucoDetector.getRefineParameters []>
java: RefineParameters getRefineParameters()
FUNC <void cv.aruco.ArucoDetector.setRefineParameters [ARG RefineParameters refineParameters=]>
java: void setRefineParameters(RefineParameters refineParameters)
FUNC <void cv.aruco.ArucoDetector.write [ARG FileStorage fs=, ARG String name=]>
SKIP:void cv::aruco::ArucoDetector::write(FileStorage fs, String name)	 due to ARG type FileStorage/I
FUNC <void cv.aruco.ArucoDetector.read [ARG FileNode fn=]>
SKIP:void cv::aruco::ArucoDetector::read(FileNode fn)	 due to ARG type FileNode/I
CLASS cv.aruco::.Board : 
FUNC < cv.aruco.Board.Board [ARG vector_Mat objPoints=, ARG Dictionary dictionary=, ARG Mat ids=]>
java:  Board(List<Mat> objPoints, Dictionary dictionary, Mat ids)
FUNC <Dictionary cv.aruco.Board.getDictionary []>
java: Dictionary getDictionary()
FUNC <vector_vector_Point3f cv.aruco.Board.getObjPoints []>
java: List<MatOfPoint3f> getObjPoints()
FUNC <vector_int cv.aruco.Board.getIds []>
java: MatOfInt getIds()
FUNC <Point3f cv.aruco.Board.getRightBottomCorner []>
java: Point3 getRightBottomCorner()
FUNC <void cv.aruco.Board.matchImagePoints [ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>
java: void matchImagePoints(List<Mat> detectedCorners, Mat detectedIds, Mat objPoints, Mat imgPoints)
FUNC <void cv.aruco.Board.generateImage [ARG Size outSize=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
java: void generateImage(Size outSize, Mat img, int marginSize, int borderBits)
java: void generateImage(Size outSize, Mat img, int marginSize)
java: void generateImage(Size outSize, Mat img)
CLASS cv.aruco::.CharucoBoard : Board
FUNC < cv.aruco.CharucoBoard.CharucoBoard [ARG Size size=, ARG float squareLength=, ARG float markerLength=, ARG Dictionary dictionary=, ARG Mat ids=Mat()]>
java:  CharucoBoard(Size size, float squareLength, float markerLength, Dictionary dictionary, Mat ids)
java:  CharucoBoard(Size size, float squareLength, float markerLength, Dictionary dictionary)
FUNC <Size cv.aruco.CharucoBoard.getChessboardSize []>
java: Size getChessboardSize()
FUNC <float cv.aruco.CharucoBoard.getSquareLength []>
java: float getSquareLength()
FUNC <float cv.aruco.CharucoBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <vector_Point3f cv.aruco.CharucoBoard.getChessboardCorners []>
java: MatOfPoint3f getChessboardCorners()
FUNC <bool cv.aruco.CharucoBoard.checkCharucoCornersCollinear [ARG Mat charucoIds=]>
java: boolean checkCharucoCornersCollinear(Mat charucoIds)
CLASS cv.aruco::.CharucoDetector : Algorithm
FUNC < cv.aruco.CharucoDetector.CharucoDetector [ARG CharucoBoard board=, ARG CharucoParameters charucoParams=CharucoParameters(), ARG DetectorParameters detectorParams=DetectorParameters(), ARG RefineParameters refineParams=RefineParameters()]>
java:  CharucoDetector(CharucoBoard board, CharucoParameters charucoParams, DetectorParameters detectorParams, RefineParameters refineParams)
java:  CharucoDetector(CharucoBoard board, CharucoParameters charucoParams, DetectorParameters detectorParams)
java:  CharucoDetector(CharucoBoard board, CharucoParameters charucoParams)
java:  CharucoDetector(CharucoBoard board)
FUNC <CharucoBoard cv.aruco.CharucoDetector.getBoard []>
java: CharucoBoard getBoard()
FUNC <void cv.aruco.CharucoDetector.setBoard [ARG CharucoBoard board=]>
java: void setBoard(CharucoBoard board)
FUNC <CharucoParameters cv.aruco.CharucoDetector.getCharucoParameters []>
java: CharucoParameters getCharucoParameters()
FUNC <void cv.aruco.CharucoDetector.setCharucoParameters [ARG CharucoParameters charucoParameters=]>
java: void setCharucoParameters(CharucoParameters charucoParameters)
FUNC <DetectorParameters cv.aruco.CharucoDetector.getDetectorParameters []>
java: DetectorParameters getDetectorParameters()
FUNC <void cv.aruco.CharucoDetector.setDetectorParameters [ARG DetectorParameters detectorParameters=]>
java: void setDetectorParameters(DetectorParameters detectorParameters)
FUNC <RefineParameters cv.aruco.CharucoDetector.getRefineParameters []>
java: RefineParameters getRefineParameters()
FUNC <void cv.aruco.CharucoDetector.setRefineParameters [ARG RefineParameters refineParameters=]>
java: void setRefineParameters(RefineParameters refineParameters)
FUNC <void cv.aruco.CharucoDetector.detectBoard [ARG Mat image=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG vector_Mat markerCorners=vector_Mat(), ARG Mat markerIds=Mat()]>
java: void detectBoard(Mat image, Mat charucoCorners, Mat charucoIds, List<Mat> markerCorners, Mat markerIds)
java: void detectBoard(Mat image, Mat charucoCorners, Mat charucoIds, List<Mat> markerCorners)
java: void detectBoard(Mat image, Mat charucoCorners, Mat charucoIds)
FUNC <void cv.aruco.CharucoDetector.detectDiamonds [ARG Mat image=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG vector_Mat markerCorners=vector_Mat(), ARG vector_Mat markerIds=vector_Mat()]>
java: void detectDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds, List<Mat> markerCorners, List<Mat> markerIds)
java: void detectDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds, List<Mat> markerCorners)
java: void detectDiamonds(Mat image, List<Mat> diamondCorners, Mat diamondIds)
CLASS cv.aruco::.CharucoParameters : 
FUNC <Mat cv.aruco.CharucoParameters.get_cameraMatrix []>
java: Mat get_cameraMatrix()
FUNC <void cv.aruco.CharucoParameters.set_cameraMatrix [ARG Mat cameraMatrix=]>
java: void set_cameraMatrix(Mat cameraMatrix)
FUNC <Mat cv.aruco.CharucoParameters.get_distCoeffs []>
java: Mat get_distCoeffs()
FUNC <void cv.aruco.CharucoParameters.set_distCoeffs [ARG Mat distCoeffs=]>
java: void set_distCoeffs(Mat distCoeffs)
FUNC <int cv.aruco.CharucoParameters.get_minMarkers []>
java: int get_minMarkers()
FUNC <void cv.aruco.CharucoParameters.set_minMarkers [ARG int minMarkers=]>
java: void set_minMarkers(int minMarkers)
FUNC <bool cv.aruco.CharucoParameters.get_tryRefineMarkers []>
java: boolean get_tryRefineMarkers()
FUNC <void cv.aruco.CharucoParameters.set_tryRefineMarkers [ARG bool tryRefineMarkers=]>
java: void set_tryRefineMarkers(boolean tryRefineMarkers)
CLASS cv.aruco::.DetectorParameters : 
FUNC < cv.aruco.DetectorParameters.DetectorParameters []>
java:  DetectorParameters()
FUNC <bool cv.aruco.DetectorParameters.readDetectorParameters [ARG FileNode fn=]>
SKIP:bool cv::aruco::DetectorParameters::readDetectorParameters(FileNode fn)	 due to ARG type FileNode/I
FUNC <bool cv.aruco.DetectorParameters.writeDetectorParameters [ARG FileStorage fs=, ARG String name=String()]>
SKIP:bool cv::aruco::DetectorParameters::writeDetectorParameters(FileStorage fs, String name = String())	 due to ARG type FileStorage/I
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMin []>
java: int get_adaptiveThreshWinSizeMin()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMin [ARG int adaptiveThreshWinSizeMin=]>
java: void set_adaptiveThreshWinSizeMin(int adaptiveThreshWinSizeMin)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeMax []>
java: int get_adaptiveThreshWinSizeMax()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeMax [ARG int adaptiveThreshWinSizeMax=]>
java: void set_adaptiveThreshWinSizeMax(int adaptiveThreshWinSizeMax)
FUNC <int cv.aruco.DetectorParameters.get_adaptiveThreshWinSizeStep []>
java: int get_adaptiveThreshWinSizeStep()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshWinSizeStep [ARG int adaptiveThreshWinSizeStep=]>
java: void set_adaptiveThreshWinSizeStep(int adaptiveThreshWinSizeStep)
FUNC <double cv.aruco.DetectorParameters.get_adaptiveThreshConstant []>
java: double get_adaptiveThreshConstant()
FUNC <void cv.aruco.DetectorParameters.set_adaptiveThreshConstant [ARG double adaptiveThreshConstant=]>
java: void set_adaptiveThreshConstant(double adaptiveThreshConstant)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerPerimeterRate []>
java: double get_minMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerPerimeterRate [ARG double minMarkerPerimeterRate=]>
java: void set_minMarkerPerimeterRate(double minMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_maxMarkerPerimeterRate []>
java: double get_maxMarkerPerimeterRate()
FUNC <void cv.aruco.DetectorParameters.set_maxMarkerPerimeterRate [ARG double maxMarkerPerimeterRate=]>
java: void set_maxMarkerPerimeterRate(double maxMarkerPerimeterRate)
FUNC <double cv.aruco.DetectorParameters.get_polygonalApproxAccuracyRate []>
java: double get_polygonalApproxAccuracyRate()
FUNC <void cv.aruco.DetectorParameters.set_polygonalApproxAccuracyRate [ARG double polygonalApproxAccuracyRate=]>
java: void set_polygonalApproxAccuracyRate(double polygonalApproxAccuracyRate)
FUNC <double cv.aruco.DetectorParameters.get_minCornerDistanceRate []>
java: double get_minCornerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minCornerDistanceRate [ARG double minCornerDistanceRate=]>
java: void set_minCornerDistanceRate(double minCornerDistanceRate)
FUNC <int cv.aruco.DetectorParameters.get_minDistanceToBorder []>
java: int get_minDistanceToBorder()
FUNC <void cv.aruco.DetectorParameters.set_minDistanceToBorder [ARG int minDistanceToBorder=]>
java: void set_minDistanceToBorder(int minDistanceToBorder)
FUNC <double cv.aruco.DetectorParameters.get_minMarkerDistanceRate []>
java: double get_minMarkerDistanceRate()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerDistanceRate [ARG double minMarkerDistanceRate=]>
java: void set_minMarkerDistanceRate(double minMarkerDistanceRate)
FUNC <CornerRefineMethod cv.aruco.DetectorParameters.get_cornerRefinementMethod []>
SKIP:CornerRefineMethod DetectorParameters::cornerRefinementMethod	 due to RET type CornerRefineMethod
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMethod [ARG CornerRefineMethod cornerRefinementMethod=]>
SKIP:void DetectorParameters::cornerRefinementMethod	 due to ARG type CornerRefineMethod/I
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementWinSize []>
java: int get_cornerRefinementWinSize()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementWinSize [ARG int cornerRefinementWinSize=]>
java: void set_cornerRefinementWinSize(int cornerRefinementWinSize)
FUNC <int cv.aruco.DetectorParameters.get_cornerRefinementMaxIterations []>
java: int get_cornerRefinementMaxIterations()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMaxIterations [ARG int cornerRefinementMaxIterations=]>
java: void set_cornerRefinementMaxIterations(int cornerRefinementMaxIterations)
FUNC <double cv.aruco.DetectorParameters.get_cornerRefinementMinAccuracy []>
java: double get_cornerRefinementMinAccuracy()
FUNC <void cv.aruco.DetectorParameters.set_cornerRefinementMinAccuracy [ARG double cornerRefinementMinAccuracy=]>
java: void set_cornerRefinementMinAccuracy(double cornerRefinementMinAccuracy)
FUNC <int cv.aruco.DetectorParameters.get_markerBorderBits []>
java: int get_markerBorderBits()
FUNC <void cv.aruco.DetectorParameters.set_markerBorderBits [ARG int markerBorderBits=]>
java: void set_markerBorderBits(int markerBorderBits)
FUNC <int cv.aruco.DetectorParameters.get_perspectiveRemovePixelPerCell []>
java: int get_perspectiveRemovePixelPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemovePixelPerCell [ARG int perspectiveRemovePixelPerCell=]>
java: void set_perspectiveRemovePixelPerCell(int perspectiveRemovePixelPerCell)
FUNC <double cv.aruco.DetectorParameters.get_perspectiveRemoveIgnoredMarginPerCell []>
java: double get_perspectiveRemoveIgnoredMarginPerCell()
FUNC <void cv.aruco.DetectorParameters.set_perspectiveRemoveIgnoredMarginPerCell [ARG double perspectiveRemoveIgnoredMarginPerCell=]>
java: void set_perspectiveRemoveIgnoredMarginPerCell(double perspectiveRemoveIgnoredMarginPerCell)
FUNC <double cv.aruco.DetectorParameters.get_maxErroneousBitsInBorderRate []>
java: double get_maxErroneousBitsInBorderRate()
FUNC <void cv.aruco.DetectorParameters.set_maxErroneousBitsInBorderRate [ARG double maxErroneousBitsInBorderRate=]>
java: void set_maxErroneousBitsInBorderRate(double maxErroneousBitsInBorderRate)
FUNC <double cv.aruco.DetectorParameters.get_minOtsuStdDev []>
java: double get_minOtsuStdDev()
FUNC <void cv.aruco.DetectorParameters.set_minOtsuStdDev [ARG double minOtsuStdDev=]>
java: void set_minOtsuStdDev(double minOtsuStdDev)
FUNC <double cv.aruco.DetectorParameters.get_errorCorrectionRate []>
java: double get_errorCorrectionRate()
FUNC <void cv.aruco.DetectorParameters.set_errorCorrectionRate [ARG double errorCorrectionRate=]>
java: void set_errorCorrectionRate(double errorCorrectionRate)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagQuadDecimate []>
java: float get_aprilTagQuadDecimate()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagQuadDecimate [ARG float aprilTagQuadDecimate=]>
java: void set_aprilTagQuadDecimate(float aprilTagQuadDecimate)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagQuadSigma []>
java: float get_aprilTagQuadSigma()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagQuadSigma [ARG float aprilTagQuadSigma=]>
java: void set_aprilTagQuadSigma(float aprilTagQuadSigma)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMinClusterPixels []>
java: int get_aprilTagMinClusterPixels()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMinClusterPixels [ARG int aprilTagMinClusterPixels=]>
java: void set_aprilTagMinClusterPixels(int aprilTagMinClusterPixels)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMaxNmaxima []>
java: int get_aprilTagMaxNmaxima()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMaxNmaxima [ARG int aprilTagMaxNmaxima=]>
java: void set_aprilTagMaxNmaxima(int aprilTagMaxNmaxima)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagCriticalRad []>
java: float get_aprilTagCriticalRad()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagCriticalRad [ARG float aprilTagCriticalRad=]>
java: void set_aprilTagCriticalRad(float aprilTagCriticalRad)
FUNC <float cv.aruco.DetectorParameters.get_aprilTagMaxLineFitMse []>
java: float get_aprilTagMaxLineFitMse()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMaxLineFitMse [ARG float aprilTagMaxLineFitMse=]>
java: void set_aprilTagMaxLineFitMse(float aprilTagMaxLineFitMse)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagMinWhiteBlackDiff []>
java: int get_aprilTagMinWhiteBlackDiff()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagMinWhiteBlackDiff [ARG int aprilTagMinWhiteBlackDiff=]>
java: void set_aprilTagMinWhiteBlackDiff(int aprilTagMinWhiteBlackDiff)
FUNC <int cv.aruco.DetectorParameters.get_aprilTagDeglitch []>
java: int get_aprilTagDeglitch()
FUNC <void cv.aruco.DetectorParameters.set_aprilTagDeglitch [ARG int aprilTagDeglitch=]>
java: void set_aprilTagDeglitch(int aprilTagDeglitch)
FUNC <bool cv.aruco.DetectorParameters.get_detectInvertedMarker []>
java: boolean get_detectInvertedMarker()
FUNC <void cv.aruco.DetectorParameters.set_detectInvertedMarker [ARG bool detectInvertedMarker=]>
java: void set_detectInvertedMarker(boolean detectInvertedMarker)
FUNC <bool cv.aruco.DetectorParameters.get_useAruco3Detection []>
java: boolean get_useAruco3Detection()
FUNC <void cv.aruco.DetectorParameters.set_useAruco3Detection [ARG bool useAruco3Detection=]>
java: void set_useAruco3Detection(boolean useAruco3Detection)
FUNC <int cv.aruco.DetectorParameters.get_minSideLengthCanonicalImg []>
java: int get_minSideLengthCanonicalImg()
FUNC <void cv.aruco.DetectorParameters.set_minSideLengthCanonicalImg [ARG int minSideLengthCanonicalImg=]>
java: void set_minSideLengthCanonicalImg(int minSideLengthCanonicalImg)
FUNC <float cv.aruco.DetectorParameters.get_minMarkerLengthRatioOriginalImg []>
java: float get_minMarkerLengthRatioOriginalImg()
FUNC <void cv.aruco.DetectorParameters.set_minMarkerLengthRatioOriginalImg [ARG float minMarkerLengthRatioOriginalImg=]>
java: void set_minMarkerLengthRatioOriginalImg(float minMarkerLengthRatioOriginalImg)
CLASS cv.aruco::.Dictionary : 
FUNC < cv.aruco.Dictionary.Dictionary []>
java:  Dictionary()
FUNC < cv.aruco.Dictionary.Dictionary [ARG Mat bytesList=, ARG int _markerSize=, ARG int maxcorr=0]>
java:  Dictionary(Mat bytesList, int _markerSize, int maxcorr)
java:  Dictionary(Mat bytesList, int _markerSize)
FUNC <bool cv.aruco.Dictionary.readDictionary [ARG FileNode fn=]>
SKIP:bool cv::aruco::Dictionary::readDictionary(FileNode fn)	 due to ARG type FileNode/I
FUNC <void cv.aruco.Dictionary.writeDictionary [ARG FileStorage fs=, ARG String name=String()]>
SKIP:void cv::aruco::Dictionary::writeDictionary(FileStorage fs, String name = String())	 due to ARG type FileStorage/I
FUNC <bool cv.aruco.Dictionary.identify [ARG Mat onlyBits=, ARG int idx=, ARG int rotation=, ARG double maxCorrectionRate=]>
java: boolean identify(Mat onlyBits, int[] idx, int[] rotation, double maxCorrectionRate)
FUNC <int cv.aruco.Dictionary.getDistanceToId [ARG Mat bits=, ARG int id=, ARG bool allRotations=true]>
java: int getDistanceToId(Mat bits, int id, boolean allRotations)
java: int getDistanceToId(Mat bits, int id)
FUNC <void cv.aruco.Dictionary.generateImageMarker [ARG int id=, ARG int sidePixels=, ARG Mat _img=, ARG int borderBits=1]>
java: void generateImageMarker(int id, int sidePixels, Mat _img, int borderBits)
java: void generateImageMarker(int id, int sidePixels, Mat _img)
FUNC <Mat cv.aruco.Dictionary.getByteListFromBits [ARG Mat bits=]>
java: Mat getByteListFromBits(Mat bits)
FUNC <Mat cv.aruco.Dictionary.getBitsFromByteList [ARG Mat byteList=, ARG int markerSize=]>
java: Mat getBitsFromByteList(Mat byteList, int markerSize)
FUNC <Mat cv.aruco.Dictionary.get_bytesList []>
java: Mat get_bytesList()
FUNC <void cv.aruco.Dictionary.set_bytesList [ARG Mat bytesList=]>
java: void set_bytesList(Mat bytesList)
FUNC <int cv.aruco.Dictionary.get_markerSize []>
java: int get_markerSize()
FUNC <void cv.aruco.Dictionary.set_markerSize [ARG int markerSize=]>
java: void set_markerSize(int markerSize)
FUNC <int cv.aruco.Dictionary.get_maxCorrectionBits []>
java: int get_maxCorrectionBits()
FUNC <void cv.aruco.Dictionary.set_maxCorrectionBits [ARG int maxCorrectionBits=]>
java: void set_maxCorrectionBits(int maxCorrectionBits)
CLASS cv.aruco::.GridBoard : Board
FUNC < cv.aruco.GridBoard.GridBoard [ARG Size size=, ARG float markerLength=, ARG float markerSeparation=, ARG Dictionary dictionary=, ARG Mat ids=Mat()]>
java:  GridBoard(Size size, float markerLength, float markerSeparation, Dictionary dictionary, Mat ids)
java:  GridBoard(Size size, float markerLength, float markerSeparation, Dictionary dictionary)
FUNC <Size cv.aruco.GridBoard.getGridSize []>
java: Size getGridSize()
FUNC <float cv.aruco.GridBoard.getMarkerLength []>
java: float getMarkerLength()
FUNC <float cv.aruco.GridBoard.getMarkerSeparation []>
java: float getMarkerSeparation()
CLASS cv.aruco::.RefineParameters : 
FUNC < cv.aruco.RefineParameters.RefineParameters [ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true]>
java:  RefineParameters(float minRepDistance, float errorCorrectionRate, boolean checkAllOrders)
java:  RefineParameters(float minRepDistance, float errorCorrectionRate)
java:  RefineParameters(float minRepDistance)
java:  RefineParameters()
FUNC <bool cv.aruco.RefineParameters.readRefineParameters [ARG FileNode fn=]>
SKIP:bool cv::aruco::RefineParameters::readRefineParameters(FileNode fn)	 due to ARG type FileNode/I
FUNC <bool cv.aruco.RefineParameters.writeRefineParameters [ARG FileStorage fs=, ARG String name=String()]>
SKIP:bool cv::aruco::RefineParameters::writeRefineParameters(FileStorage fs, String name = String())	 due to ARG type FileStorage/I
FUNC <float cv.aruco.RefineParameters.get_minRepDistance []>
java: float get_minRepDistance()
FUNC <void cv.aruco.RefineParameters.set_minRepDistance [ARG float minRepDistance=]>
java: void set_minRepDistance(float minRepDistance)
FUNC <float cv.aruco.RefineParameters.get_errorCorrectionRate []>
java: float get_errorCorrectionRate()
FUNC <void cv.aruco.RefineParameters.set_errorCorrectionRate [ARG float errorCorrectionRate=]>
java: void set_errorCorrectionRate(float errorCorrectionRate)
FUNC <bool cv.aruco.RefineParameters.get_checkAllOrders []>
java: boolean get_checkAllOrders()
FUNC <void cv.aruco.RefineParameters.set_checkAllOrders [ARG bool checkAllOrders=]>
java: void set_checkAllOrders(boolean checkAllOrders)

=== MODULE: structured_light (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light) ===


Files (4):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/sinusoidalpattern.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/graycodepattern.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/structured_light.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Structured_light : , name: Structured_light, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/sinusoidalpattern.hpp =====
Namespaces: ['cv', 'cv.structured_light']

--- Incoming ---
[   'enum cv.structured_light.<unnamed>',
    '',
    [],
    [   ['const cv.structured_light.FTP', '0', [], [], None, ''],
        ['const cv.structured_light.PSP', '1', [], [], None, ''],
        ['const cv.structured_light.FAPS', '2', [], [], None, '']],
    None]
ok: CONST FTP=0
ok: CONST PSP=1
ok: CONST FAPS=2

--- Incoming ---
[   'class cv.structured_light.SinusoidalPattern',
    ': cv::structured_light::StructuredLightPattern',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.SinusoidalPattern : StructuredLightPattern, name: SinusoidalPattern, base: StructuredLightPattern

--- Incoming ---
[   'struct cv.structured_light.SinusoidalPattern.Params',
    '',
    [],
    [   ['int', 'width', '', ['/RW']],
        ['int', 'height', '', ['/RW']],
        ['int', 'nbrOfPeriods', '', ['/RW']],
        ['float', 'shiftValue', '', ['/RW']],
        ['int', 'methodId', '', ['/RW']],
        ['int', 'nbrOfPixelsBetweenMarkers', '', ['/RW']],
        ['bool', 'horizontal', '', ['/RW']],
        ['bool', 'setMarkers', '', ['/RW']]],
    None]
ok: class CLASS cv.structured_light::SinusoidalPattern.SinusoidalPattern_Params : , name: SinusoidalPattern_Params, base: 

--- Incoming ---
['cv.structured_light.SinusoidalPattern.Params.Params', '', [], [], None]
ok: FUNC < cv.structured_light.SinusoidalPattern.Params.SinusoidalPattern_Params []>

--- Incoming ---
[   'cv.structured_light.SinusoidalPattern.create',
    'Ptr_SinusoidalPattern',
    ['/S'],
    [   [   'Ptr_SinusoidalPattern_Params',
            'parameters',
            'makePtr<SinusoidalPattern::Params>()',
            []]],
    'Ptr<SinusoidalPattern>']
ok: FUNC <Ptr_SinusoidalPattern cv.structured_light.SinusoidalPattern.create [ARG Ptr_SinusoidalPattern_Params parameters=makePtr<SinusoidalPattern::Params>()]>

--- Incoming ---
[   'cv.structured_light.SinusoidalPattern.computePhaseMap',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'patternImages', '', []],
        ['Mat', 'wrappedPhaseMap', '', ['/O']],
        ['Mat', 'shadowMask', 'Mat()', ['/O']],
        ['Mat', 'fundamental', 'Mat()', []]],
    'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.computePhaseMap [ARG vector_Mat patternImages=, ARG Mat wrappedPhaseMap=, ARG Mat shadowMask=Mat(), ARG Mat fundamental=Mat()]>

--- Incoming ---
[   'cv.structured_light.SinusoidalPattern.unwrapPhaseMap',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'wrappedPhaseMap', '', []],
        ['Mat', 'unwrappedPhaseMap', '', ['/O']],
        ['Size', 'camSize', '', []],
        ['Mat', 'shadowMask', 'Mat()', []]],
    'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Size camSize=, ARG Mat shadowMask=Mat()]>

--- Incoming ---
[   'cv.structured_light.SinusoidalPattern.findProCamMatches',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'projUnwrappedPhaseMap', '', []],
        ['Mat', 'camUnwrappedPhaseMap', '', []],
        ['vector_Mat', 'matches', '', ['/O']]],
    'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.findProCamMatches [ARG Mat projUnwrappedPhaseMap=, ARG Mat camUnwrappedPhaseMap=, ARG vector_Mat matches=]>

--- Incoming ---
[   'cv.structured_light.SinusoidalPattern.computeDataModulationTerm',
    'void',
    ['/V', '/PV'],
    [   ['vector_Mat', 'patternImages', '', []],
        ['Mat', 'dataModulationTerm', '', ['/O']],
        ['Mat', 'shadowMask', '', []]],
    'void']
ok: FUNC <void cv.structured_light.SinusoidalPattern.computeDataModulationTerm [ARG vector_Mat patternImages=, ARG Mat dataModulationTerm=, ARG Mat shadowMask=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/graycodepattern.hpp =====
Namespaces: ['cv', 'cv.structured_light']

--- Incoming ---
[   'class cv.structured_light.GrayCodePattern',
    ': cv::structured_light::StructuredLightPattern',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.GrayCodePattern : StructuredLightPattern, name: GrayCodePattern, base: StructuredLightPattern

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.create',
    'Ptr_GrayCodePattern',
    ['/S'],
    [['int', 'width', '', []], ['int', 'height', '', []]],
    'Ptr<GrayCodePattern>']
ok: FUNC <Ptr_GrayCodePattern cv.structured_light.GrayCodePattern.create [ARG int width=, ARG int height=]>

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.getNumberOfPatternImages',
    'size_t',
    ['/C', '/V', '/PV'],
    [],
    'size_t']
ok: FUNC <size_t cv.structured_light.GrayCodePattern.getNumberOfPatternImages []>

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.setWhiteThreshold',
    'void',
    ['/V', '/PV'],
    [['size_t', 'value', '', []]],
    'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.setWhiteThreshold [ARG size_t value=]>

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.setBlackThreshold',
    'void',
    ['/V', '/PV'],
    [['size_t', 'value', '', []]],
    'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.setBlackThreshold [ARG size_t value=]>

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.getImagesForShadowMasks',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'blackImage', '', ['/IO']], ['Mat', 'whiteImage', '', ['/IO']]],
    'void']
ok: FUNC <void cv.structured_light.GrayCodePattern.getImagesForShadowMasks [ARG Mat blackImage=, ARG Mat whiteImage=]>

--- Incoming ---
[   'cv.structured_light.GrayCodePattern.getProjPixel',
    'bool',
    ['/C', '/V', '/PV'],
    [   ['vector_Mat', 'patternImages', '', []],
        ['int', 'x', '', []],
        ['int', 'y', '', []],
        ['Point', 'projPix', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv.structured_light.GrayCodePattern.getProjPixel [ARG vector_Mat patternImages=, ARG int x=, ARG int y=, ARG Point projPix=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/structured_light/include/opencv2/structured_light/structured_light.hpp =====
Namespaces: ['cv', 'cv.structured_light']

--- Incoming ---
[   'enum cv.structured_light.<unnamed>',
    '',
    [],
    [['const cv.structured_light.DECODE_3D_UNDERWORLD', '0', [], [], None, '']],
    None]
ok: CONST DECODE_3D_UNDERWORLD=0

--- Incoming ---
[   'class cv.structured_light.StructuredLightPattern',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.structured_light::.StructuredLightPattern : Algorithm, name: StructuredLightPattern, base: Algorithm

--- Incoming ---
[   'cv.structured_light.StructuredLightPattern.generate',
    'bool',
    ['/V', '/PV'],
    [['vector_Mat', 'patternImages', '', ['/O']]],
    'bool']
ok: FUNC <bool cv.structured_light.StructuredLightPattern.generate [ARG vector_Mat patternImages=]>

--- Incoming ---
[   'cv.structured_light.StructuredLightPattern.decode',
    'bool',
    ['/C', '/V', '/PV'],
    [   ['vector_vector_Mat', 'patternImages', '', ['/C', '/Ref']],
        ['Mat', 'disparityMap', '', ['/O']],
        ['vector_Mat', 'blackImages', 'vector_Mat()', []],
        ['vector_Mat', 'whiteImages', 'vector_Mat()', []],
        ['int', 'flags', 'DECODE_3D_UNDERWORLD', []]],
    'bool']
ok: FUNC <bool cv.structured_light.StructuredLightPattern.decode [ARG vector_vector_Mat patternImages=, ARG Mat disparityMap=, ARG vector_Mat blackImages=vector_Mat(), ARG vector_Mat whiteImages=vector_Mat(), ARG int flags=DECODE_3D_UNDERWORLD]>


===== Generating... =====
CLASS cv::.Structured_light : 
[CONST FTP=0, CONST PSP=1, CONST FAPS=2, CONST DECODE_3D_UNDERWORLD=0]
CLASS cv.structured_light::.GrayCodePattern : StructuredLightPattern
FUNC <Ptr_GrayCodePattern cv.structured_light.GrayCodePattern.create [ARG int width=, ARG int height=]>
java: GrayCodePattern create(int width, int height)
FUNC <size_t cv.structured_light.GrayCodePattern.getNumberOfPatternImages []>
java: long getNumberOfPatternImages()
FUNC <void cv.structured_light.GrayCodePattern.setWhiteThreshold [ARG size_t value=]>
java: void setWhiteThreshold(long value)
FUNC <void cv.structured_light.GrayCodePattern.setBlackThreshold [ARG size_t value=]>
java: void setBlackThreshold(long value)
FUNC <void cv.structured_light.GrayCodePattern.getImagesForShadowMasks [ARG Mat blackImage=, ARG Mat whiteImage=]>
java: void getImagesForShadowMasks(Mat blackImage, Mat whiteImage)
FUNC <bool cv.structured_light.GrayCodePattern.getProjPixel [ARG vector_Mat patternImages=, ARG int x=, ARG int y=, ARG Point projPix=]>
java: boolean getProjPixel(List<Mat> patternImages, int x, int y, Point projPix)
CLASS cv.structured_light::.SinusoidalPattern : StructuredLightPattern
FUNC <Ptr_SinusoidalPattern cv.structured_light.SinusoidalPattern.create [ARG Ptr_SinusoidalPattern_Params parameters=makePtr<SinusoidalPattern::Params>()]>
java: SinusoidalPattern create(SinusoidalPattern_Params parameters)
java: SinusoidalPattern create()
FUNC <void cv.structured_light.SinusoidalPattern.computePhaseMap [ARG vector_Mat patternImages=, ARG Mat wrappedPhaseMap=, ARG Mat shadowMask=Mat(), ARG Mat fundamental=Mat()]>
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap, Mat shadowMask, Mat fundamental)
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap, Mat shadowMask)
java: void computePhaseMap(List<Mat> patternImages, Mat wrappedPhaseMap)
FUNC <void cv.structured_light.SinusoidalPattern.unwrapPhaseMap [ARG Mat wrappedPhaseMap=, ARG Mat unwrappedPhaseMap=, ARG Size camSize=, ARG Mat shadowMask=Mat()]>
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap, Size camSize, Mat shadowMask)
java: void unwrapPhaseMap(Mat wrappedPhaseMap, Mat unwrappedPhaseMap, Size camSize)
FUNC <void cv.structured_light.SinusoidalPattern.findProCamMatches [ARG Mat projUnwrappedPhaseMap=, ARG Mat camUnwrappedPhaseMap=, ARG vector_Mat matches=]>
java: void findProCamMatches(Mat projUnwrappedPhaseMap, Mat camUnwrappedPhaseMap, List<Mat> matches)
FUNC <void cv.structured_light.SinusoidalPattern.computeDataModulationTerm [ARG vector_Mat patternImages=, ARG Mat dataModulationTerm=, ARG Mat shadowMask=]>
java: void computeDataModulationTerm(List<Mat> patternImages, Mat dataModulationTerm, Mat shadowMask)
CLASS cv.structured_light::SinusoidalPattern.SinusoidalPattern_Params : 
FUNC < cv.structured_light.SinusoidalPattern.Params.SinusoidalPattern_Params []>
java:  SinusoidalPattern_Params()
FUNC <int cv.structured_light.SinusoidalPattern.Params.get_width []>
java: int get_width()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_width [ARG int width=]>
java: void set_width(int width)
FUNC <int cv.structured_light.SinusoidalPattern.Params.get_height []>
java: int get_height()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_height [ARG int height=]>
java: void set_height(int height)
FUNC <int cv.structured_light.SinusoidalPattern.Params.get_nbrOfPeriods []>
java: int get_nbrOfPeriods()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_nbrOfPeriods [ARG int nbrOfPeriods=]>
java: void set_nbrOfPeriods(int nbrOfPeriods)
FUNC <float cv.structured_light.SinusoidalPattern.Params.get_shiftValue []>
java: float get_shiftValue()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_shiftValue [ARG float shiftValue=]>
java: void set_shiftValue(float shiftValue)
FUNC <int cv.structured_light.SinusoidalPattern.Params.get_methodId []>
java: int get_methodId()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_methodId [ARG int methodId=]>
java: void set_methodId(int methodId)
FUNC <int cv.structured_light.SinusoidalPattern.Params.get_nbrOfPixelsBetweenMarkers []>
java: int get_nbrOfPixelsBetweenMarkers()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_nbrOfPixelsBetweenMarkers [ARG int nbrOfPixelsBetweenMarkers=]>
java: void set_nbrOfPixelsBetweenMarkers(int nbrOfPixelsBetweenMarkers)
FUNC <bool cv.structured_light.SinusoidalPattern.Params.get_horizontal []>
java: boolean get_horizontal()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_horizontal [ARG bool horizontal=]>
java: void set_horizontal(boolean horizontal)
FUNC <bool cv.structured_light.SinusoidalPattern.Params.get_setMarkers []>
java: boolean get_setMarkers()
FUNC <void cv.structured_light.SinusoidalPattern.Params.set_setMarkers [ARG bool setMarkers=]>
java: void set_setMarkers(boolean setMarkers)
CLASS cv.structured_light::.StructuredLightPattern : Algorithm
FUNC <bool cv.structured_light.StructuredLightPattern.generate [ARG vector_Mat patternImages=]>
java: boolean generate(List<Mat> patternImages)
FUNC <bool cv.structured_light.StructuredLightPattern.decode [ARG vector_vector_Mat patternImages=, ARG Mat disparityMap=, ARG vector_Mat blackImages=vector_Mat(), ARG vector_Mat whiteImages=vector_Mat(), ARG int flags=DECODE_3D_UNDERWORLD]>
SKIP:bool cv::structured_light::StructuredLightPattern::decode(vector_vector_Mat patternImages, Mat& disparityMap, vector_Mat blackImages = vector_Mat(), vector_Mat whiteImages = vector_Mat(), int flags = DECODE_3D_UNDERWORLD)	 due to ARG type vector_vector_Mat/I

=== MODULE: video (/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video) ===


Files (5):
['/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/video.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/background_segm.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/tracking.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/detail/tracking.detail.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Video : , name: Video, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/video.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/video.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/background_segm.hpp =====
Namespaces: ['cv']

--- Incoming ---
['class cv.BackgroundSubtractor', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BackgroundSubtractor : Algorithm, name: BackgroundSubtractor, base: Algorithm

--- Incoming ---
[   'cv.BackgroundSubtractor.apply',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'fgmask', '', ['/O']],
        ['double', 'learningRate', '-1', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   'cv.BackgroundSubtractor.getBackgroundImage',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'backgroundImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   'class cv.BackgroundSubtractorMOG2',
    ': cv::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor, name: BackgroundSubtractorMOG2, base: BackgroundSubtractor

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getHistory',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setHistory',
    'void',
    ['/V', '/PV'],
    [['int', 'history', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getNMixtures',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setNMixtures',
    'void',
    ['/V', '/PV'],
    [['int', 'nmixtures', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getBackgroundRatio',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setBackgroundRatio',
    'void',
    ['/V', '/PV'],
    [['double', 'ratio', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getVarThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setVarThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'varThreshold', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getVarThresholdGen',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setVarThresholdGen',
    'void',
    ['/V', '/PV'],
    [['double', 'varThresholdGen', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getVarInit',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setVarInit',
    'void',
    ['/V', '/PV'],
    [['double', 'varInit', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getVarMin',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setVarMin',
    'void',
    ['/V', '/PV'],
    [['double', 'varMin', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getVarMax',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setVarMax',
    'void',
    ['/V', '/PV'],
    [['double', 'varMax', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'ct', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getDetectShadows',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setDetectShadows',
    'void',
    ['/V', '/PV'],
    [['bool', 'detectShadows', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getShadowValue',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setShadowValue',
    'void',
    ['/V', '/PV'],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.getShadowThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.setShadowThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   'cv.BackgroundSubtractorMOG2.apply',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'fgmask', '', ['/O']],
        ['double', 'learningRate', '-1', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   'cv.createBackgroundSubtractorMOG2',
    'Ptr_BackgroundSubtractorMOG2',
    [],
    [   ['int', 'history', '500', []],
        ['double', 'varThreshold', '16', []],
        ['bool', 'detectShadows', 'true', []]],
    'Ptr<BackgroundSubtractorMOG2>']
ok: FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>

--- Incoming ---
['class cv.BackgroundSubtractorKNN', ': cv::BackgroundSubtractor', [], [], None]
ok: class CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor, name: BackgroundSubtractorKNN, base: BackgroundSubtractor

--- Incoming ---
['cv.BackgroundSubtractorKNN.getHistory', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getHistory []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setHistory',
    'void',
    ['/V', '/PV'],
    [['int', 'history', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getNSamples',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setNSamples',
    'void',
    ['/V', '/PV'],
    [['int', '_nN', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getDist2Threshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setDist2Threshold',
    'void',
    ['/V', '/PV'],
    [['double', '_dist2Threshold', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getkNNSamples',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setkNNSamples',
    'void',
    ['/V', '/PV'],
    [['int', '_nkNN', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getDetectShadows',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setDetectShadows',
    'void',
    ['/V', '/PV'],
    [['bool', 'detectShadows', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getShadowValue',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setShadowValue',
    'void',
    ['/V', '/PV'],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.getShadowThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>

--- Incoming ---
[   'cv.BackgroundSubtractorKNN.setShadowThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   'cv.createBackgroundSubtractorKNN',
    'Ptr_BackgroundSubtractorKNN',
    [],
    [   ['int', 'history', '500', []],
        ['double', 'dist2Threshold', '400.0', []],
        ['bool', 'detectShadows', 'true', []]],
    'Ptr<BackgroundSubtractorKNN>']
ok: FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/tracking.hpp =====
Namespaces: ['cv']

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.OPTFLOW_USE_INITIAL_FLOW', '4', [], [], None, ''],
        ['const cv.OPTFLOW_LK_GET_MIN_EIGENVALS', '8', [], [], None, ''],
        ['const cv.OPTFLOW_FARNEBACK_GAUSSIAN', '256', [], [], None, '']],
    None]
ok: CONST OPTFLOW_USE_INITIAL_FLOW=4
ok: CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8
ok: CONST OPTFLOW_FARNEBACK_GAUSSIAN=256

--- Incoming ---
[   'cv.CamShift',
    'RotatedRect',
    [],
    [   ['Mat', 'probImage', '', []],
        ['Rect', 'window', '', ['/IO', '/Ref']],
        ['TermCriteria', 'criteria', '', []]],
    'RotatedRect']
ok: FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   'cv.meanShift',
    'int',
    [],
    [   ['Mat', 'probImage', '', []],
        ['Rect', 'window', '', ['/IO', '/Ref']],
        ['TermCriteria', 'criteria', '', []]],
    'int']
ok: FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   'cv.buildOpticalFlowPyramid',
    'int',
    [],
    [   ['Mat', 'img', '', []],
        ['vector_Mat', 'pyramid', '', ['/O']],
        ['Size', 'winSize', '', []],
        ['int', 'maxLevel', '', []],
        ['bool', 'withDerivatives', 'true', []],
        ['int', 'pyrBorder', 'BORDER_REFLECT_101', []],
        ['int', 'derivBorder', 'BORDER_CONSTANT', []],
        ['bool', 'tryReuseInputImage', 'true', []]],
    'int']
ok: FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>

--- Incoming ---
[   'cv.calcOpticalFlowPyrLK',
    'void',
    [],
    [   ['Mat', 'prevImg', '', []],
        ['Mat', 'nextImg', '', []],
        ['Mat', 'prevPts', '', []],
        ['Mat', 'nextPts', '', ['/IO']],
        ['Mat', 'status', '', ['/O']],
        ['Mat', 'err', '', ['/O']],
        ['Size', 'winSize', 'Size(21,21)', []],
        ['int', 'maxLevel', '3', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        ['int', 'flags', '0', []],
        ['double', 'minEigThreshold', '1e-4', []]],
    'void']
ok: FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
[   'cv.calcOpticalFlowFarneback',
    'void',
    [],
    [   ['Mat', 'prev', '', []],
        ['Mat', 'next', '', []],
        ['Mat', 'flow', '', ['/IO']],
        ['double', 'pyr_scale', '', []],
        ['int', 'levels', '', []],
        ['int', 'winsize', '', []],
        ['int', 'iterations', '', []],
        ['int', 'poly_n', '', []],
        ['double', 'poly_sigma', '', []],
        ['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>

--- Incoming ---
[   'enum cv.<unnamed>',
    '',
    [],
    [   ['const cv.MOTION_TRANSLATION', '0', [], [], None, ''],
        ['const cv.MOTION_EUCLIDEAN', '1', [], [], None, ''],
        ['const cv.MOTION_AFFINE', '2', [], [], None, ''],
        ['const cv.MOTION_HOMOGRAPHY', '3', [], [], None, '']],
    None]
ok: CONST MOTION_TRANSLATION=0
ok: CONST MOTION_EUCLIDEAN=1
ok: CONST MOTION_AFFINE=2
ok: CONST MOTION_HOMOGRAPHY=3

--- Incoming ---
[   'cv.computeECC',
    'double',
    [],
    [   ['Mat', 'templateImage', '', []],
        ['Mat', 'inputImage', '', []],
        ['Mat', 'inputMask', 'Mat()', []]],
    'double']
ok: FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>

--- Incoming ---
[   'cv.findTransformECC',
    'double',
    [],
    [   ['Mat', 'templateImage', '', []],
        ['Mat', 'inputImage', '', []],
        ['Mat', 'warpMatrix', '', ['/IO']],
        ['int', 'motionType', '', []],
        ['TermCriteria', 'criteria', '', []],
        ['Mat', 'inputMask', '', []],
        ['int', 'gaussFiltSize', '', []]],
    'double']
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>

--- Incoming ---
[   'cv.findTransformECC',
    'double',
    [],
    [   ['Mat', 'templateImage', '', []],
        ['Mat', 'inputImage', '', []],
        ['Mat', 'warpMatrix', '', ['/IO']],
        ['int', 'motionType', 'MOTION_AFFINE', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001)',
            []],
        ['Mat', 'inputMask', 'Mat()', []]],
    'double']
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>

--- Incoming ---
[   'class cv.KalmanFilter',
    '',
    [],
    [   ['Mat', 'statePre', '', ['/RW']],
        ['Mat', 'statePost', '', ['/RW']],
        ['Mat', 'transitionMatrix', '', ['/RW']],
        ['Mat', 'controlMatrix', '', ['/RW']],
        ['Mat', 'measurementMatrix', '', ['/RW']],
        ['Mat', 'processNoiseCov', '', ['/RW']],
        ['Mat', 'measurementNoiseCov', '', ['/RW']],
        ['Mat', 'errorCovPre', '', ['/RW']],
        ['Mat', 'gain', '', ['/RW']],
        ['Mat', 'errorCovPost', '', ['/RW']]],
    None]
ok: class CLASS cv::.KalmanFilter : , name: KalmanFilter, base: 

--- Incoming ---
['cv.KalmanFilter.KalmanFilter', '', [], [], None]
ok: FUNC < cv.KalmanFilter.KalmanFilter []>

--- Incoming ---
[   'cv.KalmanFilter.KalmanFilter',
    '',
    [],
    [   ['int', 'dynamParams', '', []],
        ['int', 'measureParams', '', []],
        ['int', 'controlParams', '0', []],
        ['int', 'type', 'CV_32F', []]],
    None]
ok: FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>

--- Incoming ---
[   'cv.KalmanFilter.predict',
    'Mat',
    [],
    [['Mat', 'control', 'Mat()', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>

--- Incoming ---
[   'cv.KalmanFilter.correct',
    'Mat',
    [],
    [['Mat', 'measurement', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>

--- Incoming ---
[   'cv.readOpticalFlow',
    'Mat',
    [],
    [['String', 'path', '', ['/C', '/Ref']]],
    'Mat']
ok: FUNC <Mat cv..readOpticalFlow [ARG String path=]>

--- Incoming ---
[   'cv.writeOpticalFlow',
    'bool',
    [],
    [['String', 'path', '', ['/C', '/Ref']], ['Mat', 'flow', '', []]],
    'bool']
ok: FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>

--- Incoming ---
['class cv.DenseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DenseOpticalFlow : Algorithm, name: DenseOpticalFlow, base: Algorithm

--- Incoming ---
[   'cv.DenseOpticalFlow.calc',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'I0', '', []],
        ['Mat', 'I1', '', []],
        ['Mat', 'flow', '', ['/IO']]],
    'void']
ok: FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>

--- Incoming ---
['cv.DenseOpticalFlow.collectGarbage', 'void', ['/V', '/PV'], [], 'void']
ok: FUNC <void cv.DenseOpticalFlow.collectGarbage []>

--- Incoming ---
['class cv.SparseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.SparseOpticalFlow : Algorithm, name: SparseOpticalFlow, base: Algorithm

--- Incoming ---
[   'cv.SparseOpticalFlow.calc',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'prevImg', '', []],
        ['Mat', 'nextImg', '', []],
        ['Mat', 'prevPts', '', []],
        ['Mat', 'nextPts', '', ['/IO']],
        ['Mat', 'status', '', ['/O']],
        ['Mat', 'err', 'cv::Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>

--- Incoming ---
['class cv.FarnebackOpticalFlow', ': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow, name: FarnebackOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
['cv.FarnebackOpticalFlow.getNumLevels', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setNumLevels',
    'void',
    ['/V', '/PV'],
    [['int', 'numLevels', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.getPyrScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setPyrScale',
    'void',
    ['/V', '/PV'],
    [['double', 'pyrScale', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.getFastPyramids',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setFastPyramids',
    'void',
    ['/V', '/PV'],
    [['bool', 'fastPyramids', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>

--- Incoming ---
['cv.FarnebackOpticalFlow.getWinSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getWinSize []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setWinSize',
    'void',
    ['/V', '/PV'],
    [['int', 'winSize', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>

--- Incoming ---
['cv.FarnebackOpticalFlow.getNumIters', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumIters []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setNumIters',
    'void',
    ['/V', '/PV'],
    [['int', 'numIters', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>

--- Incoming ---
['cv.FarnebackOpticalFlow.getPolyN', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getPolyN []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setPolyN',
    'void',
    ['/V', '/PV'],
    [['int', 'polyN', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.getPolySigma',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setPolySigma',
    'void',
    ['/V', '/PV'],
    [['double', 'polySigma', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>

--- Incoming ---
['cv.FarnebackOpticalFlow.getFlags', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getFlags []>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.setFlags',
    'void',
    ['/V', '/PV'],
    [['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   'cv.FarnebackOpticalFlow.create',
    'Ptr_FarnebackOpticalFlow',
    ['/S'],
    [   ['int', 'numLevels', '5', []],
        ['double', 'pyrScale', '0.5', []],
        ['bool', 'fastPyramids', 'false', []],
        ['int', 'winSize', '13', []],
        ['int', 'numIters', '10', []],
        ['int', 'polyN', '5', []],
        ['double', 'polySigma', '1.1', []],
        ['int', 'flags', '0', []]],
    'Ptr<FarnebackOpticalFlow>']
ok: FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>

--- Incoming ---
['class cv.VariationalRefinement', ': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.VariationalRefinement : DenseOpticalFlow, name: VariationalRefinement, base: DenseOpticalFlow

--- Incoming ---
[   'cv.VariationalRefinement.calcUV',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'I0', '', []],
        ['Mat', 'I1', '', []],
        ['Mat', 'flow_u', '', ['/IO']],
        ['Mat', 'flow_v', '', ['/IO']]],
    'void']
ok: FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>

--- Incoming ---
[   'cv.VariationalRefinement.getFixedPointIterations',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.VariationalRefinement.getFixedPointIterations []>

--- Incoming ---
[   'cv.VariationalRefinement.setFixedPointIterations',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>

--- Incoming ---
[   'cv.VariationalRefinement.getSorIterations',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.VariationalRefinement.getSorIterations []>

--- Incoming ---
[   'cv.VariationalRefinement.setSorIterations',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>

--- Incoming ---
['cv.VariationalRefinement.getOmega', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.VariationalRefinement.getOmega []>

--- Incoming ---
[   'cv.VariationalRefinement.setOmega',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>

--- Incoming ---
['cv.VariationalRefinement.getAlpha', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.VariationalRefinement.getAlpha []>

--- Incoming ---
[   'cv.VariationalRefinement.setAlpha',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>

--- Incoming ---
['cv.VariationalRefinement.getDelta', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.VariationalRefinement.getDelta []>

--- Incoming ---
[   'cv.VariationalRefinement.setDelta',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>

--- Incoming ---
['cv.VariationalRefinement.getGamma', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.VariationalRefinement.getGamma []>

--- Incoming ---
[   'cv.VariationalRefinement.setGamma',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>

--- Incoming ---
[   'cv.VariationalRefinement.create',
    'Ptr_VariationalRefinement',
    ['/S'],
    [],
    'Ptr<VariationalRefinement>']
ok: FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>

--- Incoming ---
['class cv.DISOpticalFlow', ': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.DISOpticalFlow : DenseOpticalFlow, name: DISOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   'enum cv.DISOpticalFlow.<unnamed>',
    '',
    [],
    [   ['const cv.DISOpticalFlow.PRESET_ULTRAFAST', '0', [], [], None, ''],
        ['const cv.DISOpticalFlow.PRESET_FAST', '1', [], [], None, ''],
        ['const cv.DISOpticalFlow.PRESET_MEDIUM', '2', [], [], None, '']],
    None]
ok: CONST PRESET_ULTRAFAST=0
ok: CONST PRESET_FAST=1
ok: CONST PRESET_MEDIUM=2

--- Incoming ---
['cv.DISOpticalFlow.getFinestScale', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.DISOpticalFlow.getFinestScale []>

--- Incoming ---
[   'cv.DISOpticalFlow.setFinestScale',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>

--- Incoming ---
['cv.DISOpticalFlow.getPatchSize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchSize []>

--- Incoming ---
[   'cv.DISOpticalFlow.setPatchSize',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>

--- Incoming ---
['cv.DISOpticalFlow.getPatchStride', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchStride []>

--- Incoming ---
[   'cv.DISOpticalFlow.setPatchStride',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getGradientDescentIterations',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>

--- Incoming ---
[   'cv.DISOpticalFlow.setGradientDescentIterations',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getVariationalRefinementIterations',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>

--- Incoming ---
[   'cv.DISOpticalFlow.setVariationalRefinementIterations',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getVariationalRefinementAlpha',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>

--- Incoming ---
[   'cv.DISOpticalFlow.setVariationalRefinementAlpha',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getVariationalRefinementDelta',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>

--- Incoming ---
[   'cv.DISOpticalFlow.setVariationalRefinementDelta',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getVariationalRefinementGamma',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>

--- Incoming ---
[   'cv.DISOpticalFlow.setVariationalRefinementGamma',
    'void',
    ['/V', '/PV'],
    [['float', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getUseMeanNormalization',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>

--- Incoming ---
[   'cv.DISOpticalFlow.setUseMeanNormalization',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.getUseSpatialPropagation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>

--- Incoming ---
[   'cv.DISOpticalFlow.setUseSpatialPropagation',
    'void',
    ['/V', '/PV'],
    [['bool', 'val', '', []]],
    'void']
ok: FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>

--- Incoming ---
[   'cv.DISOpticalFlow.create',
    'Ptr_DISOpticalFlow',
    ['/S'],
    [['int', 'preset', 'DISOpticalFlow::PRESET_FAST', []]],
    'Ptr<DISOpticalFlow>']
ok: FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>

--- Incoming ---
['class cv.SparsePyrLKOpticalFlow', ': cv::SparseOpticalFlow', [], [], None]
ok: class CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow, name: SparsePyrLKOpticalFlow, base: SparseOpticalFlow

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.getWinSize',
    'Size',
    ['/C', '/V', '/PV'],
    [],
    'Size']
ok: FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.setWinSize',
    'void',
    ['/V', '/PV'],
    [['Size', 'winSize', '', []]],
    'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>

--- Incoming ---
['cv.SparsePyrLKOpticalFlow.getMaxLevel', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.setMaxLevel',
    'void',
    ['/V', '/PV'],
    [['int', 'maxLevel', '', []]],
    'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.getTermCriteria',
    'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    'TermCriteria']
ok: FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.setTermCriteria',
    'void',
    ['/V', '/PV'],
    [['TermCriteria', 'crit', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>

--- Incoming ---
['cv.SparsePyrLKOpticalFlow.getFlags', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.setFlags',
    'void',
    ['/V', '/PV'],
    [['int', 'flags', '', []]],
    'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.getMinEigThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.setMinEigThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'minEigThreshold', '', []]],
    'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>

--- Incoming ---
[   'cv.SparsePyrLKOpticalFlow.create',
    'Ptr_SparsePyrLKOpticalFlow',
    ['/S'],
    [   ['Size', 'winSize', 'Size(21, 21)', []],
        ['int', 'maxLevel', '3', []],
        [   'TermCriteria',
            'crit',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        ['int', 'flags', '0', []],
        ['double', 'minEigThreshold', '1e-4', []]],
    'Ptr<SparsePyrLKOpticalFlow>']
ok: FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
['class cv.Tracker', '', [], [], None]
ok: class CLASS cv::.Tracker : , name: Tracker, base: 

--- Incoming ---
[   'cv.Tracker.init',
    'void',
    ['/V', '/PV'],
    [['Mat', 'image', '', []], ['Rect', 'boundingBox', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.Tracker.init [ARG Mat image=, ARG Rect boundingBox=]>

--- Incoming ---
[   'cv.Tracker.update',
    'bool',
    ['/V', '/PV'],
    [['Mat', 'image', '', []], ['Rect', 'boundingBox', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect boundingBox=]>

--- Incoming ---
['class cv.TrackerMIL', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerMIL : Tracker, name: TrackerMIL, base: Tracker

--- Incoming ---
[   'struct cv.TrackerMIL.Params',
    '',
    ['/Simple'],
    [   ['float', 'samplerInitInRadius', '', ['/RW']],
        ['int', 'samplerInitMaxNegNum', '', ['/RW']],
        ['float', 'samplerSearchWinSize', '', ['/RW']],
        ['float', 'samplerTrackInRadius', '', ['/RW']],
        ['int', 'samplerTrackMaxPosNum', '', ['/RW']],
        ['int', 'samplerTrackMaxNegNum', '', ['/RW']],
        ['int', 'featureSetNumFeatures', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerMIL.TrackerMIL_Params : , name: TrackerMIL_Params, base: 

--- Incoming ---
['cv.TrackerMIL.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerMIL.Params.TrackerMIL_Params []>

--- Incoming ---
[   'cv.TrackerMIL.create',
    'Ptr_TrackerMIL',
    ['/S'],
    [   [   'TrackerMIL_Params',
            'parameters',
            'TrackerMIL::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerMIL>']
ok: FUNC <Ptr_TrackerMIL cv.TrackerMIL.create [ARG TrackerMIL_Params parameters=TrackerMIL::Params()]>

--- Incoming ---
['class cv.TrackerGOTURN', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerGOTURN : Tracker, name: TrackerGOTURN, base: Tracker

--- Incoming ---
[   'struct cv.TrackerGOTURN.Params',
    '',
    ['/Simple'],
    [['string', 'modelTxt', '', ['/RW']], ['string', 'modelBin', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerGOTURN.TrackerGOTURN_Params : , name: TrackerGOTURN_Params, base: 

--- Incoming ---
['cv.TrackerGOTURN.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerGOTURN.Params.TrackerGOTURN_Params []>

--- Incoming ---
[   'cv.TrackerGOTURN.create',
    'Ptr_TrackerGOTURN',
    ['/S'],
    [   [   'TrackerGOTURN_Params',
            'parameters',
            'TrackerGOTURN::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerGOTURN>']
ok: FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create [ARG TrackerGOTURN_Params parameters=TrackerGOTURN::Params()]>

--- Incoming ---
['class cv.TrackerDaSiamRPN', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerDaSiamRPN : Tracker, name: TrackerDaSiamRPN, base: Tracker

--- Incoming ---
[   'struct cv.TrackerDaSiamRPN.Params',
    '',
    ['/Simple'],
    [   ['string', 'model', '', ['/RW']],
        ['string', 'kernel_cls1', '', ['/RW']],
        ['string', 'kernel_r1', '', ['/RW']],
        ['int', 'backend', '', ['/RW']],
        ['int', 'target', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerDaSiamRPN.TrackerDaSiamRPN_Params : , name: TrackerDaSiamRPN_Params, base: 

--- Incoming ---
['cv.TrackerDaSiamRPN.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerDaSiamRPN.Params.TrackerDaSiamRPN_Params []>

--- Incoming ---
[   'cv.TrackerDaSiamRPN.create',
    'Ptr_TrackerDaSiamRPN',
    ['/S'],
    [   [   'TrackerDaSiamRPN_Params',
            'parameters',
            'TrackerDaSiamRPN::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerDaSiamRPN>']
ok: FUNC <Ptr_TrackerDaSiamRPN cv.TrackerDaSiamRPN.create [ARG TrackerDaSiamRPN_Params parameters=TrackerDaSiamRPN::Params()]>

--- Incoming ---
['cv.TrackerDaSiamRPN.getTrackingScore', 'float', ['/V', '/PV'], [], 'float']
ok: FUNC <float cv.TrackerDaSiamRPN.getTrackingScore []>

--- Incoming ---
['class cv.TrackerNano', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerNano : Tracker, name: TrackerNano, base: Tracker

--- Incoming ---
[   'struct cv.TrackerNano.Params',
    '',
    ['/Simple'],
    [   ['string', 'backbone', '', ['/RW']],
        ['string', 'neckhead', '', ['/RW']],
        ['int', 'backend', '', ['/RW']],
        ['int', 'target', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerNano.TrackerNano_Params : , name: TrackerNano_Params, base: 

--- Incoming ---
['cv.TrackerNano.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerNano.Params.TrackerNano_Params []>

--- Incoming ---
[   'cv.TrackerNano.create',
    'Ptr_TrackerNano',
    ['/S'],
    [   [   'TrackerNano_Params',
            'parameters',
            'TrackerNano::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerNano>']
ok: FUNC <Ptr_TrackerNano cv.TrackerNano.create [ARG TrackerNano_Params parameters=TrackerNano::Params()]>

--- Incoming ---
['cv.TrackerNano.getTrackingScore', 'float', ['/V', '/PV'], [], 'float']
ok: FUNC <float cv.TrackerNano.getTrackingScore []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/modules/video/include/opencv2/video/detail/tracking.detail.hpp =====
Namespaces: ['cv', 'cv.detail']

--- Incoming ---
[   'enum cv.detail.TrackerSamplerCSC.MODE',
    '',
    [],
    [   [   'const cv.detail.TrackerSamplerCSC.MODE_INIT_POS',
            '1',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCSC.MODE_INIT_NEG',
            '2',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCSC.MODE_TRACK_POS',
            '3',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCSC.MODE_TRACK_NEG',
            '4',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCSC.MODE_DETECT',
            '5',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST MODE_INIT_POS=1
ok: CONST TrackerSamplerCSC_MODE_INIT_POS=1
class not found: CONST MODE_INIT_NEG=2
ok: CONST TrackerSamplerCSC_MODE_INIT_NEG=2
class not found: CONST MODE_TRACK_POS=3
ok: CONST TrackerSamplerCSC_MODE_TRACK_POS=3
class not found: CONST MODE_TRACK_NEG=4
ok: CONST TrackerSamplerCSC_MODE_TRACK_NEG=4
class not found: CONST MODE_DETECT=5
ok: CONST TrackerSamplerCSC_MODE_DETECT=5


===== Generating... =====
CLASS cv::.BackgroundSubtractor : Algorithm
FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor
FUNC <int cv.BackgroundSubtractorKNN.getHistory []>
java: int getHistory()
FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>
java: int getNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>
java: void setNSamples(int _nN)
FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>
java: double getDist2Threshold()
FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>
java: void setDist2Threshold(double _dist2Threshold)
FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>
java: int getkNNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>
java: void setkNNSamples(int _nkNN)
FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor
FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>
java: int getHistory()
FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>
java: int getNMixtures()
FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>
java: void setNMixtures(int nmixtures)
FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>
java: void setBackgroundRatio(double ratio)
FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>
java: double getVarThreshold()
FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>
java: void setVarThreshold(double varThreshold)
FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>
java: double getVarThresholdGen()
FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>
java: void setVarThresholdGen(double varThresholdGen)
FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>
java: double getVarInit()
FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>
java: void setVarInit(double varInit)
FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>
java: double getVarMin()
FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>
java: void setVarMin(double varMin)
FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>
java: double getVarMax()
FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>
java: void setVarMax(double varMax)
FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>
java: double getComplexityReductionThreshold()
FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>
java: void setComplexityReductionThreshold(double ct)
FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
CLASS cv::.DISOpticalFlow : DenseOpticalFlow
[CONST PRESET_ULTRAFAST=0, CONST PRESET_FAST=1, CONST PRESET_MEDIUM=2]
FUNC <int cv.DISOpticalFlow.getFinestScale []>
java: int getFinestScale()
FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>
java: void setFinestScale(int val)
FUNC <int cv.DISOpticalFlow.getPatchSize []>
java: int getPatchSize()
FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>
java: void setPatchSize(int val)
FUNC <int cv.DISOpticalFlow.getPatchStride []>
java: int getPatchStride()
FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>
java: void setPatchStride(int val)
FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>
java: int getGradientDescentIterations()
FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>
java: void setGradientDescentIterations(int val)
FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>
java: int getVariationalRefinementIterations()
FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>
java: void setVariationalRefinementIterations(int val)
FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>
java: float getVariationalRefinementAlpha()
FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>
java: void setVariationalRefinementAlpha(float val)
FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>
java: float getVariationalRefinementDelta()
FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>
java: void setVariationalRefinementDelta(float val)
FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>
java: float getVariationalRefinementGamma()
FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>
java: void setVariationalRefinementGamma(float val)
FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>
java: boolean getUseMeanNormalization()
FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>
java: void setUseMeanNormalization(boolean val)
FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>
java: boolean getUseSpatialPropagation()
FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>
java: void setUseSpatialPropagation(boolean val)
FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>
java: DISOpticalFlow create(int preset)
java: DISOpticalFlow create()
CLASS cv::.DenseOpticalFlow : Algorithm
FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>
java: void calc(Mat I0, Mat I1, Mat flow)
FUNC <void cv.DenseOpticalFlow.collectGarbage []>
java: void collectGarbage()
CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow
FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>
java: int getNumLevels()
FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>
java: void setNumLevels(int numLevels)
FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>
java: double getPyrScale()
FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>
java: void setPyrScale(double pyrScale)
FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>
java: boolean getFastPyramids()
FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>
java: void setFastPyramids(boolean fastPyramids)
FUNC <int cv.FarnebackOpticalFlow.getWinSize []>
java: int getWinSize()
FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>
java: void setWinSize(int winSize)
FUNC <int cv.FarnebackOpticalFlow.getNumIters []>
java: int getNumIters()
FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>
java: void setNumIters(int numIters)
FUNC <int cv.FarnebackOpticalFlow.getPolyN []>
java: int getPolyN()
FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>
java: void setPolyN(int polyN)
FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>
java: double getPolySigma()
FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>
java: void setPolySigma(double polySigma)
FUNC <int cv.FarnebackOpticalFlow.getFlags []>
java: int getFlags()
FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma, int flags)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale)
java: FarnebackOpticalFlow create(int numLevels)
java: FarnebackOpticalFlow create()
CLASS cv::.KalmanFilter : 
FUNC < cv.KalmanFilter.KalmanFilter []>
java:  KalmanFilter()
FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams)
java:  KalmanFilter(int dynamParams, int measureParams)
FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>
java: Mat predict(Mat control)
java: Mat predict()
FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>
java: Mat correct(Mat measurement)
FUNC <Mat cv.KalmanFilter.get_statePre []>
java: Mat get_statePre()
FUNC <void cv.KalmanFilter.set_statePre [ARG Mat statePre=]>
java: void set_statePre(Mat statePre)
FUNC <Mat cv.KalmanFilter.get_statePost []>
java: Mat get_statePost()
FUNC <void cv.KalmanFilter.set_statePost [ARG Mat statePost=]>
java: void set_statePost(Mat statePost)
FUNC <Mat cv.KalmanFilter.get_transitionMatrix []>
java: Mat get_transitionMatrix()
FUNC <void cv.KalmanFilter.set_transitionMatrix [ARG Mat transitionMatrix=]>
java: void set_transitionMatrix(Mat transitionMatrix)
FUNC <Mat cv.KalmanFilter.get_controlMatrix []>
java: Mat get_controlMatrix()
FUNC <void cv.KalmanFilter.set_controlMatrix [ARG Mat controlMatrix=]>
java: void set_controlMatrix(Mat controlMatrix)
FUNC <Mat cv.KalmanFilter.get_measurementMatrix []>
java: Mat get_measurementMatrix()
FUNC <void cv.KalmanFilter.set_measurementMatrix [ARG Mat measurementMatrix=]>
java: void set_measurementMatrix(Mat measurementMatrix)
FUNC <Mat cv.KalmanFilter.get_processNoiseCov []>
java: Mat get_processNoiseCov()
FUNC <void cv.KalmanFilter.set_processNoiseCov [ARG Mat processNoiseCov=]>
java: void set_processNoiseCov(Mat processNoiseCov)
FUNC <Mat cv.KalmanFilter.get_measurementNoiseCov []>
java: Mat get_measurementNoiseCov()
FUNC <void cv.KalmanFilter.set_measurementNoiseCov [ARG Mat measurementNoiseCov=]>
java: void set_measurementNoiseCov(Mat measurementNoiseCov)
FUNC <Mat cv.KalmanFilter.get_errorCovPre []>
java: Mat get_errorCovPre()
FUNC <void cv.KalmanFilter.set_errorCovPre [ARG Mat errorCovPre=]>
java: void set_errorCovPre(Mat errorCovPre)
FUNC <Mat cv.KalmanFilter.get_gain []>
java: Mat get_gain()
FUNC <void cv.KalmanFilter.set_gain [ARG Mat gain=]>
java: void set_gain(Mat gain)
FUNC <Mat cv.KalmanFilter.get_errorCovPost []>
java: Mat get_errorCovPost()
FUNC <void cv.KalmanFilter.set_errorCovPost [ARG Mat errorCovPost=]>
java: void set_errorCovPost(Mat errorCovPost)
CLASS cv::.SparseOpticalFlow : Algorithm
FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status, Mat err)
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status)
CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow
FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>
java: Size getWinSize()
FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>
java: void setWinSize(Size winSize)
FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>
java: int getMaxLevel()
FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>
java: void setMaxLevel(int maxLevel)
FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>
java: void setTermCriteria(TermCriteria crit)
FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>
java: int getFlags()
FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>
java: double getMinEigThreshold()
FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>
java: void setMinEigThreshold(double minEigThreshold)
FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags, double minEigThreshold)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel)
java: SparsePyrLKOpticalFlow create(Size winSize)
java: SparsePyrLKOpticalFlow create()
CLASS cv::.Tracker : 
FUNC <void cv.Tracker.init [ARG Mat image=, ARG Rect boundingBox=]>
java: void init(Mat image, Rect boundingBox)
FUNC <bool cv.Tracker.update [ARG Mat image=, ARG Rect boundingBox=]>
java: boolean update(Mat image, Rect boundingBox)
CLASS cv::.TrackerDaSiamRPN : Tracker
FUNC <Ptr_TrackerDaSiamRPN cv.TrackerDaSiamRPN.create [ARG TrackerDaSiamRPN_Params parameters=TrackerDaSiamRPN::Params()]>
java: TrackerDaSiamRPN create(TrackerDaSiamRPN_Params parameters)
java: TrackerDaSiamRPN create()
FUNC <float cv.TrackerDaSiamRPN.getTrackingScore []>
java: float getTrackingScore()
CLASS cv::TrackerDaSiamRPN.TrackerDaSiamRPN_Params : 
FUNC < cv.TrackerDaSiamRPN.Params.TrackerDaSiamRPN_Params []>
java:  TrackerDaSiamRPN_Params()
FUNC <string cv.TrackerDaSiamRPN.Params.get_model []>
java: String get_model()
FUNC <void cv.TrackerDaSiamRPN.Params.set_model [ARG string model=]>
java: void set_model(String model)
FUNC <string cv.TrackerDaSiamRPN.Params.get_kernel_cls1 []>
java: String get_kernel_cls1()
FUNC <void cv.TrackerDaSiamRPN.Params.set_kernel_cls1 [ARG string kernel_cls1=]>
java: void set_kernel_cls1(String kernel_cls1)
FUNC <string cv.TrackerDaSiamRPN.Params.get_kernel_r1 []>
java: String get_kernel_r1()
FUNC <void cv.TrackerDaSiamRPN.Params.set_kernel_r1 [ARG string kernel_r1=]>
java: void set_kernel_r1(String kernel_r1)
FUNC <int cv.TrackerDaSiamRPN.Params.get_backend []>
java: int get_backend()
FUNC <void cv.TrackerDaSiamRPN.Params.set_backend [ARG int backend=]>
java: void set_backend(int backend)
FUNC <int cv.TrackerDaSiamRPN.Params.get_target []>
java: int get_target()
FUNC <void cv.TrackerDaSiamRPN.Params.set_target [ARG int target=]>
java: void set_target(int target)
CLASS cv::.TrackerGOTURN : Tracker
FUNC <Ptr_TrackerGOTURN cv.TrackerGOTURN.create [ARG TrackerGOTURN_Params parameters=TrackerGOTURN::Params()]>
java: TrackerGOTURN create(TrackerGOTURN_Params parameters)
java: TrackerGOTURN create()
CLASS cv::TrackerGOTURN.TrackerGOTURN_Params : 
FUNC < cv.TrackerGOTURN.Params.TrackerGOTURN_Params []>
java:  TrackerGOTURN_Params()
FUNC <string cv.TrackerGOTURN.Params.get_modelTxt []>
java: String get_modelTxt()
FUNC <void cv.TrackerGOTURN.Params.set_modelTxt [ARG string modelTxt=]>
java: void set_modelTxt(String modelTxt)
FUNC <string cv.TrackerGOTURN.Params.get_modelBin []>
java: String get_modelBin()
FUNC <void cv.TrackerGOTURN.Params.set_modelBin [ARG string modelBin=]>
java: void set_modelBin(String modelBin)
CLASS cv::.TrackerMIL : Tracker
FUNC <Ptr_TrackerMIL cv.TrackerMIL.create [ARG TrackerMIL_Params parameters=TrackerMIL::Params()]>
java: TrackerMIL create(TrackerMIL_Params parameters)
java: TrackerMIL create()
CLASS cv::TrackerMIL.TrackerMIL_Params : 
FUNC < cv.TrackerMIL.Params.TrackerMIL_Params []>
java:  TrackerMIL_Params()
FUNC <float cv.TrackerMIL.Params.get_samplerInitInRadius []>
java: float get_samplerInitInRadius()
FUNC <void cv.TrackerMIL.Params.set_samplerInitInRadius [ARG float samplerInitInRadius=]>
java: void set_samplerInitInRadius(float samplerInitInRadius)
FUNC <int cv.TrackerMIL.Params.get_samplerInitMaxNegNum []>
java: int get_samplerInitMaxNegNum()
FUNC <void cv.TrackerMIL.Params.set_samplerInitMaxNegNum [ARG int samplerInitMaxNegNum=]>
java: void set_samplerInitMaxNegNum(int samplerInitMaxNegNum)
FUNC <float cv.TrackerMIL.Params.get_samplerSearchWinSize []>
java: float get_samplerSearchWinSize()
FUNC <void cv.TrackerMIL.Params.set_samplerSearchWinSize [ARG float samplerSearchWinSize=]>
java: void set_samplerSearchWinSize(float samplerSearchWinSize)
FUNC <float cv.TrackerMIL.Params.get_samplerTrackInRadius []>
java: float get_samplerTrackInRadius()
FUNC <void cv.TrackerMIL.Params.set_samplerTrackInRadius [ARG float samplerTrackInRadius=]>
java: void set_samplerTrackInRadius(float samplerTrackInRadius)
FUNC <int cv.TrackerMIL.Params.get_samplerTrackMaxPosNum []>
java: int get_samplerTrackMaxPosNum()
FUNC <void cv.TrackerMIL.Params.set_samplerTrackMaxPosNum [ARG int samplerTrackMaxPosNum=]>
java: void set_samplerTrackMaxPosNum(int samplerTrackMaxPosNum)
FUNC <int cv.TrackerMIL.Params.get_samplerTrackMaxNegNum []>
java: int get_samplerTrackMaxNegNum()
FUNC <void cv.TrackerMIL.Params.set_samplerTrackMaxNegNum [ARG int samplerTrackMaxNegNum=]>
java: void set_samplerTrackMaxNegNum(int samplerTrackMaxNegNum)
FUNC <int cv.TrackerMIL.Params.get_featureSetNumFeatures []>
java: int get_featureSetNumFeatures()
FUNC <void cv.TrackerMIL.Params.set_featureSetNumFeatures [ARG int featureSetNumFeatures=]>
java: void set_featureSetNumFeatures(int featureSetNumFeatures)
CLASS cv::.TrackerNano : Tracker
FUNC <Ptr_TrackerNano cv.TrackerNano.create [ARG TrackerNano_Params parameters=TrackerNano::Params()]>
java: TrackerNano create(TrackerNano_Params parameters)
java: TrackerNano create()
FUNC <float cv.TrackerNano.getTrackingScore []>
java: float getTrackingScore()
CLASS cv::TrackerNano.TrackerNano_Params : 
FUNC < cv.TrackerNano.Params.TrackerNano_Params []>
java:  TrackerNano_Params()
FUNC <string cv.TrackerNano.Params.get_backbone []>
java: String get_backbone()
FUNC <void cv.TrackerNano.Params.set_backbone [ARG string backbone=]>
java: void set_backbone(String backbone)
FUNC <string cv.TrackerNano.Params.get_neckhead []>
java: String get_neckhead()
FUNC <void cv.TrackerNano.Params.set_neckhead [ARG string neckhead=]>
java: void set_neckhead(String neckhead)
FUNC <int cv.TrackerNano.Params.get_backend []>
java: int get_backend()
FUNC <void cv.TrackerNano.Params.set_backend [ARG int backend=]>
java: void set_backend(int backend)
FUNC <int cv.TrackerNano.Params.get_target []>
java: int get_target()
FUNC <void cv.TrackerNano.Params.set_target [ARG int target=]>
java: void set_target(int target)
CLASS cv::.VariationalRefinement : DenseOpticalFlow
FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>
java: void calcUV(Mat I0, Mat I1, Mat flow_u, Mat flow_v)
FUNC <int cv.VariationalRefinement.getFixedPointIterations []>
java: int getFixedPointIterations()
FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>
java: void setFixedPointIterations(int val)
FUNC <int cv.VariationalRefinement.getSorIterations []>
java: int getSorIterations()
FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>
java: void setSorIterations(int val)
FUNC <float cv.VariationalRefinement.getOmega []>
java: float getOmega()
FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>
java: void setOmega(float val)
FUNC <float cv.VariationalRefinement.getAlpha []>
java: float getAlpha()
FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>
java: void setAlpha(float val)
FUNC <float cv.VariationalRefinement.getDelta []>
java: float getDelta()
FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>
java: void setDelta(float val)
FUNC <float cv.VariationalRefinement.getGamma []>
java: float getGamma()
FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>
java: void setGamma(float val)
FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>
java: VariationalRefinement create()
CLASS cv::.Video : 
[CONST CV_LKFLOW_INITIAL_GUESSES=4(manual), CONST CV_LKFLOW_GET_MIN_EIGENVALS=8(manual)]
[CONST OPTFLOW_USE_INITIAL_FLOW=4, CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8, CONST OPTFLOW_FARNEBACK_GAUSSIAN=256, CONST MOTION_TRANSLATION=0, CONST MOTION_EUCLIDEAN=1, CONST MOTION_AFFINE=2, CONST MOTION_HOMOGRAPHY=3]
[CONST TrackerSamplerCSC_MODE_INIT_POS=1, CONST TrackerSamplerCSC_MODE_INIT_NEG=2, CONST TrackerSamplerCSC_MODE_TRACK_POS=3, CONST TrackerSamplerCSC_MODE_TRACK_NEG=4, CONST TrackerSamplerCSC_MODE_DETECT=5]
FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold, boolean detectShadows)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2()
FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold, boolean detectShadows)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN()
FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: RotatedRect CamShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: int meanShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder, boolean tryReuseInputImage)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel)
FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err)
FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>
java: void calcOpticalFlowFarneback(Mat prev, Mat next, Mat flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)
FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>
java: double computeECC(Mat templateImage, Mat inputImage, Mat inputMask)
java: double computeECC(Mat templateImage, Mat inputImage)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask, int gaussFiltSize)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=MOTION_AFFINE, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001), ARG Mat inputMask=Mat()]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType)
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix)
FUNC <Mat cv..readOpticalFlow [ARG String path=]>
java: Mat readOpticalFlow(String path)
FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>
java: boolean writeOpticalFlow(String path, Mat flow)

=== MODULE: wechat_qrcode (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/wechat_qrcode) ===


Files (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/wechat_qrcode/include/opencv2/wechat_qrcode.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Wechat_qrcode : , name: Wechat_qrcode, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/wechat_qrcode/include/opencv2/wechat_qrcode.hpp =====
Namespaces: ['cv', 'cv.wechat_qrcode']

--- Incoming ---
['class cv.wechat_qrcode.WeChatQRCode', '', [], [], None]
ok: class CLASS cv.wechat_qrcode::.WeChatQRCode : , name: WeChatQRCode, base: 

--- Incoming ---
[   'cv.wechat_qrcode.WeChatQRCode.WeChatQRCode',
    '',
    [],
    [   ['string', 'detector_prototxt_path', '""', ['/C', '/Ref']],
        ['string', 'detector_caffe_model_path', '""', ['/C', '/Ref']],
        ['string', 'super_resolution_prototxt_path', '""', ['/C', '/Ref']],
        ['string', 'super_resolution_caffe_model_path', '""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.wechat_qrcode.WeChatQRCode.WeChatQRCode [ARG string detector_prototxt_path="", ARG string detector_caffe_model_path="", ARG string super_resolution_prototxt_path="", ARG string super_resolution_caffe_model_path=""]>

--- Incoming ---
[   'cv.wechat_qrcode.WeChatQRCode.detectAndDecode',
    'vector_string',
    [],
    [['Mat', 'img', '', []], ['vector_Mat', 'points', 'vector_Mat()', ['/O']]],
    'std::vector<std::string>']
ok: FUNC <vector_string cv.wechat_qrcode.WeChatQRCode.detectAndDecode [ARG Mat img=, ARG vector_Mat points=vector_Mat()]>

--- Incoming ---
[   'cv.wechat_qrcode.WeChatQRCode.setScaleFactor',
    'void',
    [],
    [['float', '_scalingFactor', '', []]],
    'void']
ok: FUNC <void cv.wechat_qrcode.WeChatQRCode.setScaleFactor [ARG float _scalingFactor=]>

--- Incoming ---
['cv.wechat_qrcode.WeChatQRCode.getScaleFactor', 'float', [], [], 'float']
ok: FUNC <float cv.wechat_qrcode.WeChatQRCode.getScaleFactor []>


===== Generating... =====
CLASS cv::.Wechat_qrcode : 
CLASS cv.wechat_qrcode::.WeChatQRCode : 
FUNC < cv.wechat_qrcode.WeChatQRCode.WeChatQRCode [ARG string detector_prototxt_path="", ARG string detector_caffe_model_path="", ARG string super_resolution_prototxt_path="", ARG string super_resolution_caffe_model_path=""]>
java:  WeChatQRCode(String detector_prototxt_path, String detector_caffe_model_path, String super_resolution_prototxt_path, String super_resolution_caffe_model_path)
java:  WeChatQRCode(String detector_prototxt_path, String detector_caffe_model_path, String super_resolution_prototxt_path)
java:  WeChatQRCode(String detector_prototxt_path, String detector_caffe_model_path)
java:  WeChatQRCode(String detector_prototxt_path)
java:  WeChatQRCode()
FUNC <vector_string cv.wechat_qrcode.WeChatQRCode.detectAndDecode [ARG Mat img=, ARG vector_Mat points=vector_Mat()]>
java: List<String> detectAndDecode(Mat img, List<Mat> points)
java: List<String> detectAndDecode(Mat img)
FUNC <void cv.wechat_qrcode.WeChatQRCode.setScaleFactor [ARG float _scalingFactor=]>
java: void setScaleFactor(float _scalingFactor)
FUNC <float cv.wechat_qrcode.WeChatQRCode.getScaleFactor []>
java: float getScaleFactor()

=== MODULE: xfeatures2d (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d) ===


Files (3):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/nonfree.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/cuda.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Xfeatures2d : , name: Xfeatures2d, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp =====
Namespaces: ['cv', 'cv.xfeatures2d']

--- Incoming ---
['class cv.xfeatures2d.FREAK', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.FREAK : Feature2D, name: FREAK, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.FREAK.create',
    'Ptr_FREAK',
    ['/S'],
    [   ['bool', 'orientationNormalized', 'true', []],
        ['bool', 'scaleNormalized', 'true', []],
        ['float', 'patternScale', '22.0f', []],
        ['int', 'nOctaves', '4', []],
        ['vector_int', 'selectedPairs', 'std::vector<int>()', ['/C', '/Ref']]],
    'Ptr<FREAK>']
ok: FUNC <Ptr_FREAK cv.xfeatures2d.FREAK.create [ARG bool orientationNormalized=true, ARG bool scaleNormalized=true, ARG float patternScale=22.0f, ARG int nOctaves=4, ARG vector_int selectedPairs=std::vector<int>()]>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.setOrientationNormalized',
    'void',
    ['/V', '/PV'],
    [['bool', 'orientationNormalized', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.FREAK.setOrientationNormalized [ARG bool orientationNormalized=]>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.getOrientationNormalized',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.FREAK.getOrientationNormalized []>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.setScaleNormalized',
    'void',
    ['/V', '/PV'],
    [['bool', 'scaleNormalized', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.FREAK.setScaleNormalized [ARG bool scaleNormalized=]>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.getScaleNormalized',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.FREAK.getScaleNormalized []>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.setPatternScale',
    'void',
    ['/V', '/PV'],
    [['double', 'patternScale', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.FREAK.setPatternScale [ARG double patternScale=]>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.getPatternScale',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.xfeatures2d.FREAK.getPatternScale []>

--- Incoming ---
[   'cv.xfeatures2d.FREAK.setNOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'nOctaves', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.FREAK.setNOctaves [ARG int nOctaves=]>

--- Incoming ---
['cv.xfeatures2d.FREAK.getNOctaves', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.FREAK.getNOctaves []>

--- Incoming ---
['cv.xfeatures2d.FREAK.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.FREAK.getDefaultName []>

--- Incoming ---
[   'class cv.xfeatures2d.StarDetector',
    ': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.StarDetector : Feature2D, name: StarDetector, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.create',
    'Ptr_StarDetector',
    ['/S'],
    [   ['int', 'maxSize', '45', []],
        ['int', 'responseThreshold', '30', []],
        ['int', 'lineThresholdProjected', '10', []],
        ['int', 'lineThresholdBinarized', '8', []],
        ['int', 'suppressNonmaxSize', '5', []]],
    'Ptr<StarDetector>']
ok: FUNC <Ptr_StarDetector cv.xfeatures2d.StarDetector.create [ARG int maxSize=45, ARG int responseThreshold=30, ARG int lineThresholdProjected=10, ARG int lineThresholdBinarized=8, ARG int suppressNonmaxSize=5]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.setMaxSize',
    'void',
    ['/V', '/PV'],
    [['int', '_maxSize', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.StarDetector.setMaxSize [ARG int _maxSize=]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.getMaxSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.StarDetector.getMaxSize []>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.setResponseThreshold',
    'void',
    ['/V', '/PV'],
    [['int', '_responseThreshold', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.StarDetector.setResponseThreshold [ARG int _responseThreshold=]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.getResponseThreshold',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.StarDetector.getResponseThreshold []>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.setLineThresholdProjected',
    'void',
    ['/V', '/PV'],
    [['int', '_lineThresholdProjected', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.StarDetector.setLineThresholdProjected [ARG int _lineThresholdProjected=]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.getLineThresholdProjected',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.StarDetector.getLineThresholdProjected []>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.setLineThresholdBinarized',
    'void',
    ['/V', '/PV'],
    [['int', '_lineThresholdBinarized', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.StarDetector.setLineThresholdBinarized [ARG int _lineThresholdBinarized=]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.getLineThresholdBinarized',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.StarDetector.getLineThresholdBinarized []>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.setSuppressNonmaxSize',
    'void',
    ['/V', '/PV'],
    [['int', '_suppressNonmaxSize', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.StarDetector.setSuppressNonmaxSize [ARG int _suppressNonmaxSize=]>

--- Incoming ---
[   'cv.xfeatures2d.StarDetector.getSuppressNonmaxSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.StarDetector.getSuppressNonmaxSize []>

--- Incoming ---
['cv.xfeatures2d.StarDetector.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.StarDetector.getDefaultName []>

--- Incoming ---
[   'class cv.xfeatures2d.BriefDescriptorExtractor',
    ': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.BriefDescriptorExtractor : Feature2D, name: BriefDescriptorExtractor, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.create',
    'Ptr_BriefDescriptorExtractor',
    ['/S'],
    [['int', 'bytes', '32', []], ['bool', 'use_orientation', 'false', []]],
    'Ptr<BriefDescriptorExtractor>']
ok: FUNC <Ptr_BriefDescriptorExtractor cv.xfeatures2d.BriefDescriptorExtractor.create [ARG int bytes=32, ARG bool use_orientation=false]>

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.setDescriptorSize',
    'void',
    ['/V', '/PV'],
    [['int', 'bytes', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.BriefDescriptorExtractor.setDescriptorSize [ARG int bytes=]>

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.getDescriptorSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.BriefDescriptorExtractor.getDescriptorSize []>

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.setUseOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_orientation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.BriefDescriptorExtractor.setUseOrientation [ARG bool use_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.getUseOrientation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.BriefDescriptorExtractor.getUseOrientation []>

--- Incoming ---
[   'cv.xfeatures2d.BriefDescriptorExtractor.getDefaultName',
    'String',
    ['/C'],
    [],
    'String']
ok: FUNC <String cv.xfeatures2d.BriefDescriptorExtractor.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.LUCID', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.LUCID : Feature2D, name: LUCID, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.LUCID.create',
    'Ptr_LUCID',
    ['/S'],
    [['int', 'lucid_kernel', '1', ['/C']], ['int', 'blur_kernel', '2', ['/C']]],
    'Ptr<LUCID>']
ok: FUNC <Ptr_LUCID cv.xfeatures2d.LUCID.create [ARG int lucid_kernel=1, ARG int blur_kernel=2]>

--- Incoming ---
[   'cv.xfeatures2d.LUCID.setLucidKernel',
    'void',
    ['/V', '/PV'],
    [['int', 'lucid_kernel', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LUCID.setLucidKernel [ARG int lucid_kernel=]>

--- Incoming ---
['cv.xfeatures2d.LUCID.getLucidKernel', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.LUCID.getLucidKernel []>

--- Incoming ---
[   'cv.xfeatures2d.LUCID.setBlurKernel',
    'void',
    ['/V', '/PV'],
    [['int', 'blur_kernel', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LUCID.setBlurKernel [ARG int blur_kernel=]>

--- Incoming ---
['cv.xfeatures2d.LUCID.getBlurKernel', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.LUCID.getBlurKernel []>

--- Incoming ---
['cv.xfeatures2d.LUCID.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.LUCID.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.LATCH', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.LATCH : Feature2D, name: LATCH, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.LATCH.create',
    'Ptr_LATCH',
    ['/S'],
    [   ['int', 'bytes', '32', []],
        ['bool', 'rotationInvariance', 'true', []],
        ['int', 'half_ssd_size', '3', []],
        ['double', 'sigma', '2.0', []]],
    'Ptr<LATCH>']
ok: FUNC <Ptr_LATCH cv.xfeatures2d.LATCH.create [ARG int bytes=32, ARG bool rotationInvariance=true, ARG int half_ssd_size=3, ARG double sigma=2.0]>

--- Incoming ---
[   'cv.xfeatures2d.LATCH.setBytes',
    'void',
    ['/V', '/PV'],
    [['int', 'bytes', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LATCH.setBytes [ARG int bytes=]>

--- Incoming ---
['cv.xfeatures2d.LATCH.getBytes', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.LATCH.getBytes []>

--- Incoming ---
[   'cv.xfeatures2d.LATCH.setRotationInvariance',
    'void',
    ['/V', '/PV'],
    [['bool', 'rotationInvariance', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LATCH.setRotationInvariance [ARG bool rotationInvariance=]>

--- Incoming ---
[   'cv.xfeatures2d.LATCH.getRotationInvariance',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.LATCH.getRotationInvariance []>

--- Incoming ---
[   'cv.xfeatures2d.LATCH.setHalfSSDsize',
    'void',
    ['/V', '/PV'],
    [['int', 'half_ssd_size', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LATCH.setHalfSSDsize [ARG int half_ssd_size=]>

--- Incoming ---
['cv.xfeatures2d.LATCH.getHalfSSDsize', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.LATCH.getHalfSSDsize []>

--- Incoming ---
[   'cv.xfeatures2d.LATCH.setSigma',
    'void',
    ['/V', '/PV'],
    [['double', 'sigma', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.LATCH.setSigma [ARG double sigma=]>

--- Incoming ---
['cv.xfeatures2d.LATCH.getSigma', 'double', ['/C', '/V', '/PV'], [], 'double']
ok: FUNC <double cv.xfeatures2d.LATCH.getSigma []>

--- Incoming ---
['cv.xfeatures2d.LATCH.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.LATCH.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.BEBLID', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.BEBLID : Feature2D, name: BEBLID, base: Feature2D

--- Incoming ---
[   'enum cv.xfeatures2d.BEBLID.BeblidSize',
    '',
    [],
    [   ['const cv.xfeatures2d.BEBLID.SIZE_512_BITS', '100', [], [], None, ''],
        ['const cv.xfeatures2d.BEBLID.SIZE_256_BITS', '101', [], [], None, '']],
    None]
ok: CONST SIZE_512_BITS=100
ok: CONST SIZE_256_BITS=101

--- Incoming ---
[   'cv.xfeatures2d.BEBLID.create',
    'Ptr_BEBLID',
    ['/S'],
    [   ['float', 'scale_factor', '', []],
        ['int', 'n_bits', 'BEBLID::SIZE_512_BITS', []]],
    'Ptr<BEBLID>']
ok: FUNC <Ptr_BEBLID cv.xfeatures2d.BEBLID.create [ARG float scale_factor=, ARG int n_bits=BEBLID::SIZE_512_BITS]>

--- Incoming ---
[   'cv.xfeatures2d.BEBLID.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['float', 'scale_factor', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.BEBLID.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   'cv.xfeatures2d.BEBLID.getScaleFactor',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.BEBLID.getScaleFactor []>

--- Incoming ---
['cv.xfeatures2d.BEBLID.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.BEBLID.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.TEBLID', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.TEBLID : Feature2D, name: TEBLID, base: Feature2D

--- Incoming ---
[   'enum cv.xfeatures2d.TEBLID.TeblidSize',
    '',
    [],
    [   ['const cv.xfeatures2d.TEBLID.SIZE_256_BITS', '102', [], [], None, ''],
        ['const cv.xfeatures2d.TEBLID.SIZE_512_BITS', '103', [], [], None, '']],
    None]
ok: CONST SIZE_256_BITS=102
ok: CONST SIZE_512_BITS=103

--- Incoming ---
[   'cv.xfeatures2d.TEBLID.create',
    'Ptr_TEBLID',
    ['/S'],
    [   ['float', 'scale_factor', '', []],
        ['int', 'n_bits', 'TEBLID::SIZE_256_BITS', []]],
    'Ptr<TEBLID>']
ok: FUNC <Ptr_TEBLID cv.xfeatures2d.TEBLID.create [ARG float scale_factor=, ARG int n_bits=TEBLID::SIZE_256_BITS]>

--- Incoming ---
['cv.xfeatures2d.TEBLID.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.TEBLID.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.DAISY', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.DAISY : Feature2D, name: DAISY, base: Feature2D

--- Incoming ---
[   'enum cv.xfeatures2d.DAISY.NormalizationType',
    '',
    [],
    [   ['const cv.xfeatures2d.DAISY.NRM_NONE', '100', [], [], None, ''],
        ['const cv.xfeatures2d.DAISY.NRM_PARTIAL', '101', [], [], None, ''],
        ['const cv.xfeatures2d.DAISY.NRM_FULL', '102', [], [], None, ''],
        ['const cv.xfeatures2d.DAISY.NRM_SIFT', '103', [], [], None, '']],
    None]
ok: CONST NRM_NONE=100
ok: CONST NRM_PARTIAL=101
ok: CONST NRM_FULL=102
ok: CONST NRM_SIFT=103

--- Incoming ---
[   'cv.xfeatures2d.DAISY.create',
    'Ptr_DAISY',
    ['/S'],
    [   ['float', 'radius', '15', []],
        ['int', 'q_radius', '3', []],
        ['int', 'q_theta', '8', []],
        ['int', 'q_hist', '8', []],
        ['DAISY_NormalizationType', 'norm', 'DAISY::NRM_NONE', []],
        ['Mat', 'H', 'Mat()', []],
        ['bool', 'interpolation', 'true', []],
        ['bool', 'use_orientation', 'false', []]],
    'Ptr<DAISY>']
ok: FUNC <Ptr_DAISY cv.xfeatures2d.DAISY.create [ARG float radius=15, ARG int q_radius=3, ARG int q_theta=8, ARG int q_hist=8, ARG DAISY_NormalizationType norm=DAISY::NRM_NONE, ARG Mat H=Mat(), ARG bool interpolation=true, ARG bool use_orientation=false]>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setRadius',
    'void',
    ['/V', '/PV'],
    [['float', 'radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setRadius [ARG float radius=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getRadius', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xfeatures2d.DAISY.getRadius []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setQRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'q_radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setQRadius [ARG int q_radius=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getQRadius', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.DAISY.getQRadius []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setQTheta',
    'void',
    ['/V', '/PV'],
    [['int', 'q_theta', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setQTheta [ARG int q_theta=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getQTheta', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.DAISY.getQTheta []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setQHist',
    'void',
    ['/V', '/PV'],
    [['int', 'q_hist', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setQHist [ARG int q_hist=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getQHist', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.DAISY.getQHist []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setNorm',
    'void',
    ['/V', '/PV'],
    [['int', 'norm', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setNorm [ARG int norm=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getNorm', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.DAISY.getNorm []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setH',
    'void',
    ['/V', '/PV'],
    [['Mat', 'H', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setH [ARG Mat H=]>

--- Incoming ---
['cv.xfeatures2d.DAISY.getH', 'Mat', ['/C', '/V', '/PV'], [], 'cv::Mat']
ok: FUNC <Mat cv.xfeatures2d.DAISY.getH []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setInterpolation',
    'void',
    ['/V', '/PV'],
    [['bool', 'interpolation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setInterpolation [ARG bool interpolation=]>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.getInterpolation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.DAISY.getInterpolation []>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.setUseOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_orientation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.DAISY.setUseOrientation [ARG bool use_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.DAISY.getUseOrientation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.DAISY.getUseOrientation []>

--- Incoming ---
['cv.xfeatures2d.DAISY.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.DAISY.getDefaultName []>

--- Incoming ---
[   'class cv.xfeatures2d.MSDDetector',
    ': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.MSDDetector : Feature2D, name: MSDDetector, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.create',
    'Ptr_MSDDetector',
    ['/S'],
    [   ['int', 'm_patch_radius', '3', []],
        ['int', 'm_search_area_radius', '5', []],
        ['int', 'm_nms_radius', '5', []],
        ['int', 'm_nms_scale_radius', '0', []],
        ['float', 'm_th_saliency', '250.0f', []],
        ['int', 'm_kNN', '4', []],
        ['float', 'm_scale_factor', '1.25f', []],
        ['int', 'm_n_scales', '-1', []],
        ['bool', 'm_compute_orientation', 'false', []]],
    'Ptr<MSDDetector>']
ok: FUNC <Ptr_MSDDetector cv.xfeatures2d.MSDDetector.create [ARG int m_patch_radius=3, ARG int m_search_area_radius=5, ARG int m_nms_radius=5, ARG int m_nms_scale_radius=0, ARG float m_th_saliency=250.0f, ARG int m_kNN=4, ARG float m_scale_factor=1.25f, ARG int m_n_scales=-1, ARG bool m_compute_orientation=false]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setPatchRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'patch_radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setPatchRadius [ARG int patch_radius=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getPatchRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getPatchRadius []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setSearchAreaRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'use_orientation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setSearchAreaRadius [ARG int use_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getSearchAreaRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getSearchAreaRadius []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setNmsRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'nms_radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setNmsRadius [ARG int nms_radius=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getNmsRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getNmsRadius []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setNmsScaleRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'nms_scale_radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setNmsScaleRadius [ARG int nms_scale_radius=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getNmsScaleRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getNmsScaleRadius []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setThSaliency',
    'void',
    ['/V', '/PV'],
    [['float', 'th_saliency', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setThSaliency [ARG float th_saliency=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getThSaliency',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.MSDDetector.getThSaliency []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setKNN',
    'void',
    ['/V', '/PV'],
    [['int', 'kNN', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setKNN [ARG int kNN=]>

--- Incoming ---
['cv.xfeatures2d.MSDDetector.getKNN', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getKNN []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['float', 'scale_factor', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getScaleFactor',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.MSDDetector.getScaleFactor []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setNScales',
    'void',
    ['/V', '/PV'],
    [['int', 'use_orientation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setNScales [ARG int use_orientation=]>

--- Incoming ---
['cv.xfeatures2d.MSDDetector.getNScales', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.MSDDetector.getNScales []>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.setComputeOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', 'compute_orientation', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.MSDDetector.setComputeOrientation [ARG bool compute_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.MSDDetector.getComputeOrientation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.MSDDetector.getComputeOrientation []>

--- Incoming ---
['cv.xfeatures2d.MSDDetector.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.MSDDetector.getDefaultName []>

--- Incoming ---
['class cv.xfeatures2d.VGG', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.VGG : Feature2D, name: VGG, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.VGG.create',
    'Ptr_VGG',
    ['/S'],
    [   ['int', 'desc', 'VGG::VGG_120', []],
        ['float', 'isigma', '1.4f', []],
        ['bool', 'img_normalize', 'true', []],
        ['bool', 'use_scale_orientation', 'true', []],
        ['float', 'scale_factor', '6.25f', []],
        ['bool', 'dsc_normalize', 'false', []]],
    'Ptr<VGG>']
ok: FUNC <Ptr_VGG cv.xfeatures2d.VGG.create [ARG int desc=VGG::VGG_120, ARG float isigma=1.4f, ARG bool img_normalize=true, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f, ARG bool dsc_normalize=false]>

--- Incoming ---
['cv.xfeatures2d.VGG.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.VGG.getDefaultName []>

--- Incoming ---
[   'cv.xfeatures2d.VGG.setSigma',
    'void',
    ['/V', '/PV'],
    [['float', 'isigma', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.VGG.setSigma [ARG float isigma=]>

--- Incoming ---
['cv.xfeatures2d.VGG.getSigma', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xfeatures2d.VGG.getSigma []>

--- Incoming ---
[   'cv.xfeatures2d.VGG.setUseNormalizeImage',
    'void',
    ['/V', '/PV'],
    [['bool', 'img_normalize', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseNormalizeImage [ARG bool img_normalize=]>

--- Incoming ---
[   'cv.xfeatures2d.VGG.getUseNormalizeImage',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeImage []>

--- Incoming ---
[   'cv.xfeatures2d.VGG.setUseScaleOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_scale_orientation', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseScaleOrientation [ARG bool use_scale_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.VGG.getUseScaleOrientation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseScaleOrientation []>

--- Incoming ---
[   'cv.xfeatures2d.VGG.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['float', 'scale_factor', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.VGG.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
['cv.xfeatures2d.VGG.getScaleFactor', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.xfeatures2d.VGG.getScaleFactor []>

--- Incoming ---
[   'cv.xfeatures2d.VGG.setUseNormalizeDescriptor',
    'void',
    ['/V', '/PV'],
    [['bool', 'dsc_normalize', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.VGG.setUseNormalizeDescriptor [ARG bool dsc_normalize=]>

--- Incoming ---
[   'cv.xfeatures2d.VGG.getUseNormalizeDescriptor',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeDescriptor []>

--- Incoming ---
['class cv.xfeatures2d.BoostDesc', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.BoostDesc : Feature2D, name: BoostDesc, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.BoostDesc.create',
    'Ptr_BoostDesc',
    ['/S'],
    [   ['int', 'desc', 'BoostDesc::BINBOOST_256', []],
        ['bool', 'use_scale_orientation', 'true', []],
        ['float', 'scale_factor', '6.25f', []]],
    'Ptr<BoostDesc>']
ok: FUNC <Ptr_BoostDesc cv.xfeatures2d.BoostDesc.create [ARG int desc=BoostDesc::BINBOOST_256, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f]>

--- Incoming ---
['cv.xfeatures2d.BoostDesc.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.BoostDesc.getDefaultName []>

--- Incoming ---
[   'cv.xfeatures2d.BoostDesc.setUseScaleOrientation',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_scale_orientation', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.BoostDesc.setUseScaleOrientation [ARG bool use_scale_orientation=]>

--- Incoming ---
[   'cv.xfeatures2d.BoostDesc.getUseScaleOrientation',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.xfeatures2d.BoostDesc.getUseScaleOrientation []>

--- Incoming ---
[   'cv.xfeatures2d.BoostDesc.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['float', 'scale_factor', '', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d.BoostDesc.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   'cv.xfeatures2d.BoostDesc.getScaleFactor',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.BoostDesc.getScaleFactor []>

--- Incoming ---
['class cv.xfeatures2d.PCTSignatures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xfeatures2d::.PCTSignatures : Algorithm, name: PCTSignatures, base: Algorithm

--- Incoming ---
[   'enum cv.xfeatures2d.PCTSignatures.DistanceFunction',
    '',
    [],
    [   ['const cv.xfeatures2d.PCTSignatures.L0_25', '0', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.L0_5', '1', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.L1', '2', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.L2', '3', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.L2SQUARED', '4', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.L5', '5', [], [], None, ''],
        [   'const cv.xfeatures2d.PCTSignatures.L_INFINITY',
            '6',
            [],
            [],
            None,
            '']],
    None]
ok: CONST L0_25=0
ok: CONST L0_5=1
ok: CONST L1=2
ok: CONST L2=3
ok: CONST L2SQUARED=4
ok: CONST L5=5
ok: CONST L_INFINITY=6

--- Incoming ---
[   'enum cv.xfeatures2d.PCTSignatures.PointDistribution',
    '',
    [],
    [   ['const cv.xfeatures2d.PCTSignatures.UNIFORM', '0', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.REGULAR', '1', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.NORMAL', '2', [], [], None, '']],
    None]
ok: CONST UNIFORM=0
ok: CONST REGULAR=1
ok: CONST NORMAL=2

--- Incoming ---
[   'enum cv.xfeatures2d.PCTSignatures.SimilarityFunction',
    '',
    [],
    [   ['const cv.xfeatures2d.PCTSignatures.MINUS', '0', [], [], None, ''],
        ['const cv.xfeatures2d.PCTSignatures.GAUSSIAN', '1', [], [], None, ''],
        [   'const cv.xfeatures2d.PCTSignatures.HEURISTIC',
            '2',
            [],
            [],
            None,
            '']],
    None]
ok: CONST MINUS=0
ok: CONST GAUSSIAN=1
ok: CONST HEURISTIC=2

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.create',
    'Ptr_PCTSignatures',
    ['/S'],
    [   ['int', 'initSampleCount', '2000', ['/C']],
        ['int', 'initSeedCount', '400', ['/C']],
        ['int', 'pointDistribution', '0', ['/C']]],
    'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG int initSampleCount=2000, ARG int initSeedCount=400, ARG int pointDistribution=0]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.create',
    'Ptr_PCTSignatures',
    ['/S'],
    [   ['vector_Point2f', 'initSamplingPoints', '', ['/C', '/Ref']],
        ['int', 'initSeedCount', '', ['/C']]],
    'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG int initSeedCount=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.create',
    'Ptr_PCTSignatures',
    ['/S'],
    [   ['vector_Point2f', 'initSamplingPoints', '', ['/C', '/Ref']],
        ['vector_int', 'initClusterSeedIndexes', '', ['/C', '/Ref']]],
    'Ptr<PCTSignatures>']
ok: FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG vector_int initClusterSeedIndexes=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.computeSignature',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'image', '', []], ['Mat', 'signature', '', ['/O']]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.computeSignature [ARG Mat image=, ARG Mat signature=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.computeSignatures',
    'void',
    ['/C', '/V', '/PV'],
    [   ['vector_Mat', 'images', '', ['/C', '/Ref']],
        ['vector_Mat', 'signatures', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.computeSignatures [ARG vector_Mat images=, ARG vector_Mat signatures=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.drawSignature',
    'void',
    ['/S'],
    [   ['Mat', 'source', '', []],
        ['Mat', 'signature', '', []],
        ['Mat', 'result', '', ['/O']],
        ['float', 'radiusToShorterSideRatio', '1.0 / 8', []],
        ['int', 'borderThickness', '1', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.drawSignature [ARG Mat source=, ARG Mat signature=, ARG Mat result=, ARG float radiusToShorterSideRatio=1.0 / 8, ARG int borderThickness=1]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.generateInitPoints',
    'void',
    ['/S'],
    [   ['vector_Point2f', 'initPoints', '', ['/Ref']],
        ['int', 'count', '', ['/C']],
        ['int', 'pointDistribution', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.generateInitPoints [ARG vector_Point2f initPoints=, ARG int count=, ARG int pointDistribution=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getSampleCount',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getSampleCount []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getGrayscaleBits',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getGrayscaleBits []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setGrayscaleBits',
    'void',
    ['/V', '/PV'],
    [['int', 'grayscaleBits', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setGrayscaleBits [ARG int grayscaleBits=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWindowRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getWindowRadius []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWindowRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'radius', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWindowRadius [ARG int radius=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightX',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightX []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightX',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightX [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightY',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightY []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightY',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightY [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightL',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightL []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightL',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightL [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightA',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightA []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightA',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightA [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightB',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightB []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightB',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightB [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightContrast',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightContrast []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightContrast',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightContrast [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getWeightEntropy',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getWeightEntropy []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeightEntropy',
    'void',
    ['/V', '/PV'],
    [['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeightEntropy [ARG float weight=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getSamplingPoints',
    'vector_Point2f',
    ['/C', '/V', '/PV'],
    [],
    'std::vector<Point2f>']
ok: FUNC <vector_Point2f cv.xfeatures2d.PCTSignatures.getSamplingPoints []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeight',
    'void',
    ['/V', '/PV'],
    [['int', 'idx', '', []], ['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeight [ARG int idx=, ARG float value=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setWeights',
    'void',
    ['/V', '/PV'],
    [['vector_float', 'weights', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setWeights [ARG vector_float weights=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setTranslation',
    'void',
    ['/V', '/PV'],
    [['int', 'idx', '', []], ['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setTranslation [ARG int idx=, ARG float value=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setTranslations',
    'void',
    ['/V', '/PV'],
    [['vector_float', 'translations', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setTranslations [ARG vector_float translations=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setSamplingPoints',
    'void',
    ['/V', '/PV'],
    [['vector_Point2f', 'samplingPoints', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setSamplingPoints [ARG vector_Point2f samplingPoints=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getInitSeedIndexes',
    'vector_int',
    ['/C', '/V', '/PV'],
    [],
    'std::vector<int>']
ok: FUNC <vector_int cv.xfeatures2d.PCTSignatures.getInitSeedIndexes []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setInitSeedIndexes',
    'void',
    ['/V', '/PV'],
    [['vector_int', 'initSeedIndexes', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setInitSeedIndexes [ARG vector_int initSeedIndexes=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getInitSeedCount',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getInitSeedCount []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getIterationCount',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getIterationCount []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setIterationCount',
    'void',
    ['/V', '/PV'],
    [['int', 'iterationCount', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setIterationCount [ARG int iterationCount=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getMaxClustersCount',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getMaxClustersCount []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setMaxClustersCount',
    'void',
    ['/V', '/PV'],
    [['int', 'maxClustersCount', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setMaxClustersCount [ARG int maxClustersCount=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getClusterMinSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getClusterMinSize []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setClusterMinSize',
    'void',
    ['/V', '/PV'],
    [['int', 'clusterMinSize', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setClusterMinSize [ARG int clusterMinSize=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getJoiningDistance',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getJoiningDistance []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setJoiningDistance',
    'void',
    ['/V', '/PV'],
    [['float', 'joiningDistance', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setJoiningDistance [ARG float joiningDistance=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getDropThreshold',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignatures.getDropThreshold []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setDropThreshold',
    'void',
    ['/V', '/PV'],
    [['float', 'dropThreshold', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setDropThreshold [ARG float dropThreshold=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.getDistanceFunction',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.PCTSignatures.getDistanceFunction []>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignatures.setDistanceFunction',
    'void',
    ['/V', '/PV'],
    [['int', 'distanceFunction', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignatures.setDistanceFunction [ARG int distanceFunction=]>

--- Incoming ---
['class cv.xfeatures2d.PCTSignaturesSQFD', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.xfeatures2d::.PCTSignaturesSQFD : Algorithm, name: PCTSignaturesSQFD, base: Algorithm

--- Incoming ---
[   'cv.xfeatures2d.PCTSignaturesSQFD.create',
    'Ptr_PCTSignaturesSQFD',
    ['/S'],
    [   ['int', 'distanceFunction', '3', ['/C']],
        ['int', 'similarityFunction', '2', ['/C']],
        ['float', 'similarityParameter', '1.0f', ['/C']]],
    'Ptr<PCTSignaturesSQFD>']
ok: FUNC <Ptr_PCTSignaturesSQFD cv.xfeatures2d.PCTSignaturesSQFD.create [ARG int distanceFunction=3, ARG int similarityFunction=2, ARG float similarityParameter=1.0f]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance',
    'float',
    ['/C', '/V', '/PV'],
    [['Mat', '_signature0', '', []], ['Mat', '_signature1', '', []]],
    'float']
ok: FUNC <float cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance [ARG Mat _signature0=, ARG Mat _signature1=]>

--- Incoming ---
[   'cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'sourceSignature', '', ['/C', '/Ref']],
        ['vector_Mat', 'imageSignatures', '', ['/C', '/Ref']],
        ['vector_float', 'distances', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances [ARG Mat sourceSignature=, ARG vector_Mat imageSignatures=, ARG vector_float distances=]>

--- Incoming ---
[   'class cv.xfeatures2d.HarrisLaplaceFeatureDetector',
    ': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.HarrisLaplaceFeatureDetector : Feature2D, name: HarrisLaplaceFeatureDetector, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.create',
    'Ptr_HarrisLaplaceFeatureDetector',
    ['/S'],
    [   ['int', 'numOctaves', '6', []],
        ['float', 'corn_thresh', '0.01f', []],
        ['float', 'DOG_thresh', '0.01f', []],
        ['int', 'maxCorners', '5000', []],
        ['int', 'num_layers', '4', []]],
    'Ptr<HarrisLaplaceFeatureDetector>']
ok: FUNC <Ptr_HarrisLaplaceFeatureDetector cv.xfeatures2d.HarrisLaplaceFeatureDetector.create [ARG int numOctaves=6, ARG float corn_thresh=0.01f, ARG float DOG_thresh=0.01f, ARG int maxCorners=5000, ARG int num_layers=4]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'numOctaves_', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumOctaves [ARG int numOctaves_=]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumOctaves',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumOctaves []>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.setCornThresh',
    'void',
    ['/V', '/PV'],
    [['float', 'corn_thresh_', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setCornThresh [ARG float corn_thresh_=]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getCornThresh',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.HarrisLaplaceFeatureDetector.getCornThresh []>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.setDOGThresh',
    'void',
    ['/V', '/PV'],
    [['float', 'DOG_thresh_', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setDOGThresh [ARG float DOG_thresh_=]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDOGThresh',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDOGThresh []>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.setMaxCorners',
    'void',
    ['/V', '/PV'],
    [['int', 'maxCorners_', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setMaxCorners [ARG int maxCorners_=]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getMaxCorners',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getMaxCorners []>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumLayers',
    'void',
    ['/V', '/PV'],
    [['int', 'num_layers_', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumLayers [ARG int num_layers_=]>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumLayers',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumLayers []>

--- Incoming ---
[   'cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDefaultName',
    'String',
    ['/C'],
    [],
    'String']
ok: FUNC <String cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDefaultName []>

--- Incoming ---
[   'class cv.xfeatures2d.AffineFeature2D',
    ': cv::xfeatures2d::Feature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.AffineFeature2D : Feature2D, name: AffineFeature2D, base: Feature2D

--- Incoming ---
[   'class cv.xfeatures2d.TBMR',
    ': cv::xfeatures2d::AffineFeature2D',
    [],
    [],
    None]
ok: class CLASS cv.xfeatures2d::.TBMR : AffineFeature2D, name: TBMR, base: AffineFeature2D

--- Incoming ---
[   'cv.xfeatures2d.TBMR.create',
    'Ptr_TBMR',
    ['/S'],
    [   ['int', 'min_area', '60', []],
        ['float', 'max_area_relative', '0.01f', []],
        ['float', 'scale_factor', '1.25f', []],
        ['int', 'n_scales', '-1', []]],
    'Ptr<TBMR>']
ok: FUNC <Ptr_TBMR cv.xfeatures2d.TBMR.create [ARG int min_area=60, ARG float max_area_relative=0.01f, ARG float scale_factor=1.25f, ARG int n_scales=-1]>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.setMinArea',
    'void',
    ['/V', '/PV'],
    [['int', 'minArea', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.TBMR.setMinArea [ARG int minArea=]>

--- Incoming ---
['cv.xfeatures2d.TBMR.getMinArea', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.TBMR.getMinArea []>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.setMaxAreaRelative',
    'void',
    ['/V', '/PV'],
    [['float', 'maxArea', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.TBMR.setMaxAreaRelative [ARG float maxArea=]>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.getMaxAreaRelative',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.TBMR.getMaxAreaRelative []>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.setScaleFactor',
    'void',
    ['/V', '/PV'],
    [['float', 'scale_factor', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.TBMR.setScaleFactor [ARG float scale_factor=]>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.getScaleFactor',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.xfeatures2d.TBMR.getScaleFactor []>

--- Incoming ---
[   'cv.xfeatures2d.TBMR.setNScales',
    'void',
    ['/V', '/PV'],
    [['int', 'n_scales', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.TBMR.setNScales [ARG int n_scales=]>

--- Incoming ---
['cv.xfeatures2d.TBMR.getNScales', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.TBMR.getNScales []>

--- Incoming ---
[   'cv.xfeatures2d.matchGMS',
    'void',
    [],
    [   ['Size', 'size1', '', ['/C', '/Ref']],
        ['Size', 'size2', '', ['/C', '/Ref']],
        ['vector_KeyPoint', 'keypoints1', '', ['/C', '/Ref']],
        ['vector_KeyPoint', 'keypoints2', '', ['/C', '/Ref']],
        ['vector_DMatch', 'matches1to2', '', ['/C', '/Ref']],
        ['vector_DMatch', 'matchesGMS', '', ['/O', '/Ref']],
        ['bool', 'withRotation', 'false', ['/C']],
        ['bool', 'withScale', 'false', ['/C']],
        ['double', 'thresholdFactor', '6.0', ['/C']]],
    'void']
ok: FUNC <void cv.xfeatures2d..matchGMS [ARG Size size1=, ARG Size size2=, ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG vector_DMatch matchesGMS=, ARG bool withRotation=false, ARG bool withScale=false, ARG double thresholdFactor=6.0]>

--- Incoming ---
[   'cv.xfeatures2d.matchLOGOS',
    'void',
    [],
    [   ['vector_KeyPoint', 'keypoints1', '', ['/C', '/Ref']],
        ['vector_KeyPoint', 'keypoints2', '', ['/C', '/Ref']],
        ['vector_int', 'nn1', '', ['/C', '/Ref']],
        ['vector_int', 'nn2', '', ['/C', '/Ref']],
        ['vector_DMatch', 'matches1to2', '', ['/Ref']]],
    'void']
ok: FUNC <void cv.xfeatures2d..matchLOGOS [ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_int nn1=, ARG vector_int nn2=, ARG vector_DMatch matches1to2=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/nonfree.hpp =====
Namespaces: ['cv', 'cv.xfeatures2d']

--- Incoming ---
['class cv.xfeatures2d.SURF', ': cv::xfeatures2d::Feature2D', [], [], None]
ok: class CLASS cv.xfeatures2d::.SURF : Feature2D, name: SURF, base: Feature2D

--- Incoming ---
[   'cv.xfeatures2d.SURF.create',
    'Ptr_SURF',
    ['/S'],
    [   ['double', 'hessianThreshold', '100', []],
        ['int', 'nOctaves', '4', []],
        ['int', 'nOctaveLayers', '3', []],
        ['bool', 'extended', 'false', []],
        ['bool', 'upright', 'false', []]],
    'Ptr<SURF>']
ok: FUNC <Ptr_SURF cv.xfeatures2d.SURF.create [ARG double hessianThreshold=100, ARG int nOctaves=4, ARG int nOctaveLayers=3, ARG bool extended=false, ARG bool upright=false]>

--- Incoming ---
[   'cv.xfeatures2d.SURF.setHessianThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'hessianThreshold', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.SURF.setHessianThreshold [ARG double hessianThreshold=]>

--- Incoming ---
[   'cv.xfeatures2d.SURF.getHessianThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.xfeatures2d.SURF.getHessianThreshold []>

--- Incoming ---
[   'cv.xfeatures2d.SURF.setNOctaves',
    'void',
    ['/V', '/PV'],
    [['int', 'nOctaves', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.SURF.setNOctaves [ARG int nOctaves=]>

--- Incoming ---
['cv.xfeatures2d.SURF.getNOctaves', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.SURF.getNOctaves []>

--- Incoming ---
[   'cv.xfeatures2d.SURF.setNOctaveLayers',
    'void',
    ['/V', '/PV'],
    [['int', 'nOctaveLayers', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.SURF.setNOctaveLayers [ARG int nOctaveLayers=]>

--- Incoming ---
['cv.xfeatures2d.SURF.getNOctaveLayers', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.xfeatures2d.SURF.getNOctaveLayers []>

--- Incoming ---
[   'cv.xfeatures2d.SURF.setExtended',
    'void',
    ['/V', '/PV'],
    [['bool', 'extended', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.SURF.setExtended [ARG bool extended=]>

--- Incoming ---
['cv.xfeatures2d.SURF.getExtended', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.xfeatures2d.SURF.getExtended []>

--- Incoming ---
[   'cv.xfeatures2d.SURF.setUpright',
    'void',
    ['/V', '/PV'],
    [['bool', 'upright', '', []]],
    'void']
ok: FUNC <void cv.xfeatures2d.SURF.setUpright [ARG bool upright=]>

--- Incoming ---
['cv.xfeatures2d.SURF.getUpright', 'bool', ['/C', '/V', '/PV'], [], 'bool']
ok: FUNC <bool cv.xfeatures2d.SURF.getUpright []>

--- Incoming ---
['cv.xfeatures2d.SURF.getDefaultName', 'String', ['/C'], [], 'String']
ok: FUNC <String cv.xfeatures2d.SURF.getDefaultName []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/xfeatures2d/include/opencv2/xfeatures2d/cuda.hpp =====
Namespaces: ['cv', 'cv.cuda', 'cv.xfeatures2d']

--- Incoming ---
[   'class cv.cuda.SURF_CUDA',
    '',
    [],
    [   ['double', 'hessianThreshold', '', []],
        ['int', 'nOctaves', '', []],
        ['int', 'nOctaveLayers', '', []],
        ['bool', 'extended', '', []],
        ['bool', 'upright', '', []],
        ['float', 'keypointsRatio', '', []]],
    None]
ok: class CLASS cv.cuda::.SURF_CUDA : , name: SURF_CUDA, base: 

--- Incoming ---
[   'enum cv.cuda.SURF_CUDA.KeypointLayout',
    '',
    [],
    [   ['const cv.cuda.SURF_CUDA.X_ROW', '0', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.Y_ROW', '0+1', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.LAPLACIAN_ROW', '0+2', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.OCTAVE_ROW', '0+3', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.SIZE_ROW', '0+4', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.ANGLE_ROW', '0+5', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.HESSIAN_ROW', '0+6', [], [], None, ''],
        ['const cv.cuda.SURF_CUDA.ROWS_COUNT', '0+7', [], [], None, '']],
    None]
ok: CONST X_ROW=0
ok: CONST Y_ROW=0+1
ok: CONST LAPLACIAN_ROW=0+2
ok: CONST OCTAVE_ROW=0+3
ok: CONST SIZE_ROW=0+4
ok: CONST ANGLE_ROW=0+5
ok: CONST HESSIAN_ROW=0+6
ok: CONST ROWS_COUNT=0+7

--- Incoming ---
[   'cv.cuda.SURF_CUDA.create',
    'Ptr_SURF_CUDA',
    ['/S'],
    [   ['double', '_hessianThreshold', '', []],
        ['int', '_nOctaves', '4', []],
        ['int', '_nOctaveLayers', '2', []],
        ['bool', '_extended', 'false', []],
        ['float', '_keypointsRatio', '0.01f', []],
        ['bool', '_upright', 'false', []]],
    'Ptr<SURF_CUDA>']
ok: FUNC <Ptr_SURF_CUDA cv.cuda.SURF_CUDA.create [ARG double _hessianThreshold=, ARG int _nOctaves=4, ARG int _nOctaveLayers=2, ARG bool _extended=false, ARG float _keypointsRatio=0.01f, ARG bool _upright=false]>

--- Incoming ---
['cv.cuda.SURF_CUDA.descriptorSize', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.cuda.SURF_CUDA.descriptorSize []>

--- Incoming ---
['cv.cuda.SURF_CUDA.defaultNorm', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.cuda.SURF_CUDA.defaultNorm []>

--- Incoming ---
[   'cv.cuda.SURF_CUDA.downloadKeypoints',
    'void',
    [],
    [   ['GpuMat', 'keypointsGPU', '', ['/C', '/Ref']],
        ['vector_KeyPoint', 'keypoints', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.cuda.SURF_CUDA.downloadKeypoints [ARG GpuMat keypointsGPU=, ARG vector_KeyPoint keypoints=]>

--- Incoming ---
[   'cv.cuda.SURF_CUDA.detect',
    'void',
    [],
    [   ['GpuMat', 'img', '', ['/C', '/Ref']],
        ['GpuMat', 'mask', '', ['/C', '/Ref']],
        ['GpuMat', 'keypoints', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.cuda.SURF_CUDA.detect [ARG GpuMat img=, ARG GpuMat mask=, ARG GpuMat keypoints=]>

--- Incoming ---
[   'cv.cuda.SURF_CUDA.detectWithDescriptors',
    'void',
    [],
    [   ['GpuMat', 'img', '', ['/C', '/Ref']],
        ['GpuMat', 'mask', '', ['/C', '/Ref']],
        ['GpuMat', 'keypoints', '', ['/O', '/Ref']],
        ['GpuMat', 'descriptors', '', ['/O', '/Ref']],
        ['bool', 'useProvidedKeypoints', 'false', []]],
    'void']
ok: FUNC <void cv.cuda.SURF_CUDA.detectWithDescriptors [ARG GpuMat img=, ARG GpuMat mask=, ARG GpuMat keypoints=, ARG GpuMat descriptors=, ARG bool useProvidedKeypoints=false]>


===== Generating... =====
CLASS cv::.Xfeatures2d : 
FUNC <void cv.xfeatures2d..matchGMS [ARG Size size1=, ARG Size size2=, ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG vector_DMatch matchesGMS=, ARG bool withRotation=false, ARG bool withScale=false, ARG double thresholdFactor=6.0]>
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation, boolean withScale, double thresholdFactor)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation, boolean withScale)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS, boolean withRotation)
java: void matchGMS(Size size1, Size size2, MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, MatOfDMatch matchesGMS)
FUNC <void cv.xfeatures2d..matchLOGOS [ARG vector_KeyPoint keypoints1=, ARG vector_KeyPoint keypoints2=, ARG vector_int nn1=, ARG vector_int nn2=, ARG vector_DMatch matches1to2=]>
java: void matchLOGOS(MatOfKeyPoint keypoints1, MatOfKeyPoint keypoints2, MatOfInt nn1, MatOfInt nn2, MatOfDMatch matches1to2)
CLASS cv.cuda::.SURF_CUDA : 
[CONST X_ROW=0, CONST Y_ROW=0+1, CONST LAPLACIAN_ROW=0+2, CONST OCTAVE_ROW=0+3, CONST SIZE_ROW=0+4, CONST ANGLE_ROW=0+5, CONST HESSIAN_ROW=0+6, CONST ROWS_COUNT=0+7]
FUNC <Ptr_SURF_CUDA cv.cuda.SURF_CUDA.create [ARG double _hessianThreshold=, ARG int _nOctaves=4, ARG int _nOctaveLayers=2, ARG bool _extended=false, ARG float _keypointsRatio=0.01f, ARG bool _upright=false]>
java: SURF_CUDA create(double _hessianThreshold, int _nOctaves, int _nOctaveLayers, boolean _extended, float _keypointsRatio, boolean _upright)
java: SURF_CUDA create(double _hessianThreshold, int _nOctaves, int _nOctaveLayers, boolean _extended, float _keypointsRatio)
java: SURF_CUDA create(double _hessianThreshold, int _nOctaves, int _nOctaveLayers, boolean _extended)
java: SURF_CUDA create(double _hessianThreshold, int _nOctaves, int _nOctaveLayers)
java: SURF_CUDA create(double _hessianThreshold, int _nOctaves)
java: SURF_CUDA create(double _hessianThreshold)
FUNC <int cv.cuda.SURF_CUDA.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.cuda.SURF_CUDA.defaultNorm []>
java: int defaultNorm()
FUNC <void cv.cuda.SURF_CUDA.downloadKeypoints [ARG GpuMat keypointsGPU=, ARG vector_KeyPoint keypoints=]>
SKIP:void cv::cuda::SURF_CUDA::downloadKeypoints(GpuMat keypointsGPU, vector_KeyPoint& keypoints)	 due to ARG type GpuMat/I
FUNC <void cv.cuda.SURF_CUDA.detect [ARG GpuMat img=, ARG GpuMat mask=, ARG GpuMat keypoints=]>
SKIP:void cv::cuda::SURF_CUDA::detect(GpuMat img, GpuMat mask, GpuMat& keypoints)	 due to ARG type GpuMat/I
FUNC <void cv.cuda.SURF_CUDA.detectWithDescriptors [ARG GpuMat img=, ARG GpuMat mask=, ARG GpuMat keypoints=, ARG GpuMat descriptors=, ARG bool useProvidedKeypoints=false]>
SKIP:void cv::cuda::SURF_CUDA::detectWithDescriptors(GpuMat img, GpuMat mask, GpuMat& keypoints, GpuMat& descriptors, bool useProvidedKeypoints = false)	 due to ARG type GpuMat/I
FUNC <double cv.cuda.SURF_CUDA.get_hessianThreshold []>
java: double get_hessianThreshold()
FUNC <int cv.cuda.SURF_CUDA.get_nOctaves []>
java: int get_nOctaves()
FUNC <int cv.cuda.SURF_CUDA.get_nOctaveLayers []>
java: int get_nOctaveLayers()
FUNC <bool cv.cuda.SURF_CUDA.get_extended []>
java: boolean get_extended()
FUNC <bool cv.cuda.SURF_CUDA.get_upright []>
java: boolean get_upright()
FUNC <float cv.cuda.SURF_CUDA.get_keypointsRatio []>
java: float get_keypointsRatio()
CLASS cv.xfeatures2d::.AffineFeature2D : Feature2D
CLASS cv.xfeatures2d::.BEBLID : Feature2D
[CONST SIZE_512_BITS=100, CONST SIZE_256_BITS=101]
FUNC <Ptr_BEBLID cv.xfeatures2d.BEBLID.create [ARG float scale_factor=, ARG int n_bits=BEBLID::SIZE_512_BITS]>
java: BEBLID create(float scale_factor, int n_bits)
java: BEBLID create(float scale_factor)
FUNC <void cv.xfeatures2d.BEBLID.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <float cv.xfeatures2d.BEBLID.getScaleFactor []>
java: float getScaleFactor()
FUNC <String cv.xfeatures2d.BEBLID.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.BoostDesc : Feature2D
FUNC <Ptr_BoostDesc cv.xfeatures2d.BoostDesc.create [ARG int desc=BoostDesc::BINBOOST_256, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f]>
java: BoostDesc create(int desc, boolean use_scale_orientation, float scale_factor)
java: BoostDesc create(int desc, boolean use_scale_orientation)
java: BoostDesc create(int desc)
java: BoostDesc create()
FUNC <String cv.xfeatures2d.BoostDesc.getDefaultName []>
java: String getDefaultName()
FUNC <void cv.xfeatures2d.BoostDesc.setUseScaleOrientation [ARG bool use_scale_orientation=]>
java: void setUseScaleOrientation(boolean use_scale_orientation)
FUNC <bool cv.xfeatures2d.BoostDesc.getUseScaleOrientation []>
java: boolean getUseScaleOrientation()
FUNC <void cv.xfeatures2d.BoostDesc.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <float cv.xfeatures2d.BoostDesc.getScaleFactor []>
java: float getScaleFactor()
CLASS cv.xfeatures2d::.BriefDescriptorExtractor : Feature2D
FUNC <Ptr_BriefDescriptorExtractor cv.xfeatures2d.BriefDescriptorExtractor.create [ARG int bytes=32, ARG bool use_orientation=false]>
java: BriefDescriptorExtractor create(int bytes, boolean use_orientation)
java: BriefDescriptorExtractor create(int bytes)
java: BriefDescriptorExtractor create()
FUNC <void cv.xfeatures2d.BriefDescriptorExtractor.setDescriptorSize [ARG int bytes=]>
java: void setDescriptorSize(int bytes)
FUNC <int cv.xfeatures2d.BriefDescriptorExtractor.getDescriptorSize []>
java: int getDescriptorSize()
FUNC <void cv.xfeatures2d.BriefDescriptorExtractor.setUseOrientation [ARG bool use_orientation=]>
java: void setUseOrientation(boolean use_orientation)
FUNC <bool cv.xfeatures2d.BriefDescriptorExtractor.getUseOrientation []>
java: boolean getUseOrientation()
FUNC <String cv.xfeatures2d.BriefDescriptorExtractor.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.DAISY : Feature2D
[CONST NRM_NONE=100, CONST NRM_PARTIAL=101, CONST NRM_FULL=102, CONST NRM_SIFT=103]
FUNC <Ptr_DAISY cv.xfeatures2d.DAISY.create [ARG float radius=15, ARG int q_radius=3, ARG int q_theta=8, ARG int q_hist=8, ARG DAISY_NormalizationType norm=DAISY::NRM_NONE, ARG Mat H=Mat(), ARG bool interpolation=true, ARG bool use_orientation=false]>
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H, boolean interpolation, boolean use_orientation)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H, boolean interpolation)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist, Mat H)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist)
java: DAISY create(float radius, int q_radius, int q_theta, int q_hist)
java: DAISY create(float radius, int q_radius, int q_theta)
java: DAISY create(float radius, int q_radius)
java: DAISY create(float radius)
java: DAISY create()
FUNC <void cv.xfeatures2d.DAISY.setRadius [ARG float radius=]>
java: void setRadius(float radius)
FUNC <float cv.xfeatures2d.DAISY.getRadius []>
java: float getRadius()
FUNC <void cv.xfeatures2d.DAISY.setQRadius [ARG int q_radius=]>
java: void setQRadius(int q_radius)
FUNC <int cv.xfeatures2d.DAISY.getQRadius []>
java: int getQRadius()
FUNC <void cv.xfeatures2d.DAISY.setQTheta [ARG int q_theta=]>
java: void setQTheta(int q_theta)
FUNC <int cv.xfeatures2d.DAISY.getQTheta []>
java: int getQTheta()
FUNC <void cv.xfeatures2d.DAISY.setQHist [ARG int q_hist=]>
java: void setQHist(int q_hist)
FUNC <int cv.xfeatures2d.DAISY.getQHist []>
java: int getQHist()
FUNC <void cv.xfeatures2d.DAISY.setNorm [ARG int norm=]>
java: void setNorm(int norm)
FUNC <int cv.xfeatures2d.DAISY.getNorm []>
java: int getNorm()
FUNC <void cv.xfeatures2d.DAISY.setH [ARG Mat H=]>
java: void setH(Mat H)
FUNC <Mat cv.xfeatures2d.DAISY.getH []>
java: Mat getH()
FUNC <void cv.xfeatures2d.DAISY.setInterpolation [ARG bool interpolation=]>
java: void setInterpolation(boolean interpolation)
FUNC <bool cv.xfeatures2d.DAISY.getInterpolation []>
java: boolean getInterpolation()
FUNC <void cv.xfeatures2d.DAISY.setUseOrientation [ARG bool use_orientation=]>
java: void setUseOrientation(boolean use_orientation)
FUNC <bool cv.xfeatures2d.DAISY.getUseOrientation []>
java: boolean getUseOrientation()
FUNC <String cv.xfeatures2d.DAISY.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.FREAK : Feature2D
FUNC <Ptr_FREAK cv.xfeatures2d.FREAK.create [ARG bool orientationNormalized=true, ARG bool scaleNormalized=true, ARG float patternScale=22.0f, ARG int nOctaves=4, ARG vector_int selectedPairs=std::vector<int>()]>
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale, int nOctaves, MatOfInt selectedPairs)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale, int nOctaves)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized, float patternScale)
java: FREAK create(boolean orientationNormalized, boolean scaleNormalized)
java: FREAK create(boolean orientationNormalized)
java: FREAK create()
FUNC <void cv.xfeatures2d.FREAK.setOrientationNormalized [ARG bool orientationNormalized=]>
java: void setOrientationNormalized(boolean orientationNormalized)
FUNC <bool cv.xfeatures2d.FREAK.getOrientationNormalized []>
java: boolean getOrientationNormalized()
FUNC <void cv.xfeatures2d.FREAK.setScaleNormalized [ARG bool scaleNormalized=]>
java: void setScaleNormalized(boolean scaleNormalized)
FUNC <bool cv.xfeatures2d.FREAK.getScaleNormalized []>
java: boolean getScaleNormalized()
FUNC <void cv.xfeatures2d.FREAK.setPatternScale [ARG double patternScale=]>
java: void setPatternScale(double patternScale)
FUNC <double cv.xfeatures2d.FREAK.getPatternScale []>
java: double getPatternScale()
FUNC <void cv.xfeatures2d.FREAK.setNOctaves [ARG int nOctaves=]>
java: void setNOctaves(int nOctaves)
FUNC <int cv.xfeatures2d.FREAK.getNOctaves []>
java: int getNOctaves()
FUNC <String cv.xfeatures2d.FREAK.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.HarrisLaplaceFeatureDetector : Feature2D
FUNC <Ptr_HarrisLaplaceFeatureDetector cv.xfeatures2d.HarrisLaplaceFeatureDetector.create [ARG int numOctaves=6, ARG float corn_thresh=0.01f, ARG float DOG_thresh=0.01f, ARG int maxCorners=5000, ARG int num_layers=4]>
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh, int maxCorners, int num_layers)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh, int maxCorners)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh, float DOG_thresh)
java: HarrisLaplaceFeatureDetector create(int numOctaves, float corn_thresh)
java: HarrisLaplaceFeatureDetector create(int numOctaves)
java: HarrisLaplaceFeatureDetector create()
FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumOctaves [ARG int numOctaves_=]>
java: void setNumOctaves(int numOctaves_)
FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumOctaves []>
java: int getNumOctaves()
FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setCornThresh [ARG float corn_thresh_=]>
java: void setCornThresh(float corn_thresh_)
FUNC <float cv.xfeatures2d.HarrisLaplaceFeatureDetector.getCornThresh []>
java: float getCornThresh()
FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setDOGThresh [ARG float DOG_thresh_=]>
java: void setDOGThresh(float DOG_thresh_)
FUNC <float cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDOGThresh []>
java: float getDOGThresh()
FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setMaxCorners [ARG int maxCorners_=]>
java: void setMaxCorners(int maxCorners_)
FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getMaxCorners []>
java: int getMaxCorners()
FUNC <void cv.xfeatures2d.HarrisLaplaceFeatureDetector.setNumLayers [ARG int num_layers_=]>
java: void setNumLayers(int num_layers_)
FUNC <int cv.xfeatures2d.HarrisLaplaceFeatureDetector.getNumLayers []>
java: int getNumLayers()
FUNC <String cv.xfeatures2d.HarrisLaplaceFeatureDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.LATCH : Feature2D
FUNC <Ptr_LATCH cv.xfeatures2d.LATCH.create [ARG int bytes=32, ARG bool rotationInvariance=true, ARG int half_ssd_size=3, ARG double sigma=2.0]>
java: LATCH create(int bytes, boolean rotationInvariance, int half_ssd_size, double sigma)
java: LATCH create(int bytes, boolean rotationInvariance, int half_ssd_size)
java: LATCH create(int bytes, boolean rotationInvariance)
java: LATCH create(int bytes)
java: LATCH create()
FUNC <void cv.xfeatures2d.LATCH.setBytes [ARG int bytes=]>
java: void setBytes(int bytes)
FUNC <int cv.xfeatures2d.LATCH.getBytes []>
java: int getBytes()
FUNC <void cv.xfeatures2d.LATCH.setRotationInvariance [ARG bool rotationInvariance=]>
java: void setRotationInvariance(boolean rotationInvariance)
FUNC <bool cv.xfeatures2d.LATCH.getRotationInvariance []>
java: boolean getRotationInvariance()
FUNC <void cv.xfeatures2d.LATCH.setHalfSSDsize [ARG int half_ssd_size=]>
java: void setHalfSSDsize(int half_ssd_size)
FUNC <int cv.xfeatures2d.LATCH.getHalfSSDsize []>
java: int getHalfSSDsize()
FUNC <void cv.xfeatures2d.LATCH.setSigma [ARG double sigma=]>
java: void setSigma(double sigma)
FUNC <double cv.xfeatures2d.LATCH.getSigma []>
java: double getSigma()
FUNC <String cv.xfeatures2d.LATCH.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.LUCID : Feature2D
FUNC <Ptr_LUCID cv.xfeatures2d.LUCID.create [ARG int lucid_kernel=1, ARG int blur_kernel=2]>
java: LUCID create(int lucid_kernel, int blur_kernel)
java: LUCID create(int lucid_kernel)
java: LUCID create()
FUNC <void cv.xfeatures2d.LUCID.setLucidKernel [ARG int lucid_kernel=]>
java: void setLucidKernel(int lucid_kernel)
FUNC <int cv.xfeatures2d.LUCID.getLucidKernel []>
java: int getLucidKernel()
FUNC <void cv.xfeatures2d.LUCID.setBlurKernel [ARG int blur_kernel=]>
java: void setBlurKernel(int blur_kernel)
FUNC <int cv.xfeatures2d.LUCID.getBlurKernel []>
java: int getBlurKernel()
FUNC <String cv.xfeatures2d.LUCID.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.MSDDetector : Feature2D
FUNC <Ptr_MSDDetector cv.xfeatures2d.MSDDetector.create [ARG int m_patch_radius=3, ARG int m_search_area_radius=5, ARG int m_nms_radius=5, ARG int m_nms_scale_radius=0, ARG float m_th_saliency=250.0f, ARG int m_kNN=4, ARG float m_scale_factor=1.25f, ARG int m_n_scales=-1, ARG bool m_compute_orientation=false]>
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius, float m_th_saliency, int m_kNN, float m_scale_factor, int m_n_scales, boolean m_compute_orientation)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius, float m_th_saliency, int m_kNN, float m_scale_factor, int m_n_scales)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius, float m_th_saliency, int m_kNN, float m_scale_factor)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius, float m_th_saliency, int m_kNN)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius, float m_th_saliency)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius, int m_nms_scale_radius)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius, int m_nms_radius)
java: MSDDetector create(int m_patch_radius, int m_search_area_radius)
java: MSDDetector create(int m_patch_radius)
java: MSDDetector create()
FUNC <void cv.xfeatures2d.MSDDetector.setPatchRadius [ARG int patch_radius=]>
java: void setPatchRadius(int patch_radius)
FUNC <int cv.xfeatures2d.MSDDetector.getPatchRadius []>
java: int getPatchRadius()
FUNC <void cv.xfeatures2d.MSDDetector.setSearchAreaRadius [ARG int use_orientation=]>
java: void setSearchAreaRadius(int use_orientation)
FUNC <int cv.xfeatures2d.MSDDetector.getSearchAreaRadius []>
java: int getSearchAreaRadius()
FUNC <void cv.xfeatures2d.MSDDetector.setNmsRadius [ARG int nms_radius=]>
java: void setNmsRadius(int nms_radius)
FUNC <int cv.xfeatures2d.MSDDetector.getNmsRadius []>
java: int getNmsRadius()
FUNC <void cv.xfeatures2d.MSDDetector.setNmsScaleRadius [ARG int nms_scale_radius=]>
java: void setNmsScaleRadius(int nms_scale_radius)
FUNC <int cv.xfeatures2d.MSDDetector.getNmsScaleRadius []>
java: int getNmsScaleRadius()
FUNC <void cv.xfeatures2d.MSDDetector.setThSaliency [ARG float th_saliency=]>
java: void setThSaliency(float th_saliency)
FUNC <float cv.xfeatures2d.MSDDetector.getThSaliency []>
java: float getThSaliency()
FUNC <void cv.xfeatures2d.MSDDetector.setKNN [ARG int kNN=]>
java: void setKNN(int kNN)
FUNC <int cv.xfeatures2d.MSDDetector.getKNN []>
java: int getKNN()
FUNC <void cv.xfeatures2d.MSDDetector.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <float cv.xfeatures2d.MSDDetector.getScaleFactor []>
java: float getScaleFactor()
FUNC <void cv.xfeatures2d.MSDDetector.setNScales [ARG int use_orientation=]>
java: void setNScales(int use_orientation)
FUNC <int cv.xfeatures2d.MSDDetector.getNScales []>
java: int getNScales()
FUNC <void cv.xfeatures2d.MSDDetector.setComputeOrientation [ARG bool compute_orientation=]>
java: void setComputeOrientation(boolean compute_orientation)
FUNC <bool cv.xfeatures2d.MSDDetector.getComputeOrientation []>
java: boolean getComputeOrientation()
FUNC <String cv.xfeatures2d.MSDDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.PCTSignatures : Algorithm
[CONST L0_25=0, CONST L0_5=1, CONST L1=2, CONST L2=3, CONST L2SQUARED=4, CONST L5=5, CONST L_INFINITY=6]
[CONST UNIFORM=0, CONST REGULAR=1, CONST NORMAL=2]
[CONST MINUS=0, CONST GAUSSIAN=1, CONST HEURISTIC=2]
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG int initSampleCount=2000, ARG int initSeedCount=400, ARG int pointDistribution=0]>
java: PCTSignatures create(int initSampleCount, int initSeedCount, int pointDistribution)
java: PCTSignatures create(int initSampleCount, int initSeedCount)
java: PCTSignatures create(int initSampleCount)
java: PCTSignatures create()
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG int initSeedCount=]>
java: PCTSignatures create(MatOfPoint2f initSamplingPoints, int initSeedCount)
FUNC <Ptr_PCTSignatures cv.xfeatures2d.PCTSignatures.create [ARG vector_Point2f initSamplingPoints=, ARG vector_int initClusterSeedIndexes=]>
java: PCTSignatures create(MatOfPoint2f initSamplingPoints, MatOfInt initClusterSeedIndexes)
FUNC <void cv.xfeatures2d.PCTSignatures.computeSignature [ARG Mat image=, ARG Mat signature=]>
java: void computeSignature(Mat image, Mat signature)
FUNC <void cv.xfeatures2d.PCTSignatures.computeSignatures [ARG vector_Mat images=, ARG vector_Mat signatures=]>
java: void computeSignatures(List<Mat> images, List<Mat> signatures)
FUNC <void cv.xfeatures2d.PCTSignatures.drawSignature [ARG Mat source=, ARG Mat signature=, ARG Mat result=, ARG float radiusToShorterSideRatio=1.0 / 8, ARG int borderThickness=1]>
java: void drawSignature(Mat source, Mat signature, Mat result, float radiusToShorterSideRatio, int borderThickness)
java: void drawSignature(Mat source, Mat signature, Mat result, float radiusToShorterSideRatio)
java: void drawSignature(Mat source, Mat signature, Mat result)
FUNC <void cv.xfeatures2d.PCTSignatures.generateInitPoints [ARG vector_Point2f initPoints=, ARG int count=, ARG int pointDistribution=]>
java: void generateInitPoints(MatOfPoint2f initPoints, int count, int pointDistribution)
FUNC <int cv.xfeatures2d.PCTSignatures.getSampleCount []>
java: int getSampleCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getGrayscaleBits []>
java: int getGrayscaleBits()
FUNC <void cv.xfeatures2d.PCTSignatures.setGrayscaleBits [ARG int grayscaleBits=]>
java: void setGrayscaleBits(int grayscaleBits)
FUNC <int cv.xfeatures2d.PCTSignatures.getWindowRadius []>
java: int getWindowRadius()
FUNC <void cv.xfeatures2d.PCTSignatures.setWindowRadius [ARG int radius=]>
java: void setWindowRadius(int radius)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightX []>
java: float getWeightX()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightX [ARG float weight=]>
java: void setWeightX(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightY []>
java: float getWeightY()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightY [ARG float weight=]>
java: void setWeightY(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightL []>
java: float getWeightL()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightL [ARG float weight=]>
java: void setWeightL(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightA []>
java: float getWeightA()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightA [ARG float weight=]>
java: void setWeightA(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightB []>
java: float getWeightB()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightB [ARG float weight=]>
java: void setWeightB(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightContrast []>
java: float getWeightContrast()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightContrast [ARG float weight=]>
java: void setWeightContrast(float weight)
FUNC <float cv.xfeatures2d.PCTSignatures.getWeightEntropy []>
java: float getWeightEntropy()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeightEntropy [ARG float weight=]>
java: void setWeightEntropy(float weight)
FUNC <vector_Point2f cv.xfeatures2d.PCTSignatures.getSamplingPoints []>
java: MatOfPoint2f getSamplingPoints()
FUNC <void cv.xfeatures2d.PCTSignatures.setWeight [ARG int idx=, ARG float value=]>
java: void setWeight(int idx, float value)
FUNC <void cv.xfeatures2d.PCTSignatures.setWeights [ARG vector_float weights=]>
java: void setWeights(MatOfFloat weights)
FUNC <void cv.xfeatures2d.PCTSignatures.setTranslation [ARG int idx=, ARG float value=]>
java: void setTranslation(int idx, float value)
FUNC <void cv.xfeatures2d.PCTSignatures.setTranslations [ARG vector_float translations=]>
java: void setTranslations(MatOfFloat translations)
FUNC <void cv.xfeatures2d.PCTSignatures.setSamplingPoints [ARG vector_Point2f samplingPoints=]>
java: void setSamplingPoints(MatOfPoint2f samplingPoints)
FUNC <vector_int cv.xfeatures2d.PCTSignatures.getInitSeedIndexes []>
java: MatOfInt getInitSeedIndexes()
FUNC <void cv.xfeatures2d.PCTSignatures.setInitSeedIndexes [ARG vector_int initSeedIndexes=]>
java: void setInitSeedIndexes(MatOfInt initSeedIndexes)
FUNC <int cv.xfeatures2d.PCTSignatures.getInitSeedCount []>
java: int getInitSeedCount()
FUNC <int cv.xfeatures2d.PCTSignatures.getIterationCount []>
java: int getIterationCount()
FUNC <void cv.xfeatures2d.PCTSignatures.setIterationCount [ARG int iterationCount=]>
java: void setIterationCount(int iterationCount)
FUNC <int cv.xfeatures2d.PCTSignatures.getMaxClustersCount []>
java: int getMaxClustersCount()
FUNC <void cv.xfeatures2d.PCTSignatures.setMaxClustersCount [ARG int maxClustersCount=]>
java: void setMaxClustersCount(int maxClustersCount)
FUNC <int cv.xfeatures2d.PCTSignatures.getClusterMinSize []>
java: int getClusterMinSize()
FUNC <void cv.xfeatures2d.PCTSignatures.setClusterMinSize [ARG int clusterMinSize=]>
java: void setClusterMinSize(int clusterMinSize)
FUNC <float cv.xfeatures2d.PCTSignatures.getJoiningDistance []>
java: float getJoiningDistance()
FUNC <void cv.xfeatures2d.PCTSignatures.setJoiningDistance [ARG float joiningDistance=]>
java: void setJoiningDistance(float joiningDistance)
FUNC <float cv.xfeatures2d.PCTSignatures.getDropThreshold []>
java: float getDropThreshold()
FUNC <void cv.xfeatures2d.PCTSignatures.setDropThreshold [ARG float dropThreshold=]>
java: void setDropThreshold(float dropThreshold)
FUNC <int cv.xfeatures2d.PCTSignatures.getDistanceFunction []>
java: int getDistanceFunction()
FUNC <void cv.xfeatures2d.PCTSignatures.setDistanceFunction [ARG int distanceFunction=]>
java: void setDistanceFunction(int distanceFunction)
CLASS cv.xfeatures2d::.PCTSignaturesSQFD : Algorithm
FUNC <Ptr_PCTSignaturesSQFD cv.xfeatures2d.PCTSignaturesSQFD.create [ARG int distanceFunction=3, ARG int similarityFunction=2, ARG float similarityParameter=1.0f]>
java: PCTSignaturesSQFD create(int distanceFunction, int similarityFunction, float similarityParameter)
java: PCTSignaturesSQFD create(int distanceFunction, int similarityFunction)
java: PCTSignaturesSQFD create(int distanceFunction)
java: PCTSignaturesSQFD create()
FUNC <float cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistance [ARG Mat _signature0=, ARG Mat _signature1=]>
java: float computeQuadraticFormDistance(Mat _signature0, Mat _signature1)
FUNC <void cv.xfeatures2d.PCTSignaturesSQFD.computeQuadraticFormDistances [ARG Mat sourceSignature=, ARG vector_Mat imageSignatures=, ARG vector_float distances=]>
java: void computeQuadraticFormDistances(Mat sourceSignature, List<Mat> imageSignatures, MatOfFloat distances)
CLASS cv.xfeatures2d::.SURF : Feature2D
FUNC <Ptr_SURF cv.xfeatures2d.SURF.create [ARG double hessianThreshold=100, ARG int nOctaves=4, ARG int nOctaveLayers=3, ARG bool extended=false, ARG bool upright=false]>
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers, boolean extended, boolean upright)
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers, boolean extended)
java: SURF create(double hessianThreshold, int nOctaves, int nOctaveLayers)
java: SURF create(double hessianThreshold, int nOctaves)
java: SURF create(double hessianThreshold)
java: SURF create()
FUNC <void cv.xfeatures2d.SURF.setHessianThreshold [ARG double hessianThreshold=]>
java: void setHessianThreshold(double hessianThreshold)
FUNC <double cv.xfeatures2d.SURF.getHessianThreshold []>
java: double getHessianThreshold()
FUNC <void cv.xfeatures2d.SURF.setNOctaves [ARG int nOctaves=]>
java: void setNOctaves(int nOctaves)
FUNC <int cv.xfeatures2d.SURF.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.xfeatures2d.SURF.setNOctaveLayers [ARG int nOctaveLayers=]>
java: void setNOctaveLayers(int nOctaveLayers)
FUNC <int cv.xfeatures2d.SURF.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <void cv.xfeatures2d.SURF.setExtended [ARG bool extended=]>
java: void setExtended(boolean extended)
FUNC <bool cv.xfeatures2d.SURF.getExtended []>
java: boolean getExtended()
FUNC <void cv.xfeatures2d.SURF.setUpright [ARG bool upright=]>
java: void setUpright(boolean upright)
FUNC <bool cv.xfeatures2d.SURF.getUpright []>
java: boolean getUpright()
FUNC <String cv.xfeatures2d.SURF.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.StarDetector : Feature2D
FUNC <Ptr_StarDetector cv.xfeatures2d.StarDetector.create [ARG int maxSize=45, ARG int responseThreshold=30, ARG int lineThresholdProjected=10, ARG int lineThresholdBinarized=8, ARG int suppressNonmaxSize=5]>
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected, int lineThresholdBinarized, int suppressNonmaxSize)
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected, int lineThresholdBinarized)
java: StarDetector create(int maxSize, int responseThreshold, int lineThresholdProjected)
java: StarDetector create(int maxSize, int responseThreshold)
java: StarDetector create(int maxSize)
java: StarDetector create()
FUNC <void cv.xfeatures2d.StarDetector.setMaxSize [ARG int _maxSize=]>
java: void setMaxSize(int _maxSize)
FUNC <int cv.xfeatures2d.StarDetector.getMaxSize []>
java: int getMaxSize()
FUNC <void cv.xfeatures2d.StarDetector.setResponseThreshold [ARG int _responseThreshold=]>
java: void setResponseThreshold(int _responseThreshold)
FUNC <int cv.xfeatures2d.StarDetector.getResponseThreshold []>
java: int getResponseThreshold()
FUNC <void cv.xfeatures2d.StarDetector.setLineThresholdProjected [ARG int _lineThresholdProjected=]>
java: void setLineThresholdProjected(int _lineThresholdProjected)
FUNC <int cv.xfeatures2d.StarDetector.getLineThresholdProjected []>
java: int getLineThresholdProjected()
FUNC <void cv.xfeatures2d.StarDetector.setLineThresholdBinarized [ARG int _lineThresholdBinarized=]>
java: void setLineThresholdBinarized(int _lineThresholdBinarized)
FUNC <int cv.xfeatures2d.StarDetector.getLineThresholdBinarized []>
java: int getLineThresholdBinarized()
FUNC <void cv.xfeatures2d.StarDetector.setSuppressNonmaxSize [ARG int _suppressNonmaxSize=]>
java: void setSuppressNonmaxSize(int _suppressNonmaxSize)
FUNC <int cv.xfeatures2d.StarDetector.getSuppressNonmaxSize []>
java: int getSuppressNonmaxSize()
FUNC <String cv.xfeatures2d.StarDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.TBMR : AffineFeature2D
FUNC <Ptr_TBMR cv.xfeatures2d.TBMR.create [ARG int min_area=60, ARG float max_area_relative=0.01f, ARG float scale_factor=1.25f, ARG int n_scales=-1]>
java: TBMR create(int min_area, float max_area_relative, float scale_factor, int n_scales)
java: TBMR create(int min_area, float max_area_relative, float scale_factor)
java: TBMR create(int min_area, float max_area_relative)
java: TBMR create(int min_area)
java: TBMR create()
FUNC <void cv.xfeatures2d.TBMR.setMinArea [ARG int minArea=]>
java: void setMinArea(int minArea)
FUNC <int cv.xfeatures2d.TBMR.getMinArea []>
java: int getMinArea()
FUNC <void cv.xfeatures2d.TBMR.setMaxAreaRelative [ARG float maxArea=]>
java: void setMaxAreaRelative(float maxArea)
FUNC <float cv.xfeatures2d.TBMR.getMaxAreaRelative []>
java: float getMaxAreaRelative()
FUNC <void cv.xfeatures2d.TBMR.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <float cv.xfeatures2d.TBMR.getScaleFactor []>
java: float getScaleFactor()
FUNC <void cv.xfeatures2d.TBMR.setNScales [ARG int n_scales=]>
java: void setNScales(int n_scales)
FUNC <int cv.xfeatures2d.TBMR.getNScales []>
java: int getNScales()
CLASS cv.xfeatures2d::.TEBLID : Feature2D
[CONST SIZE_256_BITS=102, CONST SIZE_512_BITS=103]
FUNC <Ptr_TEBLID cv.xfeatures2d.TEBLID.create [ARG float scale_factor=, ARG int n_bits=TEBLID::SIZE_256_BITS]>
java: TEBLID create(float scale_factor, int n_bits)
java: TEBLID create(float scale_factor)
FUNC <String cv.xfeatures2d.TEBLID.getDefaultName []>
java: String getDefaultName()
CLASS cv.xfeatures2d::.VGG : Feature2D
FUNC <Ptr_VGG cv.xfeatures2d.VGG.create [ARG int desc=VGG::VGG_120, ARG float isigma=1.4f, ARG bool img_normalize=true, ARG bool use_scale_orientation=true, ARG float scale_factor=6.25f, ARG bool dsc_normalize=false]>
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation, float scale_factor, boolean dsc_normalize)
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation, float scale_factor)
java: VGG create(int desc, float isigma, boolean img_normalize, boolean use_scale_orientation)
java: VGG create(int desc, float isigma, boolean img_normalize)
java: VGG create(int desc, float isigma)
java: VGG create(int desc)
java: VGG create()
FUNC <String cv.xfeatures2d.VGG.getDefaultName []>
java: String getDefaultName()
FUNC <void cv.xfeatures2d.VGG.setSigma [ARG float isigma=]>
java: void setSigma(float isigma)
FUNC <float cv.xfeatures2d.VGG.getSigma []>
java: float getSigma()
FUNC <void cv.xfeatures2d.VGG.setUseNormalizeImage [ARG bool img_normalize=]>
java: void setUseNormalizeImage(boolean img_normalize)
FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeImage []>
java: boolean getUseNormalizeImage()
FUNC <void cv.xfeatures2d.VGG.setUseScaleOrientation [ARG bool use_scale_orientation=]>
java: void setUseScaleOrientation(boolean use_scale_orientation)
FUNC <bool cv.xfeatures2d.VGG.getUseScaleOrientation []>
java: boolean getUseScaleOrientation()
FUNC <void cv.xfeatures2d.VGG.setScaleFactor [ARG float scale_factor=]>
java: void setScaleFactor(float scale_factor)
FUNC <float cv.xfeatures2d.VGG.getScaleFactor []>
java: float getScaleFactor()
FUNC <void cv.xfeatures2d.VGG.setUseNormalizeDescriptor [ARG bool dsc_normalize=]>
java: void setUseNormalizeDescriptor(boolean dsc_normalize)
FUNC <bool cv.xfeatures2d.VGG.getUseNormalizeDescriptor []>
java: boolean getUseNormalizeDescriptor()

=== MODULE: ximgproc (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc) ===


Files (27):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/slic.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/scansegment.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/radon_transform.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/ridgefilter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/peilin.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_drawing.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/segmentation.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/find_ellipses.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/deriche_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/seeds.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/color_match.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/lsc.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/disparity_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_filter.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgeboxes.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Ximgproc : , name: Ximgproc, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
[   'enum cv.ximgproc.ThinningTypes',
    '',
    [],
    [   ['const cv.ximgproc.THINNING_ZHANGSUEN', '0', [], [], None, ''],
        ['const cv.ximgproc.THINNING_GUOHALL', '1', [], [], None, '']],
    None]
ok: CONST THINNING_ZHANGSUEN=0
ok: CONST THINNING_GUOHALL=1

--- Incoming ---
[   'enum cv.ximgproc.LocalBinarizationMethods',
    '',
    [],
    [   ['const cv.ximgproc.BINARIZATION_NIBLACK', '0', [], [], None, ''],
        ['const cv.ximgproc.BINARIZATION_SAUVOLA', '1', [], [], None, ''],
        ['const cv.ximgproc.BINARIZATION_WOLF', '2', [], [], None, ''],
        ['const cv.ximgproc.BINARIZATION_NICK', '3', [], [], None, '']],
    None]
ok: CONST BINARIZATION_NIBLACK=0
ok: CONST BINARIZATION_SAUVOLA=1
ok: CONST BINARIZATION_WOLF=2
ok: CONST BINARIZATION_NICK=3

--- Incoming ---
[   'cv.ximgproc.niBlackThreshold',
    'void',
    [],
    [   ['Mat', '_src', '', []],
        ['Mat', '_dst', '', ['/O']],
        ['double', 'maxValue', '', []],
        ['int', 'type', '', []],
        ['int', 'blockSize', '', []],
        ['double', 'k', '', []],
        ['int', 'binarizationMethod', 'BINARIZATION_NIBLACK', []],
        ['double', 'r', '128', []]],
    'void']
ok: FUNC <void cv.ximgproc..niBlackThreshold [ARG Mat _src=, ARG Mat _dst=, ARG double maxValue=, ARG int type=, ARG int blockSize=, ARG double k=, ARG int binarizationMethod=BINARIZATION_NIBLACK, ARG double r=128]>

--- Incoming ---
[   'cv.ximgproc.thinning',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'thinningType', 'THINNING_ZHANGSUEN', []]],
    'void']
ok: FUNC <void cv.ximgproc..thinning [ARG Mat src=, ARG Mat dst=, ARG int thinningType=THINNING_ZHANGSUEN]>

--- Incoming ---
[   'cv.ximgproc.anisotropicDiffusion',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['float', 'alpha', '', []],
        ['float', 'K', '', []],
        ['int', 'niters', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..anisotropicDiffusion [ARG Mat src=, ARG Mat dst=, ARG float alpha=, ARG float K=, ARG int niters=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/slic.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
[   'enum cv.ximgproc.SLICType',
    '',
    [],
    [   ['const cv.ximgproc.SLIC', '100', [], [], None, ''],
        ['const cv.ximgproc.SLICO', '101', [], [], None, ''],
        ['const cv.ximgproc.MSLIC', '102', [], [], None, '']],
    None]
ok: CONST SLIC=100
ok: CONST SLICO=101
ok: CONST MSLIC=102

--- Incoming ---
['class cv.ximgproc.SuperpixelSLIC', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelSLIC : Algorithm, name: SuperpixelSLIC, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels []>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSLIC.iterate',
    'void',
    ['/V', '/PV'],
    [['int', 'num_iterations', '10', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.iterate [ARG int num_iterations=10]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSLIC.getLabels',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'labels_out', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSLIC.getLabelContourMask',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'image', '', ['/O']], ['bool', 'thick_line', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity',
    'void',
    ['/V', '/PV'],
    [['int', 'min_element_size', '25', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity [ARG int min_element_size=25]>

--- Incoming ---
[   'cv.ximgproc.createSuperpixelSLIC',
    'Ptr_SuperpixelSLIC',
    [],
    [   ['Mat', 'image', '', []],
        ['int', 'algorithm', 'SLICO', []],
        ['int', 'region_size', '10', []],
        ['float', 'ruler', '10.0f', []]],
    'Ptr<SuperpixelSLIC>']
ok: FUNC <Ptr_SuperpixelSLIC cv.ximgproc..createSuperpixelSLIC [ARG Mat image=, ARG int algorithm=SLICO, ARG int region_size=10, ARG float ruler=10.0f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
['class cv.ximgproc.SparseMatchInterpolator', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SparseMatchInterpolator : Algorithm, name: SparseMatchInterpolator, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.SparseMatchInterpolator.interpolate',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'from_image', '', []],
        ['Mat', 'from_points', '', []],
        ['Mat', 'to_image', '', []],
        ['Mat', 'to_points', '', []],
        ['Mat', 'dense_flow', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.SparseMatchInterpolator.interpolate [ARG Mat from_image=, ARG Mat from_points=, ARG Mat to_image=, ARG Mat to_points=, ARG Mat dense_flow=]>

--- Incoming ---
[   'class cv.ximgproc.EdgeAwareInterpolator',
    ': cv::ximgproc::SparseMatchInterpolator',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.EdgeAwareInterpolator : SparseMatchInterpolator, name: EdgeAwareInterpolator, base: SparseMatchInterpolator

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setCostMap',
    'void',
    ['/V', '/PV'],
    [['Mat', '_costMap', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setCostMap [ARG Mat _costMap=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setK',
    'void',
    ['/V', '/PV'],
    [['int', '_k', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setK [ARG int _k=]>

--- Incoming ---
['cv.ximgproc.EdgeAwareInterpolator.getK', 'int', ['/V', '/PV'], [], 'int']
ok: FUNC <int cv.ximgproc.EdgeAwareInterpolator.getK []>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setSigma',
    'void',
    ['/V', '/PV'],
    [['float', '_sigma', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setSigma [ARG float _sigma=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.getSigma',
    'float',
    ['/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getSigma []>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setLambda',
    'void',
    ['/V', '/PV'],
    [['float', '_lambda', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setLambda [ARG float _lambda=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.getLambda',
    'float',
    ['/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getLambda []>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing',
    'void',
    ['/V', '/PV'],
    [['bool', '_use_post_proc', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing [ARG bool _use_post_proc=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing',
    'bool',
    ['/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing []>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setFGSLambda',
    'void',
    ['/V', '/PV'],
    [['float', '_lambda', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSLambda [ARG float _lambda=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.getFGSLambda',
    'float',
    ['/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSLambda []>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.setFGSSigma',
    'void',
    ['/V', '/PV'],
    [['float', '_sigma', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSSigma [ARG float _sigma=]>

--- Incoming ---
[   'cv.ximgproc.EdgeAwareInterpolator.getFGSSigma',
    'float',
    ['/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSSigma []>

--- Incoming ---
[   'cv.ximgproc.createEdgeAwareInterpolator',
    'Ptr_EdgeAwareInterpolator',
    [],
    [],
    'Ptr<EdgeAwareInterpolator>']
ok: FUNC <Ptr_EdgeAwareInterpolator cv.ximgproc..createEdgeAwareInterpolator []>

--- Incoming ---
[   'class cv.ximgproc.RICInterpolator',
    ': cv::ximgproc::SparseMatchInterpolator',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.RICInterpolator : SparseMatchInterpolator, name: RICInterpolator, base: SparseMatchInterpolator

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setK',
    'void',
    ['/V', '/PV'],
    [['int', 'k', '32', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setK [ARG int k=32]>

--- Incoming ---
['cv.ximgproc.RICInterpolator.getK', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ximgproc.RICInterpolator.getK []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setCostMap',
    'void',
    ['/V', '/PV'],
    [['Mat', 'costMap', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setCostMap [ARG Mat costMap=]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setSuperpixelSize',
    'void',
    ['/V', '/PV'],
    [['int', 'spSize', '15', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelSize [ARG int spSize=15]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getSuperpixelSize',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelSize []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setSuperpixelNNCnt',
    'void',
    ['/V', '/PV'],
    [['int', 'spNN', '150', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelNNCnt [ARG int spNN=150]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getSuperpixelNNCnt',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelNNCnt []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setSuperpixelRuler',
    'void',
    ['/V', '/PV'],
    [['float', 'ruler', '15.f', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelRuler [ARG float ruler=15.f]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getSuperpixelRuler',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.RICInterpolator.getSuperpixelRuler []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setSuperpixelMode',
    'void',
    ['/V', '/PV'],
    [['int', 'mode', '100', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelMode [ARG int mode=100]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getSuperpixelMode',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelMode []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setAlpha',
    'void',
    ['/V', '/PV'],
    [['float', 'alpha', '0.7f', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setAlpha [ARG float alpha=0.7f]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getAlpha',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.RICInterpolator.getAlpha []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setModelIter',
    'void',
    ['/V', '/PV'],
    [['int', 'modelIter', '4', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setModelIter [ARG int modelIter=4]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getModelIter',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.RICInterpolator.getModelIter []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setRefineModels',
    'void',
    ['/V', '/PV'],
    [['bool', 'refineModles', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setRefineModels [ARG bool refineModles=true]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getRefineModels',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.ximgproc.RICInterpolator.getRefineModels []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setMaxFlow',
    'void',
    ['/V', '/PV'],
    [['float', 'maxFlow', '250.f', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setMaxFlow [ARG float maxFlow=250.f]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getMaxFlow',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.RICInterpolator.getMaxFlow []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setUseVariationalRefinement',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_variational_refinement', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setUseVariationalRefinement [ARG bool use_variational_refinement=false]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getUseVariationalRefinement',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.ximgproc.RICInterpolator.getUseVariationalRefinement []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setUseGlobalSmootherFilter',
    'void',
    ['/V', '/PV'],
    [['bool', 'use_FGS', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setUseGlobalSmootherFilter [ARG bool use_FGS=true]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getUseGlobalSmootherFilter',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.ximgproc.RICInterpolator.getUseGlobalSmootherFilter []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setFGSLambda',
    'void',
    ['/V', '/PV'],
    [['float', 'lambda', '500.f', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setFGSLambda [ARG float lambda=500.f]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getFGSLambda',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.RICInterpolator.getFGSLambda []>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.setFGSSigma',
    'void',
    ['/V', '/PV'],
    [['float', 'sigma', '1.5f', []]],
    'void']
ok: FUNC <void cv.ximgproc.RICInterpolator.setFGSSigma [ARG float sigma=1.5f]>

--- Incoming ---
[   'cv.ximgproc.RICInterpolator.getFGSSigma',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.RICInterpolator.getFGSSigma []>

--- Incoming ---
[   'cv.ximgproc.createRICInterpolator',
    'Ptr_RICInterpolator',
    [],
    [],
    'Ptr<RICInterpolator>']
ok: FUNC <Ptr_RICInterpolator cv.ximgproc..createRICInterpolator []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/scansegment.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
['class cv.ximgproc.ScanSegment', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.ScanSegment : Algorithm, name: ScanSegment, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.ScanSegment.getNumberOfSuperpixels',
    'int',
    ['/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.ScanSegment.getNumberOfSuperpixels []>

--- Incoming ---
[   'cv.ximgproc.ScanSegment.iterate',
    'void',
    ['/V', '/PV'],
    [['Mat', 'img', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.ScanSegment.iterate [ARG Mat img=]>

--- Incoming ---
[   'cv.ximgproc.ScanSegment.getLabels',
    'void',
    ['/V', '/PV'],
    [['Mat', 'labels_out', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.ScanSegment.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   'cv.ximgproc.ScanSegment.getLabelContourMask',
    'void',
    ['/V', '/PV'],
    [['Mat', 'image', '', ['/O']], ['bool', 'thick_line', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc.ScanSegment.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>

--- Incoming ---
[   'cv.ximgproc.createScanSegment',
    'Ptr_ScanSegment',
    [],
    [   ['int', 'image_width', '', []],
        ['int', 'image_height', '', []],
        ['int', 'num_superpixels', '', []],
        ['int', 'slices', '8', []],
        ['bool', 'merge_small', 'true', []]],
    'cv::Ptr<ScanSegment>']
ok: FUNC <Ptr_ScanSegment cv.ximgproc..createScanSegment [ARG int image_width=, ARG int image_height=, ARG int num_superpixels=, ARG int slices=8, ARG bool merge_small=true]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp =====
Namespaces: ['cv', 'cv.ximgproc']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/brightedges.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/radon_transform.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
[   'cv.ximgproc.RadonTransform',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'theta', '1', []],
        ['double', 'start_angle', '0', []],
        ['double', 'end_angle', '180', []],
        ['bool', 'crop', 'false', []],
        ['bool', 'norm', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc..RadonTransform [ARG Mat src=, ARG Mat dst=, ARG double theta=1, ARG double start_angle=0, ARG double end_angle=180, ARG bool crop=false, ARG bool norm=false]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/ridgefilter.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
['class cv.ximgproc.RidgeDetectionFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.RidgeDetectionFilter : Algorithm, name: RidgeDetectionFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.RidgeDetectionFilter.create',
    'Ptr_RidgeDetectionFilter',
    ['/S'],
    [   ['int', 'ddepth', 'CV_32FC1', []],
        ['int', 'dx', '1', []],
        ['int', 'dy', '1', []],
        ['int', 'ksize', '3', []],
        ['int', 'out_dtype', 'CV_8UC1', []],
        ['double', 'scale', '1', []],
        ['double', 'delta', '0', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'Ptr<RidgeDetectionFilter>']
ok: FUNC <Ptr_RidgeDetectionFilter cv.ximgproc.RidgeDetectionFilter.create [ARG int ddepth=CV_32FC1, ARG int dx=1, ARG int dy=1, ARG int ksize=3, ARG int out_dtype=CV_8UC1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage',
    'void',
    ['/V', '/PV'],
    [['Mat', '_img', '', []], ['Mat', 'out', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage [ARG Mat _img=, ARG Mat out=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_line_detector.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
['class cv.ximgproc.FastLineDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.FastLineDetector : Algorithm, name: FastLineDetector, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.FastLineDetector.detect',
    'void',
    ['/V', '/PV'],
    [['Mat', 'image', '', []], ['Mat', 'lines', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.FastLineDetector.detect [ARG Mat image=, ARG Mat lines=]>

--- Incoming ---
[   'cv.ximgproc.FastLineDetector.drawSegments',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', ['/IO']],
        ['Mat', 'lines', '', []],
        ['bool', 'draw_arrow', 'false', []],
        ['Scalar', 'linecolor', 'Scalar(0, 0, 255)', []],
        ['int', 'linethickness', '1', []]],
    'void']
ok: FUNC <void cv.ximgproc.FastLineDetector.drawSegments [ARG Mat image=, ARG Mat lines=, ARG bool draw_arrow=false, ARG Scalar linecolor=Scalar(0, 0, 255), ARG int linethickness=1]>

--- Incoming ---
[   'cv.ximgproc.createFastLineDetector',
    'Ptr_FastLineDetector',
    [],
    [   ['int', 'length_threshold', '10', []],
        ['float', 'distance_threshold', '1.414213562f', []],
        ['double', 'canny_th1', '50.0', []],
        ['double', 'canny_th2', '50.0', []],
        ['int', 'canny_aperture_size', '3', []],
        ['bool', 'do_merge', 'false', []]],
    'Ptr<FastLineDetector>']
ok: FUNC <Ptr_FastLineDetector cv.ximgproc..createFastLineDetector [ARG int length_threshold=10, ARG float distance_threshold=1.414213562f, ARG double canny_th1=50.0, ARG double canny_th2=50.0, ARG int canny_aperture_size=3, ARG bool do_merge=false]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/peilin.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
[   'cv.ximgproc.PeiLinNormalization',
    'void',
    [],
    [['Mat', 'I', '', []], ['Mat', 'T', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..PeiLinNormalization [ARG Mat I=, ARG Mat T=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_drawing.hpp =====
Namespaces: ['cv', 'cv.ximgproc']

--- Incoming ---
['class cv.ximgproc.EdgeDrawing', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.EdgeDrawing : Algorithm, name: EdgeDrawing, base: Algorithm

--- Incoming ---
[   'enum cv.ximgproc.EdgeDrawing.GradientOperator',
    '',
    [],
    [   ['const cv.ximgproc.EdgeDrawing.PREWITT', '0', [], [], None, ''],
        ['const cv.ximgproc.EdgeDrawing.SOBEL', '1', [], [], None, ''],
        ['const cv.ximgproc.EdgeDrawing.SCHARR', '2', [], [], None, ''],
        ['const cv.ximgproc.EdgeDrawing.LSD', '3', [], [], None, '']],
    None]
ok: CONST PREWITT=0
ok: CONST SOBEL=1
ok: CONST SCHARR=2
ok: CONST LSD=3

--- Incoming ---
[   'struct cv.ximgproc.EdgeDrawing.Params',
    '',
    ['/Simple'],
    [   ['bool', 'PFmode', '', ['/RW']],
        ['int', 'EdgeDetectionOperator', '', ['/RW']],
        ['int', 'GradientThresholdValue', '', ['/RW']],
        ['int', 'AnchorThresholdValue', '', ['/RW']],
        ['int', 'ScanInterval', '', ['/RW']],
        ['int', 'MinPathLength', '', ['/RW']],
        ['float', 'Sigma', '', ['/RW']],
        ['bool', 'SumFlag', '', ['/RW']],
        ['bool', 'NFAValidation', '', ['/RW']],
        ['int', 'MinLineLength', '', ['/RW']],
        ['double', 'MaxDistanceBetweenTwoLines', '', ['/RW']],
        ['double', 'LineFitErrorThreshold', '', ['/RW']],
        ['double', 'MaxErrorThreshold', '', ['/RW']]],
    None]
ok: class CLASS cv.ximgproc::EdgeDrawing.EdgeDrawing_Params : , name: EdgeDrawing_Params, base: 

--- Incoming ---
['cv.ximgproc.EdgeDrawing.Params.Params', '', [], [], None]
ok: FUNC < cv.ximgproc.EdgeDrawing.Params.EdgeDrawing_Params []>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.detectEdges',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.detectEdges [ARG Mat src=]>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.getEdgeImage',
    'void',
    ['/V', '/PV'],
    [['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.getEdgeImage [ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.getGradientImage',
    'void',
    ['/V', '/PV'],
    [['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.getGradientImage [ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.getSegments',
    'vector_vector_Point',
    ['/V', '/PV'],
    [],
    'std::vector<std::vector<Point> >']
ok: FUNC <vector_vector_Point cv.ximgproc.EdgeDrawing.getSegments []>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.getSegmentIndicesOfLines',
    'vector_int',
    ['/C', '/V', '/PV'],
    [],
    'std::vector<int>']
ok: FUNC <vector_int cv.ximgproc.EdgeDrawing.getSegmentIndicesOfLines []>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.detectLines',
    'void',
    ['/V', '/PV'],
    [['Mat', 'lines', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.detectLines [ARG Mat lines=]>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.detectEllipses',
    'void',
    ['/V', '/PV'],
    [['Mat', 'ellipses', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.detectEllipses [ARG Mat ellipses=]>

--- Incoming ---
[   'cv.ximgproc.EdgeDrawing.setParams',
    'void',
    [],
    [['EdgeDrawing_Params', 'parameters', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeDrawing.setParams [ARG EdgeDrawing_Params parameters=]>

--- Incoming ---
['cv.ximgproc.createEdgeDrawing', 'Ptr_EdgeDrawing', [], [], 'Ptr<EdgeDrawing>']
ok: FUNC <Ptr_EdgeDrawing cv.ximgproc..createEdgeDrawing []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/run_length_morphology.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/segmentation.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'class cv.ximgproc.segmentation.GraphSegmentation',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.GraphSegmentation : Algorithm, name: GraphSegmentation, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.processImage',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.processImage [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.setSigma',
    'void',
    ['/V', '/PV'],
    [['double', 'sigma', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setSigma [ARG double sigma=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.getSigma',
    'double',
    ['/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ximgproc.segmentation.GraphSegmentation.getSigma []>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.setK',
    'void',
    ['/V', '/PV'],
    [['float', 'k', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setK [ARG float k=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.getK',
    'float',
    ['/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.segmentation.GraphSegmentation.getK []>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.setMinSize',
    'void',
    ['/V', '/PV'],
    [['int', 'min_size', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setMinSize [ARG int min_size=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.GraphSegmentation.getMinSize',
    'int',
    ['/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.segmentation.GraphSegmentation.getMinSize []>

--- Incoming ---
[   'cv.ximgproc.segmentation.createGraphSegmentation',
    'Ptr_GraphSegmentation',
    [],
    [   ['double', 'sigma', '0.5', []],
        ['float', 'k', '300', []],
        ['int', 'min_size', '100', []]],
    'Ptr<GraphSegmentation>']
ok: FUNC <Ptr_GraphSegmentation cv.ximgproc.segmentation..createGraphSegmentation [ARG double sigma=0.5, ARG float k=300, ARG int min_size=100]>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategy : Algorithm, name: SelectiveSearchSegmentationStrategy, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'img', '', []],
        ['Mat', 'regions', '', []],
        ['Mat', 'sizes', '', []],
        ['int', 'image_id', '-1', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage [ARG Mat img=, ARG Mat regions=, ARG Mat sizes=, ARG int image_id=-1]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get',
    'float',
    ['/V', '/PV'],
    [['int', 'r1', '', []], ['int', 'r2', '', []]],
    'float']
ok: FUNC <float cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get [ARG int r1=, ARG int r2=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge',
    'void',
    ['/V', '/PV'],
    [['int', 'r1', '', []], ['int', 'r2', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge [ARG int r1=, ARG int r2=]>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyColor',
    ': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyColor : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyColor, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyColor',
    'Ptr_SelectiveSearchSegmentationStrategyColor',
    [],
    [],
    'Ptr<SelectiveSearchSegmentationStrategyColor>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyColor cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyColor []>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategySize',
    ': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategySize : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategySize, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategySize',
    'Ptr_SelectiveSearchSegmentationStrategySize',
    [],
    [],
    'Ptr<SelectiveSearchSegmentationStrategySize>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategySize cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategySize []>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyTexture',
    ': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyTexture : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyTexture, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyTexture',
    'Ptr_SelectiveSearchSegmentationStrategyTexture',
    [],
    [],
    'Ptr<SelectiveSearchSegmentationStrategyTexture>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyTexture cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyTexture []>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyFill',
    ': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyFill : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyFill, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyFill',
    'Ptr_SelectiveSearchSegmentationStrategyFill',
    [],
    [],
    'Ptr<SelectiveSearchSegmentationStrategyFill>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyFill cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyFill []>

--- Incoming ---
[   'class '
    'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple',
    ': cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyMultiple : SelectiveSearchSegmentationStrategy, name: SelectiveSearchSegmentationStrategyMultiple, base: SelectiveSearchSegmentationStrategy

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy',
    'void',
    ['/V', '/PV'],
    [   ['Ptr_SelectiveSearchSegmentationStrategy', 'g', '', []],
        ['float', 'weight', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy g=, ARG float weight=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies',
    'void',
    ['/V', '/PV'],
    [],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies []>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [],
    'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple []>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [['Ptr_SelectiveSearchSegmentationStrategy', 's1', '', []]],
    'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   ['Ptr_SelectiveSearchSegmentationStrategy', 's1', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's2', '', []]],
    'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   ['Ptr_SelectiveSearchSegmentationStrategy', 's1', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's2', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's3', '', []]],
    'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentationStrategyMultiple',
    'Ptr_SelectiveSearchSegmentationStrategyMultiple',
    [],
    [   ['Ptr_SelectiveSearchSegmentationStrategy', 's1', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's2', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's3', '', []],
        ['Ptr_SelectiveSearchSegmentationStrategy', 's4', '', []]],
    'Ptr<SelectiveSearchSegmentationStrategyMultiple>']
ok: FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=, ARG Ptr_SelectiveSearchSegmentationStrategy s4=]>

--- Incoming ---
[   'class cv.ximgproc.segmentation.SelectiveSearchSegmentation',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentation : Algorithm, name: SelectiveSearchSegmentation, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage',
    'void',
    ['/V', '/PV'],
    [['Mat', 'img', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage [ARG Mat img=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy',
    'void',
    ['/V', '/PV'],
    [['int', 'k', '200', []], ['float', 'sigma', '0.8f', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy [ARG int k=200, ARG float sigma=0.8f]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast',
    'void',
    ['/V', '/PV'],
    [   ['int', 'base_k', '150', []],
        ['int', 'inc_k', '150', []],
        ['float', 'sigma', '0.8f', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality',
    'void',
    ['/V', '/PV'],
    [   ['int', 'base_k', '150', []],
        ['int', 'inc_k', '150', []],
        ['float', 'sigma', '0.8f', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage',
    'void',
    ['/V', '/PV'],
    [['Mat', 'img', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage [ARG Mat img=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages',
    'void',
    ['/V', '/PV'],
    [],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages []>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation',
    'void',
    ['/V', '/PV'],
    [['Ptr_GraphSegmentation', 'g', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation [ARG Ptr_GraphSegmentation g=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations',
    'void',
    ['/V', '/PV'],
    [],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations []>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy',
    'void',
    ['/V', '/PV'],
    [['Ptr_SelectiveSearchSegmentationStrategy', 's', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy s=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies',
    'void',
    ['/V', '/PV'],
    [],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies []>

--- Incoming ---
[   'cv.ximgproc.segmentation.SelectiveSearchSegmentation.process',
    'void',
    ['/V', '/PV'],
    [['vector_Rect', 'rects', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.process [ARG vector_Rect rects=]>

--- Incoming ---
[   'cv.ximgproc.segmentation.createSelectiveSearchSegmentation',
    'Ptr_SelectiveSearchSegmentation',
    [],
    [],
    'Ptr<SelectiveSearchSegmentation>']
ok: FUNC <Ptr_SelectiveSearchSegmentation cv.ximgproc.segmentation..createSelectiveSearchSegmentation []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fast_hough_transform.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'enum cv.ximgproc.AngleRangeOption',
    '',
    [],
    [   ['const cv.ximgproc.ARO_0_45', '0', [], [], None, ''],
        ['const cv.ximgproc.ARO_45_90', '1', [], [], None, ''],
        ['const cv.ximgproc.ARO_90_135', '2', [], [], None, ''],
        ['const cv.ximgproc.ARO_315_0', '3', [], [], None, ''],
        ['const cv.ximgproc.ARO_315_45', '4', [], [], None, ''],
        ['const cv.ximgproc.ARO_45_135', '5', [], [], None, ''],
        ['const cv.ximgproc.ARO_315_135', '6', [], [], None, ''],
        ['const cv.ximgproc.ARO_CTR_HOR', '7', [], [], None, ''],
        ['const cv.ximgproc.ARO_CTR_VER', '8', [], [], None, '']],
    None]
ok: CONST ARO_0_45=0
ok: CONST ARO_45_90=1
ok: CONST ARO_90_135=2
ok: CONST ARO_315_0=3
ok: CONST ARO_315_45=4
ok: CONST ARO_45_135=5
ok: CONST ARO_315_135=6
ok: CONST ARO_CTR_HOR=7
ok: CONST ARO_CTR_VER=8

--- Incoming ---
[   'enum cv.ximgproc.HoughOp',
    '',
    [],
    [   ['const cv.ximgproc.FHT_MIN', '0', [], [], None, ''],
        ['const cv.ximgproc.FHT_MAX', '1', [], [], None, ''],
        ['const cv.ximgproc.FHT_ADD', '2', [], [], None, ''],
        ['const cv.ximgproc.FHT_AVE', '3', [], [], None, '']],
    None]
ok: CONST FHT_MIN=0
ok: CONST FHT_MAX=1
ok: CONST FHT_ADD=2
ok: CONST FHT_AVE=3

--- Incoming ---
[   'enum cv.ximgproc.HoughDeskewOption',
    '',
    [],
    [   ['const cv.ximgproc.HDO_RAW', '0', [], [], None, ''],
        ['const cv.ximgproc.HDO_DESKEW', '1', [], [], None, '']],
    None]
ok: CONST HDO_RAW=0
ok: CONST HDO_DESKEW=1

--- Incoming ---
[   'cv.ximgproc.FastHoughTransform',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dstMatDepth', '', []],
        ['int', 'angleRange', 'ARO_315_135', []],
        ['int', 'op', 'FHT_ADD', []],
        ['int', 'makeSkew', 'HDO_DESKEW', []]],
    'void']
ok: FUNC <void cv.ximgproc..FastHoughTransform [ARG Mat src=, ARG Mat dst=, ARG int dstMatDepth=, ARG int angleRange=ARO_315_135, ARG int op=FHT_ADD, ARG int makeSkew=HDO_DESKEW]>

--- Incoming ---
[   'cv.ximgproc.HoughPoint2Line',
    'Vec4i',
    [],
    [   ['Point', 'houghPoint', '', ['/C', '/Ref']],
        ['Mat', 'srcImgInfo', '', []],
        ['int', 'angleRange', 'ARO_315_135', []],
        ['int', 'makeSkew', 'HDO_DESKEW', []],
        ['int', 'rules', 'RO_IGNORE_BORDERS', []]],
    'Vec4i']
ok: FUNC <Vec4i cv.ximgproc..HoughPoint2Line [ARG Point houghPoint=, ARG Mat srcImgInfo=, ARG int angleRange=ARO_315_135, ARG int makeSkew=HDO_DESKEW, ARG int rules=RO_IGNORE_BORDERS]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/find_ellipses.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'cv.ximgproc.findEllipses',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'ellipses', '', ['/O']],
        ['float', 'scoreThreshold', '0.7f', []],
        ['float', 'reliabilityThreshold', '0.5f', []],
        ['float', 'centerDistanceThreshold', '0.05f', []]],
    'void']
ok: FUNC <void cv.ximgproc..findEllipses [ARG Mat image=, ARG Mat ellipses=, ARG float scoreThreshold=0.7f, ARG float reliabilityThreshold=0.5f, ARG float centerDistanceThreshold=0.05f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/deriche_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'cv.ximgproc.GradientDericheY',
    'void',
    [],
    [   ['Mat', 'op', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'alpha', '', []],
        ['double', 'omega', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..GradientDericheY [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>

--- Incoming ---
[   'cv.ximgproc.GradientDericheX',
    'void',
    [],
    [   ['Mat', 'op', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'alpha', '', []],
        ['double', 'omega', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..GradientDericheX [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/weighted_median_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'enum cv.ximgproc.WMFWeightType',
    '',
    [],
    [   ['const cv.ximgproc.WMF_EXP', '1', [], [], None, ''],
        ['const cv.ximgproc.WMF_IV1', '1 << 1', [], [], None, ''],
        ['const cv.ximgproc.WMF_IV2', '1 << 2', [], [], None, ''],
        ['const cv.ximgproc.WMF_COS', '1 << 3', [], [], None, ''],
        ['const cv.ximgproc.WMF_JAC', '1 << 4', [], [], None, ''],
        ['const cv.ximgproc.WMF_OFF', '1 << 5', [], [], None, '']],
    None]
ok: CONST WMF_EXP=1
ok: CONST WMF_IV1=1 << 1
ok: CONST WMF_IV2=1 << 2
ok: CONST WMF_COS=1 << 3
ok: CONST WMF_JAC=1 << 4
ok: CONST WMF_OFF=1 << 5

--- Incoming ---
[   'cv.ximgproc.weightedMedianFilter',
    'void',
    [],
    [   ['Mat', 'joint', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'r', '', []],
        ['double', 'sigma', '25.5', []],
        ['int', 'weightType', 'WMF_EXP', []],
        ['Mat', 'mask', 'Mat()', []]],
    'void']
ok: FUNC <void cv.ximgproc..weightedMedianFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int r=, ARG double sigma=25.5, ARG int weightType=WMF_EXP, ARG Mat mask=Mat()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/estimated_covariance.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'cv.ximgproc.covarianceEstimation',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'windowRows', '', []],
        ['int', 'windowCols', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..covarianceEstimation [ARG Mat src=, ARG Mat dst=, ARG int windowRows=, ARG int windowCols=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/structured_edge_detection.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.RFFeatureGetter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.RFFeatureGetter : Algorithm, name: RFFeatureGetter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.RFFeatureGetter.getFeatures',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'src', '', ['/C', '/Ref']],
        ['Mat', 'features', '', ['/Ref']],
        ['int', 'gnrmRad', '', ['/C']],
        ['int', 'gsmthRad', '', ['/C']],
        ['int', 'shrink', '', ['/C']],
        ['int', 'outNum', '', ['/C']],
        ['int', 'gradNum', '', ['/C']]],
    'void']
ok: FUNC <void cv.ximgproc.RFFeatureGetter.getFeatures [ARG Mat src=, ARG Mat features=, ARG int gnrmRad=, ARG int gsmthRad=, ARG int shrink=, ARG int outNum=, ARG int gradNum=]>

--- Incoming ---
[   'cv.ximgproc.createRFFeatureGetter',
    'Ptr_RFFeatureGetter',
    [],
    [],
    'Ptr<RFFeatureGetter>']
ok: FUNC <Ptr_RFFeatureGetter cv.ximgproc..createRFFeatureGetter []>

--- Incoming ---
['class cv.ximgproc.StructuredEdgeDetection', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.StructuredEdgeDetection : Algorithm, name: StructuredEdgeDetection, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.StructuredEdgeDetection.detectEdges',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.detectEdges [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.StructuredEdgeDetection.computeOrientation',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.computeOrientation [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.StructuredEdgeDetection.edgesNms',
    'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', 'edge_image', '', []],
        ['Mat', 'orientation_image', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'r', '2', []],
        ['int', 's', '0', []],
        ['float', 'm', '1', []],
        ['bool', 'isParallel', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc.StructuredEdgeDetection.edgesNms [ARG Mat edge_image=, ARG Mat orientation_image=, ARG Mat dst=, ARG int r=2, ARG int s=0, ARG float m=1, ARG bool isParallel=true]>

--- Incoming ---
[   'cv.ximgproc.createStructuredEdgeDetection',
    'Ptr_StructuredEdgeDetection',
    [],
    [   ['String', 'model', '', ['/C', '/Ref']],
        [   'Ptr_RFFeatureGetter',
            'howToGetFeatures',
            'Ptr<RFFeatureGetter>()',
            ['/C']]],
    'Ptr<StructuredEdgeDetection>']
ok: FUNC <Ptr_StructuredEdgeDetection cv.ximgproc..createStructuredEdgeDetection [ARG String model=, ARG Ptr_RFFeatureGetter howToGetFeatures=Ptr<RFFeatureGetter>()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/fourier_descriptors.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.ContourFitting', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.ContourFitting : Algorithm, name: ContourFitting, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.ContourFitting.estimateTransformation',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['Mat', 'alphaPhiST', '', ['/O']],
        ['double', 'dist', '', ['/O', '/Ref']],
        ['bool', 'fdContour', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc.ContourFitting.estimateTransformation [ARG Mat src=, ARG Mat dst=, ARG Mat alphaPhiST=, ARG double dist=, ARG bool fdContour=false]>

--- Incoming ---
[   'cv.ximgproc.ContourFitting.setCtrSize',
    'void',
    [],
    [['int', 'n', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.ContourFitting.setCtrSize [ARG int n=]>

--- Incoming ---
[   'cv.ximgproc.ContourFitting.setFDSize',
    'void',
    [],
    [['int', 'n', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.ContourFitting.setFDSize [ARG int n=]>

--- Incoming ---
['cv.ximgproc.ContourFitting.getCtrSize', 'int', [], [], 'int']
ok: FUNC <int cv.ximgproc.ContourFitting.getCtrSize []>

--- Incoming ---
['cv.ximgproc.ContourFitting.getFDSize', 'int', [], [], 'int']
ok: FUNC <int cv.ximgproc.ContourFitting.getFDSize []>

--- Incoming ---
[   'cv.ximgproc.fourierDescriptor',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'nbElt', '-1', []],
        ['int', 'nbFD', '-1', []]],
    'void']
ok: FUNC <void cv.ximgproc..fourierDescriptor [ARG Mat src=, ARG Mat dst=, ARG int nbElt=-1, ARG int nbFD=-1]>

--- Incoming ---
[   'cv.ximgproc.transformFD',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 't', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['bool', 'fdContour', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc..transformFD [ARG Mat src=, ARG Mat t=, ARG Mat dst=, ARG bool fdContour=true]>

--- Incoming ---
[   'cv.ximgproc.contourSampling',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'out', '', ['/O']],
        ['int', 'nbElt', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..contourSampling [ARG Mat src=, ARG Mat out=, ARG int nbElt=]>

--- Incoming ---
[   'cv.ximgproc.createContourFitting',
    'Ptr_ContourFitting',
    [],
    [['int', 'ctr', '1024', []], ['int', 'fd', '16', []]],
    'Ptr<ContourFitting>']
ok: FUNC <Ptr_ContourFitting cv.ximgproc..createContourFitting [ARG int ctr=1024, ARG int fd=16]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgepreserving_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'cv.ximgproc.edgePreservingFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'd', '', []],
        ['double', 'threshold', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double threshold=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/seeds.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.SuperpixelSEEDS', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelSEEDS : Algorithm, name: SuperpixelSEEDS, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels',
    'int',
    ['/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels []>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSEEDS.iterate',
    'void',
    ['/V', '/PV'],
    [['Mat', 'img', '', []], ['int', 'num_iterations', '4', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.iterate [ARG Mat img=, ARG int num_iterations=4]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSEEDS.getLabels',
    'void',
    ['/V', '/PV'],
    [['Mat', 'labels_out', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelSEEDS.getLabelContourMask',
    'void',
    ['/V', '/PV'],
    [['Mat', 'image', '', ['/O']], ['bool', 'thick_line', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>

--- Incoming ---
[   'cv.ximgproc.createSuperpixelSEEDS',
    'Ptr_SuperpixelSEEDS',
    [],
    [   ['int', 'image_width', '', []],
        ['int', 'image_height', '', []],
        ['int', 'image_channels', '', []],
        ['int', 'num_superpixels', '', []],
        ['int', 'num_levels', '', []],
        ['int', 'prior', '2', []],
        ['int', 'histogram_bins', '5', []],
        ['bool', 'double_step', 'false', []]],
    'Ptr<SuperpixelSEEDS>']
ok: FUNC <Ptr_SuperpixelSEEDS cv.ximgproc..createSuperpixelSEEDS [ARG int image_width=, ARG int image_height=, ARG int image_channels=, ARG int num_superpixels=, ARG int num_levels=, ARG int prior=2, ARG int histogram_bins=5, ARG bool double_step=false]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/color_match.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'cv.ximgproc.createQuaternionImage',
    'void',
    [],
    [['Mat', 'img', '', []], ['Mat', 'qimg', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..createQuaternionImage [ARG Mat img=, ARG Mat qimg=]>

--- Incoming ---
[   'cv.ximgproc.qconj',
    'void',
    [],
    [['Mat', 'qimg', '', []], ['Mat', 'qcimg', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..qconj [ARG Mat qimg=, ARG Mat qcimg=]>

--- Incoming ---
[   'cv.ximgproc.qunitary',
    'void',
    [],
    [['Mat', 'qimg', '', []], ['Mat', 'qnimg', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..qunitary [ARG Mat qimg=, ARG Mat qnimg=]>

--- Incoming ---
[   'cv.ximgproc.qmultiply',
    'void',
    [],
    [   ['Mat', 'src1', '', []],
        ['Mat', 'src2', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..qmultiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.qdft',
    'void',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'qimg', '', ['/O']],
        ['int', 'flags', '', []],
        ['bool', 'sideLeft', '', []]],
    'void']
ok: FUNC <void cv.ximgproc..qdft [ARG Mat img=, ARG Mat qimg=, ARG int flags=, ARG bool sideLeft=]>

--- Incoming ---
[   'cv.ximgproc.colorMatchTemplate',
    'void',
    [],
    [   ['Mat', 'img', '', []],
        ['Mat', 'templ', '', []],
        ['Mat', 'result', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc..colorMatchTemplate [ARG Mat img=, ARG Mat templ=, ARG Mat result=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/lsc.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.SuperpixelLSC', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.SuperpixelLSC : Algorithm, name: SuperpixelLSC, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels []>

--- Incoming ---
[   'cv.ximgproc.SuperpixelLSC.iterate',
    'void',
    ['/V', '/PV'],
    [['int', 'num_iterations', '10', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.iterate [ARG int num_iterations=10]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelLSC.getLabels',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'labels_out', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.getLabels [ARG Mat labels_out=]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelLSC.getLabelContourMask',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'image', '', ['/O']], ['bool', 'thick_line', 'true', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>

--- Incoming ---
[   'cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity',
    'void',
    ['/V', '/PV'],
    [['int', 'min_element_size', '25', []]],
    'void']
ok: FUNC <void cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity [ARG int min_element_size=25]>

--- Incoming ---
[   'cv.ximgproc.createSuperpixelLSC',
    'Ptr_SuperpixelLSC',
    [],
    [   ['Mat', 'image', '', []],
        ['int', 'region_size', '10', []],
        ['float', 'ratio', '0.075f', []]],
    'Ptr<SuperpixelLSC>']
ok: FUNC <Ptr_SuperpixelLSC cv.ximgproc..createSuperpixelLSC [ARG Mat image=, ARG int region_size=10, ARG float ratio=0.075f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/disparity_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.DisparityFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.DisparityFilter : Algorithm, name: DisparityFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.DisparityFilter.filter',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'disparity_map_left', '', []],
        ['Mat', 'left_view', '', []],
        ['Mat', 'filtered_disparity_map', '', ['/O']],
        ['Mat', 'disparity_map_right', 'Mat()', []],
        ['Rect', 'ROI', 'Rect()', []],
        ['Mat', 'right_view', 'Mat()', []]],
    'void']
ok: FUNC <void cv.ximgproc.DisparityFilter.filter [ARG Mat disparity_map_left=, ARG Mat left_view=, ARG Mat filtered_disparity_map=, ARG Mat disparity_map_right=Mat(), ARG Rect ROI=Rect(), ARG Mat right_view=Mat()]>

--- Incoming ---
[   'class cv.ximgproc.DisparityWLSFilter',
    ': cv::ximgproc::DisparityFilter',
    [],
    [],
    None]
ok: class CLASS cv.ximgproc::.DisparityWLSFilter : DisparityFilter, name: DisparityWLSFilter, base: DisparityFilter

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.getLambda',
    'double',
    ['/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ximgproc.DisparityWLSFilter.getLambda []>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.setLambda',
    'void',
    ['/V', '/PV'],
    [['double', '_lambda', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setLambda [ARG double _lambda=]>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.getSigmaColor',
    'double',
    ['/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.ximgproc.DisparityWLSFilter.getSigmaColor []>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.setSigmaColor',
    'void',
    ['/V', '/PV'],
    [['double', '_sigma_color', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setSigmaColor [ARG double _sigma_color=]>

--- Incoming ---
['cv.ximgproc.DisparityWLSFilter.getLRCthresh', 'int', ['/V', '/PV'], [], 'int']
ok: FUNC <int cv.ximgproc.DisparityWLSFilter.getLRCthresh []>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.setLRCthresh',
    'void',
    ['/V', '/PV'],
    [['int', '_LRC_thresh', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setLRCthresh [ARG int _LRC_thresh=]>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius',
    'int',
    ['/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius []>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius',
    'void',
    ['/V', '/PV'],
    [['int', '_disc_radius', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius [ARG int _disc_radius=]>

--- Incoming ---
[   'cv.ximgproc.DisparityWLSFilter.getConfidenceMap',
    'Mat',
    ['/V', '/PV'],
    [],
    'Mat']
ok: FUNC <Mat cv.ximgproc.DisparityWLSFilter.getConfidenceMap []>

--- Incoming ---
['cv.ximgproc.DisparityWLSFilter.getROI', 'Rect', ['/V', '/PV'], [], 'Rect']
ok: FUNC <Rect cv.ximgproc.DisparityWLSFilter.getROI []>

--- Incoming ---
[   'cv.ximgproc.createDisparityWLSFilter',
    'Ptr_DisparityWLSFilter',
    [],
    [['Ptr_StereoMatcher', 'matcher_left', '', []]],
    'Ptr<DisparityWLSFilter>']
ok: FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilter [ARG Ptr_StereoMatcher matcher_left=]>

--- Incoming ---
[   'cv.ximgproc.createRightMatcher',
    'Ptr_StereoMatcher',
    [],
    [['Ptr_StereoMatcher', 'matcher_left', '', []]],
    'Ptr<StereoMatcher>']
ok: FUNC <Ptr_StereoMatcher cv.ximgproc..createRightMatcher [ARG Ptr_StereoMatcher matcher_left=]>

--- Incoming ---
[   'cv.ximgproc.createDisparityWLSFilterGeneric',
    'Ptr_DisparityWLSFilter',
    [],
    [['bool', 'use_confidence', '', []]],
    'Ptr<DisparityWLSFilter>']
ok: FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilterGeneric [ARG bool use_confidence=]>

--- Incoming ---
[   'cv.ximgproc.readGT',
    'int',
    [],
    [['String', 'src_path', '', []], ['Mat', 'dst', '', ['/O']]],
    'int']
ok: FUNC <int cv.ximgproc..readGT [ARG String src_path=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.computeMSE',
    'double',
    [],
    [['Mat', 'GT', '', []], ['Mat', 'src', '', []], ['Rect', 'ROI', '', []]],
    'double']
ok: FUNC <double cv.ximgproc..computeMSE [ARG Mat GT=, ARG Mat src=, ARG Rect ROI=]>

--- Incoming ---
[   'cv.ximgproc.computeBadPixelPercent',
    'double',
    [],
    [   ['Mat', 'GT', '', []],
        ['Mat', 'src', '', []],
        ['Rect', 'ROI', '', []],
        ['int', 'thresh', '24', []]],
    'double']
ok: FUNC <double cv.ximgproc..computeBadPixelPercent [ARG Mat GT=, ARG Mat src=, ARG Rect ROI=, ARG int thresh=24]>

--- Incoming ---
[   'cv.ximgproc.getDisparityVis',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'scale', '1.0', []]],
    'void']
ok: FUNC <void cv.ximgproc..getDisparityVis [ARG Mat src=, ARG Mat dst=, ARG double scale=1.0]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edge_filter.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
[   'enum cv.ximgproc.EdgeAwareFiltersList',
    '',
    [],
    [   ['const cv.ximgproc.DTF_NC', '0', [], [], None, ''],
        ['const cv.ximgproc.DTF_IC', '1', [], [], None, ''],
        ['const cv.ximgproc.DTF_RF', '2', [], [], None, ''],
        ['const cv.ximgproc.GUIDED_FILTER', '3', [], [], None, ''],
        ['const cv.ximgproc.AM_FILTER', '4', [], [], None, '']],
    None]
ok: CONST DTF_NC=0
ok: CONST DTF_IC=1
ok: CONST DTF_RF=2
ok: CONST GUIDED_FILTER=3
ok: CONST AM_FILTER=4

--- Incoming ---
['class cv.ximgproc.DTFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.DTFilter : Algorithm, name: DTFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.DTFilter.filter',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dDepth', '-1', []]],
    'void']
ok: FUNC <void cv.ximgproc.DTFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>

--- Incoming ---
[   'cv.ximgproc.createDTFilter',
    'Ptr_DTFilter',
    [],
    [   ['Mat', 'guide', '', []],
        ['double', 'sigmaSpatial', '', []],
        ['double', 'sigmaColor', '', []],
        ['int', 'mode', 'DTF_NC', []],
        ['int', 'numIters', '3', []]],
    'Ptr<DTFilter>']
ok: FUNC <Ptr_DTFilter cv.ximgproc..createDTFilter [ARG Mat guide=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>

--- Incoming ---
[   'cv.ximgproc.dtFilter',
    'void',
    [],
    [   ['Mat', 'guide', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'sigmaSpatial', '', []],
        ['double', 'sigmaColor', '', []],
        ['int', 'mode', 'DTF_NC', []],
        ['int', 'numIters', '3', []]],
    'void']
ok: FUNC <void cv.ximgproc..dtFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>

--- Incoming ---
['class cv.ximgproc.GuidedFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.GuidedFilter : Algorithm, name: GuidedFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.GuidedFilter.filter',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'dDepth', '-1', []]],
    'void']
ok: FUNC <void cv.ximgproc.GuidedFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>

--- Incoming ---
[   'cv.ximgproc.createGuidedFilter',
    'Ptr_GuidedFilter',
    [],
    [   ['Mat', 'guide', '', []],
        ['int', 'radius', '', []],
        ['double', 'eps', '', []]],
    'Ptr<GuidedFilter>']
ok: FUNC <Ptr_GuidedFilter cv.ximgproc..createGuidedFilter [ARG Mat guide=, ARG int radius=, ARG double eps=]>

--- Incoming ---
[   'cv.ximgproc.guidedFilter',
    'void',
    [],
    [   ['Mat', 'guide', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'radius', '', []],
        ['double', 'eps', '', []],
        ['int', 'dDepth', '-1', []]],
    'void']
ok: FUNC <void cv.ximgproc..guidedFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG int radius=, ARG double eps=, ARG int dDepth=-1]>

--- Incoming ---
['class cv.ximgproc.AdaptiveManifoldFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.AdaptiveManifoldFilter : Algorithm, name: AdaptiveManifoldFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.AdaptiveManifoldFilter.filter',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'joint', 'Mat()', []]],
    'void']
ok: FUNC <void cv.ximgproc.AdaptiveManifoldFilter.filter [ARG Mat src=, ARG Mat dst=, ARG Mat joint=Mat()]>

--- Incoming ---
[   'cv.ximgproc.AdaptiveManifoldFilter.collectGarbage',
    'void',
    ['/V', '/PV'],
    [],
    'void']
ok: FUNC <void cv.ximgproc.AdaptiveManifoldFilter.collectGarbage []>

--- Incoming ---
[   'cv.ximgproc.AdaptiveManifoldFilter.create',
    'Ptr_AdaptiveManifoldFilter',
    ['/S'],
    [],
    'Ptr<AdaptiveManifoldFilter>']
ok: FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc.AdaptiveManifoldFilter.create []>

--- Incoming ---
[   'cv.ximgproc.createAMFilter',
    'Ptr_AdaptiveManifoldFilter',
    [],
    [   ['double', 'sigma_s', '', []],
        ['double', 'sigma_r', '', []],
        ['bool', 'adjust_outliers', 'false', []]],
    'Ptr<AdaptiveManifoldFilter>']
ok: FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc..createAMFilter [ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>

--- Incoming ---
[   'cv.ximgproc.amFilter',
    'void',
    [],
    [   ['Mat', 'joint', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'sigma_s', '', []],
        ['double', 'sigma_r', '', []],
        ['bool', 'adjust_outliers', 'false', []]],
    'void']
ok: FUNC <void cv.ximgproc..amFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>

--- Incoming ---
[   'cv.ximgproc.jointBilateralFilter',
    'void',
    [],
    [   ['Mat', 'joint', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'd', '', []],
        ['double', 'sigmaColor', '', []],
        ['double', 'sigmaSpace', '', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv.ximgproc..jointBilateralFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   'cv.ximgproc.bilateralTextureFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'fr', '3', []],
        ['int', 'numIter', '1', []],
        ['double', 'sigmaAlpha', '-1.', []],
        ['double', 'sigmaAvg', '-1.', []]],
    'void']
ok: FUNC <void cv.ximgproc..bilateralTextureFilter [ARG Mat src=, ARG Mat dst=, ARG int fr=3, ARG int numIter=1, ARG double sigmaAlpha=-1., ARG double sigmaAvg=-1.]>

--- Incoming ---
[   'cv.ximgproc.rollingGuidanceFilter',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['int', 'd', '-1', []],
        ['double', 'sigmaColor', '25', []],
        ['double', 'sigmaSpace', '3', []],
        ['int', 'numOfIter', '4', []],
        ['int', 'borderType', 'BORDER_DEFAULT', []]],
    'void']
ok: FUNC <void cv.ximgproc..rollingGuidanceFilter [ARG Mat src=, ARG Mat dst=, ARG int d=-1, ARG double sigmaColor=25, ARG double sigmaSpace=3, ARG int numOfIter=4, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
['class cv.ximgproc.FastBilateralSolverFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.FastBilateralSolverFilter : Algorithm, name: FastBilateralSolverFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.FastBilateralSolverFilter.filter',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'src', '', []],
        ['Mat', 'confidence', '', []],
        ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.FastBilateralSolverFilter.filter [ARG Mat src=, ARG Mat confidence=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.createFastBilateralSolverFilter',
    'Ptr_FastBilateralSolverFilter',
    [],
    [   ['Mat', 'guide', '', []],
        ['double', 'sigma_spatial', '', []],
        ['double', 'sigma_luma', '', []],
        ['double', 'sigma_chroma', '', []],
        ['double', 'lambda', '128.0', []],
        ['int', 'num_iter', '25', []],
        ['double', 'max_tol', '1e-5', []]],
    'Ptr<FastBilateralSolverFilter>']
ok: FUNC <Ptr_FastBilateralSolverFilter cv.ximgproc..createFastBilateralSolverFilter [ARG Mat guide=, ARG double sigma_spatial=, ARG double sigma_luma=, ARG double sigma_chroma=, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>

--- Incoming ---
[   'cv.ximgproc.fastBilateralSolverFilter',
    'void',
    [],
    [   ['Mat', 'guide', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'confidence', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'sigma_spatial', '8', []],
        ['double', 'sigma_luma', '8', []],
        ['double', 'sigma_chroma', '8', []],
        ['double', 'lambda', '128.0', []],
        ['int', 'num_iter', '25', []],
        ['double', 'max_tol', '1e-5', []]],
    'void']
ok: FUNC <void cv.ximgproc..fastBilateralSolverFilter [ARG Mat guide=, ARG Mat src=, ARG Mat confidence=, ARG Mat dst=, ARG double sigma_spatial=8, ARG double sigma_luma=8, ARG double sigma_chroma=8, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>

--- Incoming ---
['class cv.ximgproc.FastGlobalSmootherFilter', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.FastGlobalSmootherFilter : Algorithm, name: FastGlobalSmootherFilter, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.FastGlobalSmootherFilter.filter',
    'void',
    ['/V', '/PV'],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.FastGlobalSmootherFilter.filter [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.ximgproc.createFastGlobalSmootherFilter',
    'Ptr_FastGlobalSmootherFilter',
    [],
    [   ['Mat', 'guide', '', []],
        ['double', 'lambda', '', []],
        ['double', 'sigma_color', '', []],
        ['double', 'lambda_attenuation', '0.25', []],
        ['int', 'num_iter', '3', []]],
    'Ptr<FastGlobalSmootherFilter>']
ok: FUNC <Ptr_FastGlobalSmootherFilter cv.ximgproc..createFastGlobalSmootherFilter [ARG Mat guide=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>

--- Incoming ---
[   'cv.ximgproc.fastGlobalSmootherFilter',
    'void',
    [],
    [   ['Mat', 'guide', '', []],
        ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'lambda', '', []],
        ['double', 'sigma_color', '', []],
        ['double', 'lambda_attenuation', '0.25', []],
        ['int', 'num_iter', '3', []]],
    'void']
ok: FUNC <void cv.ximgproc..fastGlobalSmootherFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>

--- Incoming ---
[   'cv.ximgproc.l0Smooth',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['double', 'lambda', '0.02', []],
        ['double', 'kappa', '2.0', []]],
    'void']
ok: FUNC <void cv.ximgproc..l0Smooth [ARG Mat src=, ARG Mat dst=, ARG double lambda=0.02, ARG double kappa=2.0]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/edgeboxes.hpp =====
Namespaces: ['cv', 'cv.ximgproc', 'cv.ximgproc.rl', 'cv.ximgproc.segmentation']

--- Incoming ---
['class cv.ximgproc.EdgeBoxes', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ximgproc::.EdgeBoxes : Algorithm, name: EdgeBoxes, base: Algorithm

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getBoundingBoxes',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'edge_map', '', []],
        ['Mat', 'orientation_map', '', []],
        ['vector_Rect', 'boxes', '', ['/O', '/Ref']],
        ['Mat', 'scores', 'Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.getBoundingBoxes [ARG Mat edge_map=, ARG Mat orientation_map=, ARG vector_Rect boxes=, ARG Mat scores=Mat()]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getAlpha', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getAlpha []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setAlpha',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setAlpha [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getBeta', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getBeta []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setBeta',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setBeta [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getEta', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEta []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setEta',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEta [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getMinScore', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMinScore []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setMinScore',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMinScore [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getMaxBoxes', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.ximgproc.EdgeBoxes.getMaxBoxes []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setMaxBoxes',
    'void',
    ['/V', '/PV'],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMaxBoxes [ARG int value=]>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getEdgeMinMag',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMinMag []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setEdgeMinMag',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMinMag [ARG float value=]>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getEdgeMergeThr',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMergeThr []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setEdgeMergeThr',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMergeThr [ARG float value=]>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getClusterMinMag',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getClusterMinMag []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setClusterMinMag',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setClusterMinMag [ARG float value=]>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getMaxAspectRatio',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMaxAspectRatio []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setMaxAspectRatio',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMaxAspectRatio [ARG float value=]>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.getMinBoxArea',
    'float',
    ['/C', '/V', '/PV'],
    [],
    'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getMinBoxArea []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setMinBoxArea',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setMinBoxArea [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getGamma', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getGamma []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setGamma',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setGamma [ARG float value=]>

--- Incoming ---
['cv.ximgproc.EdgeBoxes.getKappa', 'float', ['/C', '/V', '/PV'], [], 'float']
ok: FUNC <float cv.ximgproc.EdgeBoxes.getKappa []>

--- Incoming ---
[   'cv.ximgproc.EdgeBoxes.setKappa',
    'void',
    ['/V', '/PV'],
    [['float', 'value', '', []]],
    'void']
ok: FUNC <void cv.ximgproc.EdgeBoxes.setKappa [ARG float value=]>

--- Incoming ---
[   'cv.ximgproc.createEdgeBoxes',
    'Ptr_EdgeBoxes',
    [],
    [   ['float', 'alpha', '0.65f', []],
        ['float', 'beta', '0.75f', []],
        ['float', 'eta', '1', []],
        ['float', 'minScore', '0.01f', []],
        ['int', 'maxBoxes', '10000', []],
        ['float', 'edgeMinMag', '0.1f', []],
        ['float', 'edgeMergeThr', '0.5f', []],
        ['float', 'clusterMinMag', '0.5f', []],
        ['float', 'maxAspectRatio', '3', []],
        ['float', 'minBoxArea', '1000', []],
        ['float', 'gamma', '2', []],
        ['float', 'kappa', '1.5f', []]],
    'Ptr<EdgeBoxes>']
ok: FUNC <Ptr_EdgeBoxes cv.ximgproc..createEdgeBoxes [ARG float alpha=0.65f, ARG float beta=0.75f, ARG float eta=1, ARG float minScore=0.01f, ARG int maxBoxes=10000, ARG float edgeMinMag=0.1f, ARG float edgeMergeThr=0.5f, ARG float clusterMinMag=0.5f, ARG float maxAspectRatio=3, ARG float minBoxArea=1000, ARG float gamma=2, ARG float kappa=1.5f]>


===== Generating... =====
CLASS cv::.Ximgproc : 
[CONST ARO_0_45=0, CONST ARO_45_90=1, CONST ARO_90_135=2, CONST ARO_315_0=3, CONST ARO_315_45=4, CONST ARO_45_135=5, CONST ARO_315_135=6, CONST ARO_CTR_HOR=7, CONST ARO_CTR_VER=8]
[CONST DTF_NC=0, CONST DTF_IC=1, CONST DTF_RF=2, CONST GUIDED_FILTER=3, CONST AM_FILTER=4]
[CONST HDO_RAW=0, CONST HDO_DESKEW=1]
[CONST FHT_MIN=0, CONST FHT_MAX=1, CONST FHT_ADD=2, CONST FHT_AVE=3]
[CONST BINARIZATION_NIBLACK=0, CONST BINARIZATION_SAUVOLA=1, CONST BINARIZATION_WOLF=2, CONST BINARIZATION_NICK=3]
[CONST SLIC=100, CONST SLICO=101, CONST MSLIC=102]
[CONST THINNING_ZHANGSUEN=0, CONST THINNING_GUOHALL=1]
[CONST WMF_EXP=1, CONST WMF_IV1=1 << 1, CONST WMF_IV2=1 << 2, CONST WMF_COS=1 << 3, CONST WMF_JAC=1 << 4, CONST WMF_OFF=1 << 5]
FUNC <void cv.ximgproc..niBlackThreshold [ARG Mat _src=, ARG Mat _dst=, ARG double maxValue=, ARG int type=, ARG int blockSize=, ARG double k=, ARG int binarizationMethod=BINARIZATION_NIBLACK, ARG double r=128]>
java: void niBlackThreshold(Mat _src, Mat _dst, double maxValue, int type, int blockSize, double k, int binarizationMethod, double r)
java: void niBlackThreshold(Mat _src, Mat _dst, double maxValue, int type, int blockSize, double k, int binarizationMethod)
java: void niBlackThreshold(Mat _src, Mat _dst, double maxValue, int type, int blockSize, double k)
FUNC <void cv.ximgproc..thinning [ARG Mat src=, ARG Mat dst=, ARG int thinningType=THINNING_ZHANGSUEN]>
java: void thinning(Mat src, Mat dst, int thinningType)
java: void thinning(Mat src, Mat dst)
FUNC <void cv.ximgproc..anisotropicDiffusion [ARG Mat src=, ARG Mat dst=, ARG float alpha=, ARG float K=, ARG int niters=]>
java: void anisotropicDiffusion(Mat src, Mat dst, float alpha, float K, int niters)
FUNC <Ptr_SuperpixelSLIC cv.ximgproc..createSuperpixelSLIC [ARG Mat image=, ARG int algorithm=SLICO, ARG int region_size=10, ARG float ruler=10.0f]>
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm, int region_size, float ruler)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm, int region_size)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image, int algorithm)
java: SuperpixelSLIC createSuperpixelSLIC(Mat image)
FUNC <Ptr_EdgeAwareInterpolator cv.ximgproc..createEdgeAwareInterpolator []>
java: EdgeAwareInterpolator createEdgeAwareInterpolator()
FUNC <Ptr_RICInterpolator cv.ximgproc..createRICInterpolator []>
java: RICInterpolator createRICInterpolator()
FUNC <Ptr_ScanSegment cv.ximgproc..createScanSegment [ARG int image_width=, ARG int image_height=, ARG int num_superpixels=, ARG int slices=8, ARG bool merge_small=true]>
java: ScanSegment createScanSegment(int image_width, int image_height, int num_superpixels, int slices, boolean merge_small)
java: ScanSegment createScanSegment(int image_width, int image_height, int num_superpixels, int slices)
java: ScanSegment createScanSegment(int image_width, int image_height, int num_superpixels)
FUNC <void cv.ximgproc..RadonTransform [ARG Mat src=, ARG Mat dst=, ARG double theta=1, ARG double start_angle=0, ARG double end_angle=180, ARG bool crop=false, ARG bool norm=false]>
java: void RadonTransform(Mat src, Mat dst, double theta, double start_angle, double end_angle, boolean crop, boolean norm)
java: void RadonTransform(Mat src, Mat dst, double theta, double start_angle, double end_angle, boolean crop)
java: void RadonTransform(Mat src, Mat dst, double theta, double start_angle, double end_angle)
java: void RadonTransform(Mat src, Mat dst, double theta, double start_angle)
java: void RadonTransform(Mat src, Mat dst, double theta)
java: void RadonTransform(Mat src, Mat dst)
FUNC <Ptr_FastLineDetector cv.ximgproc..createFastLineDetector [ARG int length_threshold=10, ARG float distance_threshold=1.414213562f, ARG double canny_th1=50.0, ARG double canny_th2=50.0, ARG int canny_aperture_size=3, ARG bool do_merge=false]>
java: FastLineDetector createFastLineDetector(int length_threshold, float distance_threshold, double canny_th1, double canny_th2, int canny_aperture_size, boolean do_merge)
java: FastLineDetector createFastLineDetector(int length_threshold, float distance_threshold, double canny_th1, double canny_th2, int canny_aperture_size)
java: FastLineDetector createFastLineDetector(int length_threshold, float distance_threshold, double canny_th1, double canny_th2)
java: FastLineDetector createFastLineDetector(int length_threshold, float distance_threshold, double canny_th1)
java: FastLineDetector createFastLineDetector(int length_threshold, float distance_threshold)
java: FastLineDetector createFastLineDetector(int length_threshold)
java: FastLineDetector createFastLineDetector()
FUNC <void cv.ximgproc..PeiLinNormalization [ARG Mat I=, ARG Mat T=]>
java: void PeiLinNormalization(Mat I, Mat T)
FUNC <Ptr_EdgeDrawing cv.ximgproc..createEdgeDrawing []>
java: EdgeDrawing createEdgeDrawing()
FUNC <Ptr_GraphSegmentation cv.ximgproc.segmentation..createGraphSegmentation [ARG double sigma=0.5, ARG float k=300, ARG int min_size=100]>
java: GraphSegmentation createGraphSegmentation(double sigma, float k, int min_size)
java: GraphSegmentation createGraphSegmentation(double sigma, float k)
java: GraphSegmentation createGraphSegmentation(double sigma)
java: GraphSegmentation createGraphSegmentation()
FUNC <Ptr_SelectiveSearchSegmentationStrategyColor cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyColor []>
java: SelectiveSearchSegmentationStrategyColor createSelectiveSearchSegmentationStrategyColor()
FUNC <Ptr_SelectiveSearchSegmentationStrategySize cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategySize []>
java: SelectiveSearchSegmentationStrategySize createSelectiveSearchSegmentationStrategySize()
FUNC <Ptr_SelectiveSearchSegmentationStrategyTexture cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyTexture []>
java: SelectiveSearchSegmentationStrategyTexture createSelectiveSearchSegmentationStrategyTexture()
FUNC <Ptr_SelectiveSearchSegmentationStrategyFill cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyFill []>
java: SelectiveSearchSegmentationStrategyFill createSelectiveSearchSegmentationStrategyFill()
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple []>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple()
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2, SelectiveSearchSegmentationStrategy s3)
FUNC <Ptr_SelectiveSearchSegmentationStrategyMultiple cv.ximgproc.segmentation..createSelectiveSearchSegmentationStrategyMultiple [ARG Ptr_SelectiveSearchSegmentationStrategy s1=, ARG Ptr_SelectiveSearchSegmentationStrategy s2=, ARG Ptr_SelectiveSearchSegmentationStrategy s3=, ARG Ptr_SelectiveSearchSegmentationStrategy s4=]>
java: SelectiveSearchSegmentationStrategyMultiple createSelectiveSearchSegmentationStrategyMultiple(SelectiveSearchSegmentationStrategy s1, SelectiveSearchSegmentationStrategy s2, SelectiveSearchSegmentationStrategy s3, SelectiveSearchSegmentationStrategy s4)
FUNC <Ptr_SelectiveSearchSegmentation cv.ximgproc.segmentation..createSelectiveSearchSegmentation []>
java: SelectiveSearchSegmentation createSelectiveSearchSegmentation()
FUNC <void cv.ximgproc..FastHoughTransform [ARG Mat src=, ARG Mat dst=, ARG int dstMatDepth=, ARG int angleRange=ARO_315_135, ARG int op=FHT_ADD, ARG int makeSkew=HDO_DESKEW]>
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange, int op, int makeSkew)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange, int op)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth, int angleRange)
java: void FastHoughTransform(Mat src, Mat dst, int dstMatDepth)
FUNC <Vec4i cv.ximgproc..HoughPoint2Line [ARG Point houghPoint=, ARG Mat srcImgInfo=, ARG int angleRange=ARO_315_135, ARG int makeSkew=HDO_DESKEW, ARG int rules=RO_IGNORE_BORDERS]>
SKIP:Vec4i cv::ximgproc::HoughPoint2Line(Point houghPoint, Mat srcImgInfo, int angleRange = ARO_315_135, int makeSkew = HDO_DESKEW, int rules = RO_IGNORE_BORDERS)	 due to RET type Vec4i
FUNC <void cv.ximgproc..findEllipses [ARG Mat image=, ARG Mat ellipses=, ARG float scoreThreshold=0.7f, ARG float reliabilityThreshold=0.5f, ARG float centerDistanceThreshold=0.05f]>
java: void findEllipses(Mat image, Mat ellipses, float scoreThreshold, float reliabilityThreshold, float centerDistanceThreshold)
java: void findEllipses(Mat image, Mat ellipses, float scoreThreshold, float reliabilityThreshold)
java: void findEllipses(Mat image, Mat ellipses, float scoreThreshold)
java: void findEllipses(Mat image, Mat ellipses)
FUNC <void cv.ximgproc..GradientDericheY [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>
java: void GradientDericheY(Mat op, Mat dst, double alpha, double omega)
FUNC <void cv.ximgproc..GradientDericheX [ARG Mat op=, ARG Mat dst=, ARG double alpha=, ARG double omega=]>
java: void GradientDericheX(Mat op, Mat dst, double alpha, double omega)
FUNC <void cv.ximgproc..weightedMedianFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int r=, ARG double sigma=25.5, ARG int weightType=WMF_EXP, ARG Mat mask=Mat()]>
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma, int weightType, Mat mask)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma, int weightType)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r, double sigma)
java: void weightedMedianFilter(Mat joint, Mat src, Mat dst, int r)
FUNC <void cv.ximgproc..covarianceEstimation [ARG Mat src=, ARG Mat dst=, ARG int windowRows=, ARG int windowCols=]>
java: void covarianceEstimation(Mat src, Mat dst, int windowRows, int windowCols)
FUNC <Ptr_RFFeatureGetter cv.ximgproc..createRFFeatureGetter []>
java: RFFeatureGetter createRFFeatureGetter()
FUNC <Ptr_StructuredEdgeDetection cv.ximgproc..createStructuredEdgeDetection [ARG String model=, ARG Ptr_RFFeatureGetter howToGetFeatures=Ptr<RFFeatureGetter>()]>
java: StructuredEdgeDetection createStructuredEdgeDetection(String model, RFFeatureGetter howToGetFeatures)
java: StructuredEdgeDetection createStructuredEdgeDetection(String model)
FUNC <void cv.ximgproc..fourierDescriptor [ARG Mat src=, ARG Mat dst=, ARG int nbElt=-1, ARG int nbFD=-1]>
java: void fourierDescriptor(Mat src, Mat dst, int nbElt, int nbFD)
java: void fourierDescriptor(Mat src, Mat dst, int nbElt)
java: void fourierDescriptor(Mat src, Mat dst)
FUNC <void cv.ximgproc..transformFD [ARG Mat src=, ARG Mat t=, ARG Mat dst=, ARG bool fdContour=true]>
java: void transformFD(Mat src, Mat t, Mat dst, boolean fdContour)
java: void transformFD(Mat src, Mat t, Mat dst)
FUNC <void cv.ximgproc..contourSampling [ARG Mat src=, ARG Mat out=, ARG int nbElt=]>
java: void contourSampling(Mat src, Mat out, int nbElt)
FUNC <Ptr_ContourFitting cv.ximgproc..createContourFitting [ARG int ctr=1024, ARG int fd=16]>
java: ContourFitting createContourFitting(int ctr, int fd)
java: ContourFitting createContourFitting(int ctr)
java: ContourFitting createContourFitting()
FUNC <void cv.ximgproc..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double threshold=]>
java: void edgePreservingFilter(Mat src, Mat dst, int d, double threshold)
FUNC <Ptr_SuperpixelSEEDS cv.ximgproc..createSuperpixelSEEDS [ARG int image_width=, ARG int image_height=, ARG int image_channels=, ARG int num_superpixels=, ARG int num_levels=, ARG int prior=2, ARG int histogram_bins=5, ARG bool double_step=false]>
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior, int histogram_bins, boolean double_step)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior, int histogram_bins)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int prior)
java: SuperpixelSEEDS createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels)
FUNC <void cv.ximgproc..createQuaternionImage [ARG Mat img=, ARG Mat qimg=]>
java: void createQuaternionImage(Mat img, Mat qimg)
FUNC <void cv.ximgproc..qconj [ARG Mat qimg=, ARG Mat qcimg=]>
java: void qconj(Mat qimg, Mat qcimg)
FUNC <void cv.ximgproc..qunitary [ARG Mat qimg=, ARG Mat qnimg=]>
java: void qunitary(Mat qimg, Mat qnimg)
FUNC <void cv.ximgproc..qmultiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void qmultiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv.ximgproc..qdft [ARG Mat img=, ARG Mat qimg=, ARG int flags=, ARG bool sideLeft=]>
java: void qdft(Mat img, Mat qimg, int flags, boolean sideLeft)
FUNC <void cv.ximgproc..colorMatchTemplate [ARG Mat img=, ARG Mat templ=, ARG Mat result=]>
java: void colorMatchTemplate(Mat img, Mat templ, Mat result)
FUNC <Ptr_SuperpixelLSC cv.ximgproc..createSuperpixelLSC [ARG Mat image=, ARG int region_size=10, ARG float ratio=0.075f]>
java: SuperpixelLSC createSuperpixelLSC(Mat image, int region_size, float ratio)
java: SuperpixelLSC createSuperpixelLSC(Mat image, int region_size)
java: SuperpixelLSC createSuperpixelLSC(Mat image)
FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilter [ARG Ptr_StereoMatcher matcher_left=]>
java: DisparityWLSFilter createDisparityWLSFilter(StereoMatcher matcher_left)
FUNC <Ptr_StereoMatcher cv.ximgproc..createRightMatcher [ARG Ptr_StereoMatcher matcher_left=]>
java: StereoMatcher createRightMatcher(StereoMatcher matcher_left)
FUNC <Ptr_DisparityWLSFilter cv.ximgproc..createDisparityWLSFilterGeneric [ARG bool use_confidence=]>
java: DisparityWLSFilter createDisparityWLSFilterGeneric(boolean use_confidence)
FUNC <int cv.ximgproc..readGT [ARG String src_path=, ARG Mat dst=]>
java: int readGT(String src_path, Mat dst)
FUNC <double cv.ximgproc..computeMSE [ARG Mat GT=, ARG Mat src=, ARG Rect ROI=]>
java: double computeMSE(Mat GT, Mat src, Rect ROI)
FUNC <double cv.ximgproc..computeBadPixelPercent [ARG Mat GT=, ARG Mat src=, ARG Rect ROI=, ARG int thresh=24]>
java: double computeBadPixelPercent(Mat GT, Mat src, Rect ROI, int thresh)
java: double computeBadPixelPercent(Mat GT, Mat src, Rect ROI)
FUNC <void cv.ximgproc..getDisparityVis [ARG Mat src=, ARG Mat dst=, ARG double scale=1.0]>
java: void getDisparityVis(Mat src, Mat dst, double scale)
java: void getDisparityVis(Mat src, Mat dst)
FUNC <Ptr_DTFilter cv.ximgproc..createDTFilter [ARG Mat guide=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor, int mode, int numIters)
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor, int mode)
java: DTFilter createDTFilter(Mat guide, double sigmaSpatial, double sigmaColor)
FUNC <void cv.ximgproc..dtFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double sigmaSpatial=, ARG double sigmaColor=, ARG int mode=DTF_NC, ARG int numIters=3]>
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor, int mode, int numIters)
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor, int mode)
java: void dtFilter(Mat guide, Mat src, Mat dst, double sigmaSpatial, double sigmaColor)
FUNC <Ptr_GuidedFilter cv.ximgproc..createGuidedFilter [ARG Mat guide=, ARG int radius=, ARG double eps=]>
java: GuidedFilter createGuidedFilter(Mat guide, int radius, double eps)
FUNC <void cv.ximgproc..guidedFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG int radius=, ARG double eps=, ARG int dDepth=-1]>
java: void guidedFilter(Mat guide, Mat src, Mat dst, int radius, double eps, int dDepth)
java: void guidedFilter(Mat guide, Mat src, Mat dst, int radius, double eps)
FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc..createAMFilter [ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>
java: AdaptiveManifoldFilter createAMFilter(double sigma_s, double sigma_r, boolean adjust_outliers)
java: AdaptiveManifoldFilter createAMFilter(double sigma_s, double sigma_r)
FUNC <void cv.ximgproc..amFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG double sigma_s=, ARG double sigma_r=, ARG bool adjust_outliers=false]>
java: void amFilter(Mat joint, Mat src, Mat dst, double sigma_s, double sigma_r, boolean adjust_outliers)
java: void amFilter(Mat joint, Mat src, Mat dst, double sigma_s, double sigma_r)
FUNC <void cv.ximgproc..jointBilateralFilter [ARG Mat joint=, ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void jointBilateralFilter(Mat joint, Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void jointBilateralFilter(Mat joint, Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv.ximgproc..bilateralTextureFilter [ARG Mat src=, ARG Mat dst=, ARG int fr=3, ARG int numIter=1, ARG double sigmaAlpha=-1., ARG double sigmaAvg=-1.]>
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter, double sigmaAlpha, double sigmaAvg)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter, double sigmaAlpha)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr, int numIter)
java: void bilateralTextureFilter(Mat src, Mat dst, int fr)
java: void bilateralTextureFilter(Mat src, Mat dst)
FUNC <void cv.ximgproc..rollingGuidanceFilter [ARG Mat src=, ARG Mat dst=, ARG int d=-1, ARG double sigmaColor=25, ARG double sigmaSpace=3, ARG int numOfIter=4, ARG int borderType=BORDER_DEFAULT]>
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int numOfIter, int borderType)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int numOfIter)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d, double sigmaColor)
java: void rollingGuidanceFilter(Mat src, Mat dst, int d)
java: void rollingGuidanceFilter(Mat src, Mat dst)
FUNC <Ptr_FastBilateralSolverFilter cv.ximgproc..createFastBilateralSolverFilter [ARG Mat guide=, ARG double sigma_spatial=, ARG double sigma_luma=, ARG double sigma_chroma=, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda)
java: FastBilateralSolverFilter createFastBilateralSolverFilter(Mat guide, double sigma_spatial, double sigma_luma, double sigma_chroma)
FUNC <void cv.ximgproc..fastBilateralSolverFilter [ARG Mat guide=, ARG Mat src=, ARG Mat confidence=, ARG Mat dst=, ARG double sigma_spatial=8, ARG double sigma_luma=8, ARG double sigma_chroma=8, ARG double lambda=128.0, ARG int num_iter=25, ARG double max_tol=1e-5]>
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter, double max_tol)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda, int num_iter)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma, double lambda)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma, double sigma_chroma)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial, double sigma_luma)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst, double sigma_spatial)
java: void fastBilateralSolverFilter(Mat guide, Mat src, Mat confidence, Mat dst)
FUNC <Ptr_FastGlobalSmootherFilter cv.ximgproc..createFastGlobalSmootherFilter [ARG Mat guide=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color, double lambda_attenuation, int num_iter)
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color, double lambda_attenuation)
java: FastGlobalSmootherFilter createFastGlobalSmootherFilter(Mat guide, double lambda, double sigma_color)
FUNC <void cv.ximgproc..fastGlobalSmootherFilter [ARG Mat guide=, ARG Mat src=, ARG Mat dst=, ARG double lambda=, ARG double sigma_color=, ARG double lambda_attenuation=0.25, ARG int num_iter=3]>
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color, double lambda_attenuation, int num_iter)
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color, double lambda_attenuation)
java: void fastGlobalSmootherFilter(Mat guide, Mat src, Mat dst, double lambda, double sigma_color)
FUNC <void cv.ximgproc..l0Smooth [ARG Mat src=, ARG Mat dst=, ARG double lambda=0.02, ARG double kappa=2.0]>
java: void l0Smooth(Mat src, Mat dst, double lambda, double kappa)
java: void l0Smooth(Mat src, Mat dst, double lambda)
java: void l0Smooth(Mat src, Mat dst)
FUNC <Ptr_EdgeBoxes cv.ximgproc..createEdgeBoxes [ARG float alpha=0.65f, ARG float beta=0.75f, ARG float eta=1, ARG float minScore=0.01f, ARG int maxBoxes=10000, ARG float edgeMinMag=0.1f, ARG float edgeMergeThr=0.5f, ARG float clusterMinMag=0.5f, ARG float maxAspectRatio=3, ARG float minBoxArea=1000, ARG float gamma=2, ARG float kappa=1.5f]>
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea, float gamma, float kappa)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea, float gamma)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio, float minBoxArea)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag, float maxAspectRatio)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr, float clusterMinMag)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag, float edgeMergeThr)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes, float edgeMinMag)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore, int maxBoxes)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta, float minScore)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta, float eta)
java: EdgeBoxes createEdgeBoxes(float alpha, float beta)
java: EdgeBoxes createEdgeBoxes(float alpha)
java: EdgeBoxes createEdgeBoxes()
CLASS cv.ximgproc::.AdaptiveManifoldFilter : Algorithm
FUNC <void cv.ximgproc.AdaptiveManifoldFilter.filter [ARG Mat src=, ARG Mat dst=, ARG Mat joint=Mat()]>
java: void filter(Mat src, Mat dst, Mat joint)
java: void filter(Mat src, Mat dst)
FUNC <void cv.ximgproc.AdaptiveManifoldFilter.collectGarbage []>
java: void collectGarbage()
FUNC <Ptr_AdaptiveManifoldFilter cv.ximgproc.AdaptiveManifoldFilter.create []>
java: AdaptiveManifoldFilter create()
CLASS cv.ximgproc::.ContourFitting : Algorithm
FUNC <void cv.ximgproc.ContourFitting.estimateTransformation [ARG Mat src=, ARG Mat dst=, ARG Mat alphaPhiST=, ARG double dist=, ARG bool fdContour=false]>
java: void estimateTransformation(Mat src, Mat dst, Mat alphaPhiST, double[] dist, boolean fdContour)
java: void estimateTransformation(Mat src, Mat dst, Mat alphaPhiST, double[] dist)
FUNC <void cv.ximgproc.ContourFitting.setCtrSize [ARG int n=]>
java: void setCtrSize(int n)
FUNC <void cv.ximgproc.ContourFitting.setFDSize [ARG int n=]>
java: void setFDSize(int n)
FUNC <int cv.ximgproc.ContourFitting.getCtrSize []>
java: int getCtrSize()
FUNC <int cv.ximgproc.ContourFitting.getFDSize []>
java: int getFDSize()
CLASS cv.ximgproc::.DTFilter : Algorithm
FUNC <void cv.ximgproc.DTFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>
java: void filter(Mat src, Mat dst, int dDepth)
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc::.DisparityFilter : Algorithm
FUNC <void cv.ximgproc.DisparityFilter.filter [ARG Mat disparity_map_left=, ARG Mat left_view=, ARG Mat filtered_disparity_map=, ARG Mat disparity_map_right=Mat(), ARG Rect ROI=Rect(), ARG Mat right_view=Mat()]>
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right, Rect ROI, Mat right_view)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right, Rect ROI)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map, Mat disparity_map_right)
java: void filter(Mat disparity_map_left, Mat left_view, Mat filtered_disparity_map)
CLASS cv.ximgproc::.DisparityWLSFilter : DisparityFilter
FUNC <double cv.ximgproc.DisparityWLSFilter.getLambda []>
java: double getLambda()
FUNC <void cv.ximgproc.DisparityWLSFilter.setLambda [ARG double _lambda=]>
java: void setLambda(double _lambda)
FUNC <double cv.ximgproc.DisparityWLSFilter.getSigmaColor []>
java: double getSigmaColor()
FUNC <void cv.ximgproc.DisparityWLSFilter.setSigmaColor [ARG double _sigma_color=]>
java: void setSigmaColor(double _sigma_color)
FUNC <int cv.ximgproc.DisparityWLSFilter.getLRCthresh []>
java: int getLRCthresh()
FUNC <void cv.ximgproc.DisparityWLSFilter.setLRCthresh [ARG int _LRC_thresh=]>
java: void setLRCthresh(int _LRC_thresh)
FUNC <int cv.ximgproc.DisparityWLSFilter.getDepthDiscontinuityRadius []>
java: int getDepthDiscontinuityRadius()
FUNC <void cv.ximgproc.DisparityWLSFilter.setDepthDiscontinuityRadius [ARG int _disc_radius=]>
java: void setDepthDiscontinuityRadius(int _disc_radius)
FUNC <Mat cv.ximgproc.DisparityWLSFilter.getConfidenceMap []>
java: Mat getConfidenceMap()
FUNC <Rect cv.ximgproc.DisparityWLSFilter.getROI []>
java: Rect getROI()
CLASS cv.ximgproc::.EdgeAwareInterpolator : SparseMatchInterpolator
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setCostMap [ARG Mat _costMap=]>
java: void setCostMap(Mat _costMap)
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setK [ARG int _k=]>
java: void setK(int _k)
FUNC <int cv.ximgproc.EdgeAwareInterpolator.getK []>
java: int getK()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setSigma [ARG float _sigma=]>
java: void setSigma(float _sigma)
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getSigma []>
java: float getSigma()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setLambda [ARG float _lambda=]>
java: void setLambda(float _lambda)
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getLambda []>
java: float getLambda()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setUsePostProcessing [ARG bool _use_post_proc=]>
java: void setUsePostProcessing(boolean _use_post_proc)
FUNC <bool cv.ximgproc.EdgeAwareInterpolator.getUsePostProcessing []>
java: boolean getUsePostProcessing()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSLambda [ARG float _lambda=]>
java: void setFGSLambda(float _lambda)
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSLambda []>
java: float getFGSLambda()
FUNC <void cv.ximgproc.EdgeAwareInterpolator.setFGSSigma [ARG float _sigma=]>
java: void setFGSSigma(float _sigma)
FUNC <float cv.ximgproc.EdgeAwareInterpolator.getFGSSigma []>
java: float getFGSSigma()
CLASS cv.ximgproc::.EdgeBoxes : Algorithm
FUNC <void cv.ximgproc.EdgeBoxes.getBoundingBoxes [ARG Mat edge_map=, ARG Mat orientation_map=, ARG vector_Rect boxes=, ARG Mat scores=Mat()]>
java: void getBoundingBoxes(Mat edge_map, Mat orientation_map, MatOfRect boxes, Mat scores)
java: void getBoundingBoxes(Mat edge_map, Mat orientation_map, MatOfRect boxes)
FUNC <float cv.ximgproc.EdgeBoxes.getAlpha []>
java: float getAlpha()
FUNC <void cv.ximgproc.EdgeBoxes.setAlpha [ARG float value=]>
java: void setAlpha(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getBeta []>
java: float getBeta()
FUNC <void cv.ximgproc.EdgeBoxes.setBeta [ARG float value=]>
java: void setBeta(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getEta []>
java: float getEta()
FUNC <void cv.ximgproc.EdgeBoxes.setEta [ARG float value=]>
java: void setEta(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getMinScore []>
java: float getMinScore()
FUNC <void cv.ximgproc.EdgeBoxes.setMinScore [ARG float value=]>
java: void setMinScore(float value)
FUNC <int cv.ximgproc.EdgeBoxes.getMaxBoxes []>
java: int getMaxBoxes()
FUNC <void cv.ximgproc.EdgeBoxes.setMaxBoxes [ARG int value=]>
java: void setMaxBoxes(int value)
FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMinMag []>
java: float getEdgeMinMag()
FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMinMag [ARG float value=]>
java: void setEdgeMinMag(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getEdgeMergeThr []>
java: float getEdgeMergeThr()
FUNC <void cv.ximgproc.EdgeBoxes.setEdgeMergeThr [ARG float value=]>
java: void setEdgeMergeThr(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getClusterMinMag []>
java: float getClusterMinMag()
FUNC <void cv.ximgproc.EdgeBoxes.setClusterMinMag [ARG float value=]>
java: void setClusterMinMag(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getMaxAspectRatio []>
java: float getMaxAspectRatio()
FUNC <void cv.ximgproc.EdgeBoxes.setMaxAspectRatio [ARG float value=]>
java: void setMaxAspectRatio(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getMinBoxArea []>
java: float getMinBoxArea()
FUNC <void cv.ximgproc.EdgeBoxes.setMinBoxArea [ARG float value=]>
java: void setMinBoxArea(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getGamma []>
java: float getGamma()
FUNC <void cv.ximgproc.EdgeBoxes.setGamma [ARG float value=]>
java: void setGamma(float value)
FUNC <float cv.ximgproc.EdgeBoxes.getKappa []>
java: float getKappa()
FUNC <void cv.ximgproc.EdgeBoxes.setKappa [ARG float value=]>
java: void setKappa(float value)
CLASS cv.ximgproc::.EdgeDrawing : Algorithm
[CONST PREWITT=0, CONST SOBEL=1, CONST SCHARR=2, CONST LSD=3]
FUNC <void cv.ximgproc.EdgeDrawing.detectEdges [ARG Mat src=]>
java: void detectEdges(Mat src)
FUNC <void cv.ximgproc.EdgeDrawing.getEdgeImage [ARG Mat dst=]>
java: void getEdgeImage(Mat dst)
FUNC <void cv.ximgproc.EdgeDrawing.getGradientImage [ARG Mat dst=]>
java: void getGradientImage(Mat dst)
FUNC <vector_vector_Point cv.ximgproc.EdgeDrawing.getSegments []>
java: List<MatOfPoint> getSegments()
FUNC <vector_int cv.ximgproc.EdgeDrawing.getSegmentIndicesOfLines []>
java: MatOfInt getSegmentIndicesOfLines()
FUNC <void cv.ximgproc.EdgeDrawing.detectLines [ARG Mat lines=]>
java: void detectLines(Mat lines)
FUNC <void cv.ximgproc.EdgeDrawing.detectEllipses [ARG Mat ellipses=]>
java: void detectEllipses(Mat ellipses)
FUNC <void cv.ximgproc.EdgeDrawing.setParams [ARG EdgeDrawing_Params parameters=]>
java: void setParams(EdgeDrawing_Params parameters)
CLASS cv.ximgproc::EdgeDrawing.EdgeDrawing_Params : 
FUNC < cv.ximgproc.EdgeDrawing.Params.EdgeDrawing_Params []>
java:  EdgeDrawing_Params()
FUNC <bool cv.ximgproc.EdgeDrawing.Params.get_PFmode []>
java: boolean get_PFmode()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_PFmode [ARG bool PFmode=]>
java: void set_PFmode(boolean PFmode)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_EdgeDetectionOperator []>
java: int get_EdgeDetectionOperator()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_EdgeDetectionOperator [ARG int EdgeDetectionOperator=]>
java: void set_EdgeDetectionOperator(int EdgeDetectionOperator)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_GradientThresholdValue []>
java: int get_GradientThresholdValue()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_GradientThresholdValue [ARG int GradientThresholdValue=]>
java: void set_GradientThresholdValue(int GradientThresholdValue)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_AnchorThresholdValue []>
java: int get_AnchorThresholdValue()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_AnchorThresholdValue [ARG int AnchorThresholdValue=]>
java: void set_AnchorThresholdValue(int AnchorThresholdValue)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_ScanInterval []>
java: int get_ScanInterval()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_ScanInterval [ARG int ScanInterval=]>
java: void set_ScanInterval(int ScanInterval)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_MinPathLength []>
java: int get_MinPathLength()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_MinPathLength [ARG int MinPathLength=]>
java: void set_MinPathLength(int MinPathLength)
FUNC <float cv.ximgproc.EdgeDrawing.Params.get_Sigma []>
java: float get_Sigma()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_Sigma [ARG float Sigma=]>
java: void set_Sigma(float Sigma)
FUNC <bool cv.ximgproc.EdgeDrawing.Params.get_SumFlag []>
java: boolean get_SumFlag()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_SumFlag [ARG bool SumFlag=]>
java: void set_SumFlag(boolean SumFlag)
FUNC <bool cv.ximgproc.EdgeDrawing.Params.get_NFAValidation []>
java: boolean get_NFAValidation()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_NFAValidation [ARG bool NFAValidation=]>
java: void set_NFAValidation(boolean NFAValidation)
FUNC <int cv.ximgproc.EdgeDrawing.Params.get_MinLineLength []>
java: int get_MinLineLength()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_MinLineLength [ARG int MinLineLength=]>
java: void set_MinLineLength(int MinLineLength)
FUNC <double cv.ximgproc.EdgeDrawing.Params.get_MaxDistanceBetweenTwoLines []>
java: double get_MaxDistanceBetweenTwoLines()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_MaxDistanceBetweenTwoLines [ARG double MaxDistanceBetweenTwoLines=]>
java: void set_MaxDistanceBetweenTwoLines(double MaxDistanceBetweenTwoLines)
FUNC <double cv.ximgproc.EdgeDrawing.Params.get_LineFitErrorThreshold []>
java: double get_LineFitErrorThreshold()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_LineFitErrorThreshold [ARG double LineFitErrorThreshold=]>
java: void set_LineFitErrorThreshold(double LineFitErrorThreshold)
FUNC <double cv.ximgproc.EdgeDrawing.Params.get_MaxErrorThreshold []>
java: double get_MaxErrorThreshold()
FUNC <void cv.ximgproc.EdgeDrawing.Params.set_MaxErrorThreshold [ARG double MaxErrorThreshold=]>
java: void set_MaxErrorThreshold(double MaxErrorThreshold)
CLASS cv.ximgproc::.FastBilateralSolverFilter : Algorithm
FUNC <void cv.ximgproc.FastBilateralSolverFilter.filter [ARG Mat src=, ARG Mat confidence=, ARG Mat dst=]>
java: void filter(Mat src, Mat confidence, Mat dst)
CLASS cv.ximgproc::.FastGlobalSmootherFilter : Algorithm
FUNC <void cv.ximgproc.FastGlobalSmootherFilter.filter [ARG Mat src=, ARG Mat dst=]>
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc::.FastLineDetector : Algorithm
FUNC <void cv.ximgproc.FastLineDetector.detect [ARG Mat image=, ARG Mat lines=]>
java: void detect(Mat image, Mat lines)
FUNC <void cv.ximgproc.FastLineDetector.drawSegments [ARG Mat image=, ARG Mat lines=, ARG bool draw_arrow=false, ARG Scalar linecolor=Scalar(0, 0, 255), ARG int linethickness=1]>
java: void drawSegments(Mat image, Mat lines, boolean draw_arrow, Scalar linecolor, int linethickness)
java: void drawSegments(Mat image, Mat lines, boolean draw_arrow, Scalar linecolor)
java: void drawSegments(Mat image, Mat lines, boolean draw_arrow)
java: void drawSegments(Mat image, Mat lines)
CLASS cv.ximgproc::.GuidedFilter : Algorithm
FUNC <void cv.ximgproc.GuidedFilter.filter [ARG Mat src=, ARG Mat dst=, ARG int dDepth=-1]>
java: void filter(Mat src, Mat dst, int dDepth)
java: void filter(Mat src, Mat dst)
CLASS cv.ximgproc::.RFFeatureGetter : Algorithm
FUNC <void cv.ximgproc.RFFeatureGetter.getFeatures [ARG Mat src=, ARG Mat features=, ARG int gnrmRad=, ARG int gsmthRad=, ARG int shrink=, ARG int outNum=, ARG int gradNum=]>
java: void getFeatures(Mat src, Mat features, int gnrmRad, int gsmthRad, int shrink, int outNum, int gradNum)
CLASS cv.ximgproc::.RICInterpolator : SparseMatchInterpolator
FUNC <void cv.ximgproc.RICInterpolator.setK [ARG int k=32]>
java: void setK(int k)
java: void setK()
FUNC <int cv.ximgproc.RICInterpolator.getK []>
java: int getK()
FUNC <void cv.ximgproc.RICInterpolator.setCostMap [ARG Mat costMap=]>
java: void setCostMap(Mat costMap)
FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelSize [ARG int spSize=15]>
java: void setSuperpixelSize(int spSize)
java: void setSuperpixelSize()
FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelSize []>
java: int getSuperpixelSize()
FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelNNCnt [ARG int spNN=150]>
java: void setSuperpixelNNCnt(int spNN)
java: void setSuperpixelNNCnt()
FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelNNCnt []>
java: int getSuperpixelNNCnt()
FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelRuler [ARG float ruler=15.f]>
java: void setSuperpixelRuler(float ruler)
java: void setSuperpixelRuler()
FUNC <float cv.ximgproc.RICInterpolator.getSuperpixelRuler []>
java: float getSuperpixelRuler()
FUNC <void cv.ximgproc.RICInterpolator.setSuperpixelMode [ARG int mode=100]>
java: void setSuperpixelMode(int mode)
java: void setSuperpixelMode()
FUNC <int cv.ximgproc.RICInterpolator.getSuperpixelMode []>
java: int getSuperpixelMode()
FUNC <void cv.ximgproc.RICInterpolator.setAlpha [ARG float alpha=0.7f]>
java: void setAlpha(float alpha)
java: void setAlpha()
FUNC <float cv.ximgproc.RICInterpolator.getAlpha []>
java: float getAlpha()
FUNC <void cv.ximgproc.RICInterpolator.setModelIter [ARG int modelIter=4]>
java: void setModelIter(int modelIter)
java: void setModelIter()
FUNC <int cv.ximgproc.RICInterpolator.getModelIter []>
java: int getModelIter()
FUNC <void cv.ximgproc.RICInterpolator.setRefineModels [ARG bool refineModles=true]>
java: void setRefineModels(boolean refineModles)
java: void setRefineModels()
FUNC <bool cv.ximgproc.RICInterpolator.getRefineModels []>
java: boolean getRefineModels()
FUNC <void cv.ximgproc.RICInterpolator.setMaxFlow [ARG float maxFlow=250.f]>
java: void setMaxFlow(float maxFlow)
java: void setMaxFlow()
FUNC <float cv.ximgproc.RICInterpolator.getMaxFlow []>
java: float getMaxFlow()
FUNC <void cv.ximgproc.RICInterpolator.setUseVariationalRefinement [ARG bool use_variational_refinement=false]>
java: void setUseVariationalRefinement(boolean use_variational_refinement)
java: void setUseVariationalRefinement()
FUNC <bool cv.ximgproc.RICInterpolator.getUseVariationalRefinement []>
java: boolean getUseVariationalRefinement()
FUNC <void cv.ximgproc.RICInterpolator.setUseGlobalSmootherFilter [ARG bool use_FGS=true]>
java: void setUseGlobalSmootherFilter(boolean use_FGS)
java: void setUseGlobalSmootherFilter()
FUNC <bool cv.ximgproc.RICInterpolator.getUseGlobalSmootherFilter []>
java: boolean getUseGlobalSmootherFilter()
FUNC <void cv.ximgproc.RICInterpolator.setFGSLambda [ARG float lambda=500.f]>
java: void setFGSLambda(float lambda)
java: void setFGSLambda()
FUNC <float cv.ximgproc.RICInterpolator.getFGSLambda []>
java: float getFGSLambda()
FUNC <void cv.ximgproc.RICInterpolator.setFGSSigma [ARG float sigma=1.5f]>
java: void setFGSSigma(float sigma)
java: void setFGSSigma()
FUNC <float cv.ximgproc.RICInterpolator.getFGSSigma []>
java: float getFGSSigma()
CLASS cv.ximgproc::.RidgeDetectionFilter : Algorithm
FUNC <Ptr_RidgeDetectionFilter cv.ximgproc.RidgeDetectionFilter.create [ARG int ddepth=CV_32FC1, ARG int dx=1, ARG int dy=1, ARG int ksize=3, ARG int out_dtype=CV_8UC1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale, double delta, int borderType)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale, double delta)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype, double scale)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize, int out_dtype)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy, int ksize)
java: RidgeDetectionFilter create(int ddepth, int dx, int dy)
java: RidgeDetectionFilter create(int ddepth, int dx)
java: RidgeDetectionFilter create(int ddepth)
java: RidgeDetectionFilter create()
FUNC <void cv.ximgproc.RidgeDetectionFilter.getRidgeFilteredImage [ARG Mat _img=, ARG Mat out=]>
java: void getRidgeFilteredImage(Mat _img, Mat out)
CLASS cv.ximgproc::.ScanSegment : Algorithm
FUNC <int cv.ximgproc.ScanSegment.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.ScanSegment.iterate [ARG Mat img=]>
java: void iterate(Mat img)
FUNC <void cv.ximgproc.ScanSegment.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.ScanSegment.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
CLASS cv.ximgproc::.SparseMatchInterpolator : Algorithm
FUNC <void cv.ximgproc.SparseMatchInterpolator.interpolate [ARG Mat from_image=, ARG Mat from_points=, ARG Mat to_image=, ARG Mat to_points=, ARG Mat dense_flow=]>
java: void interpolate(Mat from_image, Mat from_points, Mat to_image, Mat to_points, Mat dense_flow)
CLASS cv.ximgproc::.StructuredEdgeDetection : Algorithm
FUNC <void cv.ximgproc.StructuredEdgeDetection.detectEdges [ARG Mat src=, ARG Mat dst=]>
java: void detectEdges(Mat src, Mat dst)
FUNC <void cv.ximgproc.StructuredEdgeDetection.computeOrientation [ARG Mat src=, ARG Mat dst=]>
java: void computeOrientation(Mat src, Mat dst)
FUNC <void cv.ximgproc.StructuredEdgeDetection.edgesNms [ARG Mat edge_image=, ARG Mat orientation_image=, ARG Mat dst=, ARG int r=2, ARG int s=0, ARG float m=1, ARG bool isParallel=true]>
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat dst, int r, int s, float m, boolean isParallel)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat dst, int r, int s, float m)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat dst, int r, int s)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat dst, int r)
java: void edgesNms(Mat edge_image, Mat orientation_image, Mat dst)
CLASS cv.ximgproc::.SuperpixelLSC : Algorithm
FUNC <int cv.ximgproc.SuperpixelLSC.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelLSC.iterate [ARG int num_iterations=10]>
java: void iterate(int num_iterations)
java: void iterate()
FUNC <void cv.ximgproc.SuperpixelLSC.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelLSC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
FUNC <void cv.ximgproc.SuperpixelLSC.enforceLabelConnectivity [ARG int min_element_size=25]>
java: void enforceLabelConnectivity(int min_element_size)
java: void enforceLabelConnectivity()
CLASS cv.ximgproc::.SuperpixelSEEDS : Algorithm
FUNC <int cv.ximgproc.SuperpixelSEEDS.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelSEEDS.iterate [ARG Mat img=, ARG int num_iterations=4]>
java: void iterate(Mat img, int num_iterations)
java: void iterate(Mat img)
FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelSEEDS.getLabelContourMask [ARG Mat image=, ARG bool thick_line=false]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
CLASS cv.ximgproc::.SuperpixelSLIC : Algorithm
FUNC <int cv.ximgproc.SuperpixelSLIC.getNumberOfSuperpixels []>
java: int getNumberOfSuperpixels()
FUNC <void cv.ximgproc.SuperpixelSLIC.iterate [ARG int num_iterations=10]>
java: void iterate(int num_iterations)
java: void iterate()
FUNC <void cv.ximgproc.SuperpixelSLIC.getLabels [ARG Mat labels_out=]>
java: void getLabels(Mat labels_out)
FUNC <void cv.ximgproc.SuperpixelSLIC.getLabelContourMask [ARG Mat image=, ARG bool thick_line=true]>
java: void getLabelContourMask(Mat image, boolean thick_line)
java: void getLabelContourMask(Mat image)
FUNC <void cv.ximgproc.SuperpixelSLIC.enforceLabelConnectivity [ARG int min_element_size=25]>
java: void enforceLabelConnectivity(int min_element_size)
java: void enforceLabelConnectivity()
CLASS cv.ximgproc.segmentation::.GraphSegmentation : Algorithm
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.processImage [ARG Mat src=, ARG Mat dst=]>
java: void processImage(Mat src, Mat dst)
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setSigma [ARG double sigma=]>
java: void setSigma(double sigma)
FUNC <double cv.ximgproc.segmentation.GraphSegmentation.getSigma []>
java: double getSigma()
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setK [ARG float k=]>
java: void setK(float k)
FUNC <float cv.ximgproc.segmentation.GraphSegmentation.getK []>
java: float getK()
FUNC <void cv.ximgproc.segmentation.GraphSegmentation.setMinSize [ARG int min_size=]>
java: void setMinSize(int min_size)
FUNC <int cv.ximgproc.segmentation.GraphSegmentation.getMinSize []>
java: int getMinSize()
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentation : Algorithm
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.setBaseImage [ARG Mat img=]>
java: void setBaseImage(Mat img)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSingleStrategy [ARG int k=200, ARG float sigma=0.8f]>
java: void switchToSingleStrategy(int k, float sigma)
java: void switchToSingleStrategy(int k)
java: void switchToSingleStrategy()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchFast [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>
java: void switchToSelectiveSearchFast(int base_k, int inc_k, float sigma)
java: void switchToSelectiveSearchFast(int base_k, int inc_k)
java: void switchToSelectiveSearchFast(int base_k)
java: void switchToSelectiveSearchFast()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.switchToSelectiveSearchQuality [ARG int base_k=150, ARG int inc_k=150, ARG float sigma=0.8f]>
java: void switchToSelectiveSearchQuality(int base_k, int inc_k, float sigma)
java: void switchToSelectiveSearchQuality(int base_k, int inc_k)
java: void switchToSelectiveSearchQuality(int base_k)
java: void switchToSelectiveSearchQuality()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addImage [ARG Mat img=]>
java: void addImage(Mat img)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearImages []>
java: void clearImages()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addGraphSegmentation [ARG Ptr_GraphSegmentation g=]>
java: void addGraphSegmentation(GraphSegmentation g)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearGraphSegmentations []>
java: void clearGraphSegmentations()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy s=]>
java: void addStrategy(SelectiveSearchSegmentationStrategy s)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.clearStrategies []>
java: void clearStrategies()
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentation.process [ARG vector_Rect rects=]>
java: void process(MatOfRect rects)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategy : Algorithm
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.setImage [ARG Mat img=, ARG Mat regions=, ARG Mat sizes=, ARG int image_id=-1]>
java: void setImage(Mat img, Mat regions, Mat sizes, int image_id)
java: void setImage(Mat img, Mat regions, Mat sizes)
FUNC <float cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.get [ARG int r1=, ARG int r2=]>
java: float get(int r1, int r2)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategy.merge [ARG int r1=, ARG int r2=]>
java: void merge(int r1, int r2)
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyColor : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyFill : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyMultiple : SelectiveSearchSegmentationStrategy
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.addStrategy [ARG Ptr_SelectiveSearchSegmentationStrategy g=, ARG float weight=]>
java: void addStrategy(SelectiveSearchSegmentationStrategy g, float weight)
FUNC <void cv.ximgproc.segmentation.SelectiveSearchSegmentationStrategyMultiple.clearStrategies []>
java: void clearStrategies()
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategySize : SelectiveSearchSegmentationStrategy
CLASS cv.ximgproc.segmentation::.SelectiveSearchSegmentationStrategyTexture : SelectiveSearchSegmentationStrategy

=== MODULE: aruco (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco) ===


Files (3):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco/aruco_calib.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Aruco : , name: Aruco, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'cv.aruco.detectMarkers',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Ptr_Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['vector_Mat', 'corners', '', ['/O']],
        ['Mat', 'ids', '', ['/O']],
        [   'Ptr_DetectorParameters',
            'parameters',
            'makePtr<DetectorParameters>()',
            ['/C', '/Ref']],
        ['vector_Mat', 'rejectedImgPoints', 'vector_Mat()', ['/O']]],
    'void']
ok: FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=makePtr<DetectorParameters>(), ARG vector_Mat rejectedImgPoints=vector_Mat()]>

--- Incoming ---
[   'cv.aruco.refineDetectedMarkers',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['vector_Mat', 'detectedCorners', '', ['/IO']],
        ['Mat', 'detectedIds', '', ['/IO']],
        ['vector_Mat', 'rejectedCorners', '', ['/IO']],
        ['Mat', 'cameraMatrix', 'Mat()', []],
        ['Mat', 'distCoeffs', 'Mat()', []],
        ['float', 'minRepDistance', '10.f', []],
        ['float', 'errorCorrectionRate', '3.f', []],
        ['bool', 'checkAllOrders', 'true', []],
        ['Mat', 'recoveredIdxs', 'Mat()', ['/O']],
        [   'Ptr_DetectorParameters',
            'parameters',
            'makePtr<DetectorParameters>()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=makePtr<DetectorParameters>()]>

--- Incoming ---
[   'cv.aruco.drawPlanarBoard',
    'void',
    [],
    [   ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['Size', 'outSize', '', []],
        ['Mat', 'img', '', ['/O']],
        ['int', 'marginSize', '', []],
        ['int', 'borderBits', '', []]],
    'void']
ok: FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=, ARG int borderBits=]>

--- Incoming ---
[   'cv.aruco.getBoardObjectAndImagePoints',
    'void',
    [],
    [   ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['vector_Mat', 'detectedCorners', '', []],
        ['Mat', 'detectedIds', '', []],
        ['Mat', 'objPoints', '', ['/O']],
        ['Mat', 'imgPoints', '', ['/O']]],
    'void']
ok: FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>

--- Incoming ---
[   'cv.aruco.estimatePoseBoard',
    'int',
    [],
    [   ['vector_Mat', 'corners', '', []],
        ['Mat', 'ids', '', []],
        ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/IO']],
        ['Mat', 'tvec', '', ['/IO']],
        ['bool', 'useExtrinsicGuess', 'false', []]],
    'int']
ok: FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   'cv.aruco.estimatePoseCharucoBoard',
    'bool',
    [],
    [   ['Mat', 'charucoCorners', '', []],
        ['Mat', 'charucoIds', '', []],
        ['Ptr_CharucoBoard', 'board', '', ['/C', '/Ref']],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/IO']],
        ['Mat', 'tvec', '', ['/IO']],
        ['bool', 'useExtrinsicGuess', 'false', []]],
    'bool']
ok: FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>

--- Incoming ---
[   'cv.aruco.estimatePoseSingleMarkers',
    'void',
    [],
    [   ['vector_Mat', 'corners', '', []],
        ['float', 'markerLength', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvecs', '', ['/O']],
        ['Mat', 'tvecs', '', ['/O']],
        ['Mat', 'objPoints', 'Mat()', ['/O']],
        [   'Ptr_EstimateParameters',
            'estimateParameters',
            'makePtr<EstimateParameters>()',
            ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat objPoints=Mat(), ARG Ptr_EstimateParameters estimateParameters=makePtr<EstimateParameters>()]>

--- Incoming ---
[   'cv.aruco.testCharucoCornersCollinear',
    'bool',
    [],
    [   ['Ptr_CharucoBoard', 'board', '', ['/C', '/Ref']],
        ['Mat', 'charucoIds', '', []]],
    'bool']
ok: FUNC <bool cv.aruco..testCharucoCornersCollinear [ARG Ptr_CharucoBoard board=, ARG Mat charucoIds=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'cv.aruco.interpolateCornersCharuco',
    'int',
    [],
    [   ['vector_Mat', 'markerCorners', '', []],
        ['Mat', 'markerIds', '', []],
        ['Mat', 'image', '', []],
        ['Ptr_CharucoBoard', 'board', '', ['/C', '/Ref']],
        ['Mat', 'charucoCorners', '', ['/O']],
        ['Mat', 'charucoIds', '', ['/O']],
        ['Mat', 'cameraMatrix', 'Mat()', []],
        ['Mat', 'distCoeffs', 'Mat()', []],
        ['int', 'minMarkers', '2', []]],
    'int']
ok: FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>

--- Incoming ---
[   'cv.aruco.detectCharucoDiamond',
    'void',
    [],
    [   ['Mat', 'image', '', []],
        ['vector_Mat', 'markerCorners', '', []],
        ['Mat', 'markerIds', '', []],
        ['float', 'squareMarkerLengthRate', '', []],
        ['vector_Mat', 'diamondCorners', '', ['/O']],
        ['Mat', 'diamondIds', '', ['/O']],
        ['Mat', 'cameraMatrix', 'Mat()', []],
        ['Mat', 'distCoeffs', 'Mat()', []],
        [   'Ptr_Dictionary',
            'dictionary',
            'makePtr<Dictionary> '
            '(getPredefinedDictionary(PredefinedDictionaryType::DICT_4X4_50))',
            []]],
    'void']
ok: FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG Ptr_Dictionary dictionary=makePtr<Dictionary> (getPredefinedDictionary(PredefinedDictionaryType::DICT_4X4_50))]>

--- Incoming ---
[   'cv.aruco.drawCharucoDiamond',
    'void',
    [],
    [   ['Ptr_Dictionary', 'dictionary', '', ['/C', '/Ref']],
        ['Vec4i', 'ids', '', []],
        ['int', 'squareLength', '', []],
        ['int', 'markerLength', '', []],
        ['Mat', 'img', '', ['/O']],
        ['int', 'marginSize', '0', []],
        ['int', 'borderBits', '1', []]],
    'void']
ok: FUNC <void cv.aruco..drawCharucoDiamond [ARG Ptr_Dictionary dictionary=, ARG Vec4i ids=, ARG int squareLength=, ARG int markerLength=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/aruco/include/opencv2/aruco/aruco_calib.hpp =====
Namespaces: ['cv', 'cv.aruco']

--- Incoming ---
[   'enum cv.aruco.PatternPositionType',
    '',
    [],
    [   ['const cv.aruco.ARUCO_CCW_CENTER', '0', [], [], None, ''],
        ['const cv.aruco.ARUCO_CW_TOP_LEFT_CORNER', '1', [], [], None, '']],
    None]
ok: CONST ARUCO_CCW_CENTER=0
ok: CONST ARUCO_CW_TOP_LEFT_CORNER=1

--- Incoming ---
[   'struct cv.aruco.EstimateParameters',
    '',
    ['/Simple'],
    [   ['PatternPositionType', 'pattern', '', ['/RW']],
        ['bool', 'useExtrinsicGuess', '', ['/RW']],
        ['int', 'solvePnPMethod', '', ['/RW']]],
    None]
ok: class CLASS cv.aruco::.EstimateParameters : , name: EstimateParameters, base: 

--- Incoming ---
['cv.aruco.EstimateParameters.EstimateParameters', '', [], [], None]
ok: FUNC < cv.aruco.EstimateParameters.EstimateParameters []>

--- Incoming ---
[   'cv.aruco.calibrateCameraAruco',
    'double',
    ['=calibrateCameraArucoExtended'],
    [   ['vector_Mat', 'corners', '', []],
        ['Mat', 'ids', '', []],
        ['Mat', 'counter', '', []],
        ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', 'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            ['/C', '/Ref']]],
    'double']
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.aruco.calibrateCameraAruco',
    'double',
    [],
    [   ['vector_Mat', 'corners', '', []],
        ['Mat', 'ids', '', []],
        ['Mat', 'counter', '', []],
        ['Ptr_Board', 'board', '', ['/C', '/Ref']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', 'vector_Mat()', ['/O']],
        ['vector_Mat', 'tvecs', 'vector_Mat()', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            ['/C', '/Ref']]],
    'double']
ok: FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.aruco.calibrateCameraCharuco',
    'double',
    ['=calibrateCameraCharucoExtended'],
    [   ['vector_Mat', 'charucoCorners', '', []],
        ['vector_Mat', 'charucoIds', '', []],
        ['Ptr_CharucoBoard', 'board', '', ['/C', '/Ref']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['Mat', 'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', 'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', 'perViewErrors', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            ['/C', '/Ref']]],
    'double']
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.aruco.calibrateCameraCharuco',
    'double',
    [],
    [   ['vector_Mat', 'charucoCorners', '', []],
        ['vector_Mat', 'charucoIds', '', []],
        ['Ptr_CharucoBoard', 'board', '', ['/C', '/Ref']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', 'vector_Mat()', ['/O']],
        ['vector_Mat', 'tvecs', 'vector_Mat()', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, '
            'DBL_EPSILON)',
            ['/C', '/Ref']]],
    'double']
ok: FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>


===== Generating... =====
CLASS cv::.Aruco : 
[CONST ARUCO_CCW_CENTER=0, CONST ARUCO_CW_TOP_LEFT_CORNER=1]
FUNC <void cv.aruco..detectMarkers [ARG Mat image=, ARG Ptr_Dictionary dictionary=, ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_DetectorParameters parameters=makePtr<DetectorParameters>(), ARG vector_Mat rejectedImgPoints=vector_Mat()]>
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters, List<Mat> rejectedImgPoints)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids, DetectorParameters parameters)
java: void detectMarkers(Mat image, Dictionary dictionary, List<Mat> corners, Mat ids)
FUNC <void cv.aruco..refineDetectedMarkers [ARG Mat image=, ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG vector_Mat rejectedCorners=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG float minRepDistance=10.f, ARG float errorCorrectionRate=3.f, ARG bool checkAllOrders=true, ARG Mat recoveredIdxs=Mat(), ARG Ptr_DetectorParameters parameters=makePtr<DetectorParameters>()]>
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders, Mat recoveredIdxs, DetectorParameters parameters)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders, Mat recoveredIdxs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate, boolean checkAllOrders)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance, float errorCorrectionRate)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs, float minRepDistance)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix, Mat distCoeffs)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners, Mat cameraMatrix)
java: void refineDetectedMarkers(Mat image, Board board, List<Mat> detectedCorners, Mat detectedIds, List<Mat> rejectedCorners)
FUNC <void cv.aruco..drawPlanarBoard [ARG Ptr_Board board=, ARG Size outSize=, ARG Mat img=, ARG int marginSize=, ARG int borderBits=]>
java: void drawPlanarBoard(Board board, Size outSize, Mat img, int marginSize, int borderBits)
FUNC <void cv.aruco..getBoardObjectAndImagePoints [ARG Ptr_Board board=, ARG vector_Mat detectedCorners=, ARG Mat detectedIds=, ARG Mat objPoints=, ARG Mat imgPoints=]>
java: void getBoardObjectAndImagePoints(Board board, List<Mat> detectedCorners, Mat detectedIds, Mat objPoints, Mat imgPoints)
FUNC <int cv.aruco..estimatePoseBoard [ARG vector_Mat corners=, ARG Mat ids=, ARG Ptr_Board board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: int estimatePoseBoard(List<Mat> corners, Mat ids, Board board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv.aruco..estimatePoseCharucoBoard [ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false]>
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean estimatePoseCharucoBoard(Mat charucoCorners, Mat charucoIds, CharucoBoard board, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv.aruco..estimatePoseSingleMarkers [ARG vector_Mat corners=, ARG float markerLength=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvecs=, ARG Mat tvecs=, ARG Mat objPoints=Mat(), ARG Ptr_EstimateParameters estimateParameters=makePtr<EstimateParameters>()]>
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs, Mat objPoints, EstimateParameters estimateParameters)
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs, Mat objPoints)
java: void estimatePoseSingleMarkers(List<Mat> corners, float markerLength, Mat cameraMatrix, Mat distCoeffs, Mat rvecs, Mat tvecs)
FUNC <bool cv.aruco..testCharucoCornersCollinear [ARG Ptr_CharucoBoard board=, ARG Mat charucoIds=]>
java: boolean testCharucoCornersCollinear(CharucoBoard board, Mat charucoIds)
FUNC <int cv.aruco..interpolateCornersCharuco [ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG Mat image=, ARG Ptr_CharucoBoard board=, ARG Mat charucoCorners=, ARG Mat charucoIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG int minMarkers=2]>
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix, Mat distCoeffs, int minMarkers)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix, Mat distCoeffs)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds, Mat cameraMatrix)
java: int interpolateCornersCharuco(List<Mat> markerCorners, Mat markerIds, Mat image, CharucoBoard board, Mat charucoCorners, Mat charucoIds)
FUNC <void cv.aruco..detectCharucoDiamond [ARG Mat image=, ARG vector_Mat markerCorners=, ARG Mat markerIds=, ARG float squareMarkerLengthRate=, ARG vector_Mat diamondCorners=, ARG Mat diamondIds=, ARG Mat cameraMatrix=Mat(), ARG Mat distCoeffs=Mat(), ARG Ptr_Dictionary dictionary=makePtr<Dictionary> (getPredefinedDictionary(PredefinedDictionaryType::DICT_4X4_50))]>
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix, Mat distCoeffs, Dictionary dictionary)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix, Mat distCoeffs)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds, Mat cameraMatrix)
java: void detectCharucoDiamond(Mat image, List<Mat> markerCorners, Mat markerIds, float squareMarkerLengthRate, List<Mat> diamondCorners, Mat diamondIds)
FUNC <void cv.aruco..drawCharucoDiamond [ARG Ptr_Dictionary dictionary=, ARG Vec4i ids=, ARG int squareLength=, ARG int markerLength=, ARG Mat img=, ARG int marginSize=0, ARG int borderBits=1]>
SKIP:void cv::aruco::drawCharucoDiamond(Ptr_Dictionary dictionary, Vec4i ids, int squareLength, int markerLength, Mat& img, int marginSize = 0, int borderBits = 1)	 due to ARG type Vec4i/I
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraArucoExtended(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraAruco [ARG vector_Mat corners=, ARG Mat ids=, ARG Mat counter=, ARG Ptr_Board board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs)
java: double calibrateCameraAruco(List<Mat> corners, Mat ids, Mat counter, Board board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraCharucoExtended(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv.aruco..calibrateCameraCharuco [ARG vector_Mat charucoCorners=, ARG vector_Mat charucoIds=, ARG Ptr_CharucoBoard board=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=vector_Mat(), ARG vector_Mat tvecs=vector_Mat(), ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs)
java: double calibrateCameraCharuco(List<Mat> charucoCorners, List<Mat> charucoIds, CharucoBoard board, Size imageSize, Mat cameraMatrix, Mat distCoeffs)
CLASS cv.aruco::.EstimateParameters : 
FUNC < cv.aruco.EstimateParameters.EstimateParameters []>
java:  EstimateParameters()
FUNC <PatternPositionType cv.aruco.EstimateParameters.get_pattern []>
SKIP:PatternPositionType EstimateParameters::pattern	 due to RET type PatternPositionType
FUNC <void cv.aruco.EstimateParameters.set_pattern [ARG PatternPositionType pattern=]>
SKIP:void EstimateParameters::pattern	 due to ARG type PatternPositionType/I
FUNC <bool cv.aruco.EstimateParameters.get_useExtrinsicGuess []>
java: boolean get_useExtrinsicGuess()
FUNC <void cv.aruco.EstimateParameters.set_useExtrinsicGuess [ARG bool useExtrinsicGuess=]>
java: void set_useExtrinsicGuess(boolean useExtrinsicGuess)
FUNC <int cv.aruco.EstimateParameters.get_solvePnPMethod []>
java: int get_solvePnPMethod()
FUNC <void cv.aruco.EstimateParameters.set_solvePnPMethod [ARG int solvePnPMethod=]>
java: void set_solvePnPMethod(int solvePnPMethod)

=== MODULE: bgsegm (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bgsegm) ===


Files (1):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bgsegm/include/opencv2/bgsegm.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Bgsegm : , name: Bgsegm, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bgsegm/include/opencv2/bgsegm.hpp =====
Namespaces: ['cv', 'cv.bgsegm']

--- Incoming ---
[   'class cv.bgsegm.BackgroundSubtractorMOG',
    ': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorMOG : BackgroundSubtractor, name: BackgroundSubtractorMOG, base: BackgroundSubtractor

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.getHistory',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getHistory []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.setHistory',
    'void',
    ['/V', '/PV'],
    [['int', 'nframes', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setHistory [ARG int nframes=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.getNMixtures',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getNMixtures []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.setNMixtures',
    'void',
    ['/V', '/PV'],
    [['int', 'nmix', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNMixtures [ARG int nmix=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio',
    'void',
    ['/V', '/PV'],
    [['double', 'backgroundRatio', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio [ARG double backgroundRatio=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma',
    'void',
    ['/V', '/PV'],
    [['double', 'noiseSigma', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma [ARG double noiseSigma=]>

--- Incoming ---
[   'cv.bgsegm.createBackgroundSubtractorMOG',
    'Ptr_BackgroundSubtractorMOG',
    [],
    [   ['int', 'history', '200', []],
        ['int', 'nmixtures', '5', []],
        ['double', 'backgroundRatio', '0.7', []],
        ['double', 'noiseSigma', '0', []]],
    'Ptr<BackgroundSubtractorMOG>']
ok: FUNC <Ptr_BackgroundSubtractorMOG cv.bgsegm..createBackgroundSubtractorMOG [ARG int history=200, ARG int nmixtures=5, ARG double backgroundRatio=0.7, ARG double noiseSigma=0]>

--- Incoming ---
[   'class cv.bgsegm.BackgroundSubtractorGMG',
    ': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorGMG : BackgroundSubtractor, name: BackgroundSubtractorGMG, base: BackgroundSubtractor

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures',
    'void',
    ['/V', '/PV'],
    [['int', 'maxFeatures', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate',
    'void',
    ['/V', '/PV'],
    [['double', 'lr', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate [ARG double lr=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getNumFrames',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getNumFrames []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setNumFrames',
    'void',
    ['/V', '/PV'],
    [['int', 'nframes', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setNumFrames [ARG int nframes=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels',
    'void',
    ['/V', '/PV'],
    [['int', 'nlevels', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels [ARG int nlevels=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior',
    'void',
    ['/V', '/PV'],
    [['double', 'bgprior', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior [ARG double bgprior=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'radius', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius [ARG int radius=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'thresh', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold [ARG double thresh=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel',
    'void',
    ['/V', '/PV'],
    [['bool', 'update', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel [ARG bool update=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getMinVal',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMinVal []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setMinVal',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMinVal [ARG double val=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.getMaxVal',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMaxVal []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGMG.setMaxVal',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxVal [ARG double val=]>

--- Incoming ---
[   'cv.bgsegm.createBackgroundSubtractorGMG',
    'Ptr_BackgroundSubtractorGMG',
    [],
    [   ['int', 'initializationFrames', '120', []],
        ['double', 'decisionThreshold', '0.8', []]],
    'Ptr<BackgroundSubtractorGMG>']
ok: FUNC <Ptr_BackgroundSubtractorGMG cv.bgsegm..createBackgroundSubtractorGMG [ARG int initializationFrames=120, ARG double decisionThreshold=0.8]>

--- Incoming ---
[   'class cv.bgsegm.BackgroundSubtractorCNT',
    ': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorCNT : BackgroundSubtractor, name: BackgroundSubtractorCNT, base: BackgroundSubtractor

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.apply',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'fgmask', '', ['/O']],
        ['double', 'learningRate', '-1', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'backgroundImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability',
    'void',
    ['/V', '/PV'],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability [ARG int value=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability',
    'void',
    ['/V', '/PV'],
    [['int', 'value', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability [ARG int value=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.getUseHistory',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getUseHistory []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.setUseHistory',
    'void',
    ['/V', '/PV'],
    [['bool', 'value', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setUseHistory [ARG bool value=]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.getIsParallel',
    'bool',
    ['/C', '/V', '/PV'],
    [],
    'bool']
ok: FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getIsParallel []>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorCNT.setIsParallel',
    'void',
    ['/V', '/PV'],
    [['bool', 'value', '', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setIsParallel [ARG bool value=]>

--- Incoming ---
[   'cv.bgsegm.createBackgroundSubtractorCNT',
    'Ptr_BackgroundSubtractorCNT',
    [],
    [   ['int', 'minPixelStability', '15', []],
        ['bool', 'useHistory', 'true', []],
        ['int', 'maxPixelStability', '15*60', []],
        ['bool', 'isParallel', 'true', []]],
    'Ptr<BackgroundSubtractorCNT>']
ok: FUNC <Ptr_BackgroundSubtractorCNT cv.bgsegm..createBackgroundSubtractorCNT [ARG int minPixelStability=15, ARG bool useHistory=true, ARG int maxPixelStability=15*60, ARG bool isParallel=true]>

--- Incoming ---
[   'enum cv.bgsegm.LSBPCameraMotionCompensation',
    '',
    [],
    [   [   'const cv.bgsegm.LSBP_CAMERA_MOTION_COMPENSATION_NONE',
            '0',
            [],
            [],
            None,
            ''],
        [   'const cv.bgsegm.LSBP_CAMERA_MOTION_COMPENSATION_LK',
            '0+1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST LSBP_CAMERA_MOTION_COMPENSATION_NONE=0
ok: CONST LSBP_CAMERA_MOTION_COMPENSATION_LK=0+1

--- Incoming ---
[   'class cv.bgsegm.BackgroundSubtractorGSOC',
    ': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorGSOC : BackgroundSubtractor, name: BackgroundSubtractorGSOC, base: BackgroundSubtractor

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGSOC.apply',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'fgmask', '', ['/O']],
        ['double', 'learningRate', '-1', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'backgroundImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   'class cv.bgsegm.BackgroundSubtractorLSBP',
    ': cv::bgsegm::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorLSBP : BackgroundSubtractor, name: BackgroundSubtractorLSBP, base: BackgroundSubtractor

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorLSBP.apply',
    'void',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'fgmask', '', ['/O']],
        ['double', 'learningRate', '-1', []]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   'cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'backgroundImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
['class cv.bgsegm.BackgroundSubtractorLSBPDesc', '', [], [], None]
ok: class CLASS cv.bgsegm::.BackgroundSubtractorLSBPDesc : , name: BackgroundSubtractorLSBPDesc, base: 

--- Incoming ---
[   'cv.bgsegm.createBackgroundSubtractorGSOC',
    'Ptr_BackgroundSubtractorGSOC',
    [],
    [   ['int', 'mc', 'LSBP_CAMERA_MOTION_COMPENSATION_NONE', []],
        ['int', 'nSamples', '20', []],
        ['float', 'replaceRate', '0.003f', []],
        ['float', 'propagationRate', '0.01f', []],
        ['int', 'hitsThreshold', '32', []],
        ['float', 'alpha', '0.01f', []],
        ['float', 'beta', '0.0022f', []],
        ['float', 'blinkingSupressionDecay', '0.1f', []],
        ['float', 'blinkingSupressionMultiplier', '0.1f', []],
        ['float', 'noiseRemovalThresholdFacBG', '0.0004f', []],
        ['float', 'noiseRemovalThresholdFacFG', '0.0008f', []]],
    'Ptr<BackgroundSubtractorGSOC>']
ok: FUNC <Ptr_BackgroundSubtractorGSOC cv.bgsegm..createBackgroundSubtractorGSOC [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG float replaceRate=0.003f, ARG float propagationRate=0.01f, ARG int hitsThreshold=32, ARG float alpha=0.01f, ARG float beta=0.0022f, ARG float blinkingSupressionDecay=0.1f, ARG float blinkingSupressionMultiplier=0.1f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f]>

--- Incoming ---
[   'cv.bgsegm.createBackgroundSubtractorLSBP',
    'Ptr_BackgroundSubtractorLSBP',
    [],
    [   ['int', 'mc', 'LSBP_CAMERA_MOTION_COMPENSATION_NONE', []],
        ['int', 'nSamples', '20', []],
        ['int', 'LSBPRadius', '16', []],
        ['float', 'Tlower', '2.0f', []],
        ['float', 'Tupper', '32.0f', []],
        ['float', 'Tinc', '1.0f', []],
        ['float', 'Tdec', '0.05f', []],
        ['float', 'Rscale', '10.0f', []],
        ['float', 'Rincdec', '0.005f', []],
        ['float', 'noiseRemovalThresholdFacBG', '0.0004f', []],
        ['float', 'noiseRemovalThresholdFacFG', '0.0008f', []],
        ['int', 'LSBPthreshold', '8', []],
        ['int', 'minCount', '2', []]],
    'Ptr<BackgroundSubtractorLSBP>']
ok: FUNC <Ptr_BackgroundSubtractorLSBP cv.bgsegm..createBackgroundSubtractorLSBP [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG int LSBPRadius=16, ARG float Tlower=2.0f, ARG float Tupper=32.0f, ARG float Tinc=1.0f, ARG float Tdec=0.05f, ARG float Rscale=10.0f, ARG float Rincdec=0.005f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f, ARG int LSBPthreshold=8, ARG int minCount=2]>

--- Incoming ---
['class cv.bgsegm.SyntheticSequenceGenerator', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.bgsegm::.SyntheticSequenceGenerator : Algorithm, name: SyntheticSequenceGenerator, base: Algorithm

--- Incoming ---
[   'cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator',
    '',
    [],
    [   ['Mat', 'background', '', []],
        ['Mat', 'object', '', []],
        ['double', 'amplitude', '', []],
        ['double', 'wavelength', '', []],
        ['double', 'wavespeed', '', []],
        ['double', 'objspeed', '', []]],
    None]
ok: FUNC < cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=, ARG double wavelength=, ARG double wavespeed=, ARG double objspeed=]>

--- Incoming ---
[   'cv.bgsegm.SyntheticSequenceGenerator.getNextFrame',
    'void',
    [],
    [['Mat', 'frame', '', ['/O']], ['Mat', 'gtMask', '', ['/O']]],
    'void']
ok: FUNC <void cv.bgsegm.SyntheticSequenceGenerator.getNextFrame [ARG Mat frame=, ARG Mat gtMask=]>

--- Incoming ---
[   'cv.bgsegm.createSyntheticSequenceGenerator',
    'Ptr_SyntheticSequenceGenerator',
    [],
    [   ['Mat', 'background', '', []],
        ['Mat', 'object', '', []],
        ['double', 'amplitude', '2.0', []],
        ['double', 'wavelength', '20.0', []],
        ['double', 'wavespeed', '0.2', []],
        ['double', 'objspeed', '6.0', []]],
    'Ptr<SyntheticSequenceGenerator>']
ok: FUNC <Ptr_SyntheticSequenceGenerator cv.bgsegm..createSyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=2.0, ARG double wavelength=20.0, ARG double wavespeed=0.2, ARG double objspeed=6.0]>


===== Generating... =====
CLASS cv::.Bgsegm : 
[CONST LSBP_CAMERA_MOTION_COMPENSATION_NONE=0, CONST LSBP_CAMERA_MOTION_COMPENSATION_LK=0+1]
FUNC <Ptr_BackgroundSubtractorMOG cv.bgsegm..createBackgroundSubtractorMOG [ARG int history=200, ARG int nmixtures=5, ARG double backgroundRatio=0.7, ARG double noiseSigma=0]>
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history, int nmixtures)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG(int history)
java: BackgroundSubtractorMOG createBackgroundSubtractorMOG()
FUNC <Ptr_BackgroundSubtractorGMG cv.bgsegm..createBackgroundSubtractorGMG [ARG int initializationFrames=120, ARG double decisionThreshold=0.8]>
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG(int initializationFrames, double decisionThreshold)
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG(int initializationFrames)
java: BackgroundSubtractorGMG createBackgroundSubtractorGMG()
FUNC <Ptr_BackgroundSubtractorCNT cv.bgsegm..createBackgroundSubtractorCNT [ARG int minPixelStability=15, ARG bool useHistory=true, ARG int maxPixelStability=15*60, ARG bool isParallel=true]>
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory, int maxPixelStability, boolean isParallel)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory, int maxPixelStability)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability, boolean useHistory)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT(int minPixelStability)
java: BackgroundSubtractorCNT createBackgroundSubtractorCNT()
FUNC <Ptr_BackgroundSubtractorGSOC cv.bgsegm..createBackgroundSubtractorGSOC [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG float replaceRate=0.003f, ARG float propagationRate=0.01f, ARG int hitsThreshold=32, ARG float alpha=0.01f, ARG float beta=0.0022f, ARG float blinkingSupressionDecay=0.1f, ARG float blinkingSupressionMultiplier=0.1f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f]>
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier, float noiseRemovalThresholdFacBG)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay, float blinkingSupressionMultiplier)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta, float blinkingSupressionDecay)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha, float beta)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold, float alpha)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate, int hitsThreshold)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate, float propagationRate)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples, float replaceRate)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc, int nSamples)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC(int mc)
java: BackgroundSubtractorGSOC createBackgroundSubtractorGSOC()
FUNC <Ptr_BackgroundSubtractorLSBP cv.bgsegm..createBackgroundSubtractorLSBP [ARG int mc=LSBP_CAMERA_MOTION_COMPENSATION_NONE, ARG int nSamples=20, ARG int LSBPRadius=16, ARG float Tlower=2.0f, ARG float Tupper=32.0f, ARG float Tinc=1.0f, ARG float Tdec=0.05f, ARG float Rscale=10.0f, ARG float Rincdec=0.005f, ARG float noiseRemovalThresholdFacBG=0.0004f, ARG float noiseRemovalThresholdFacFG=0.0008f, ARG int LSBPthreshold=8, ARG int minCount=2]>
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG, int LSBPthreshold, int minCount)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG, int LSBPthreshold)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG, float noiseRemovalThresholdFacFG)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec, float noiseRemovalThresholdFacBG)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale, float Rincdec)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec, float Rscale)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc, float Tdec)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper, float Tinc)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower, float Tupper)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius, float Tlower)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples, int LSBPRadius)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc, int nSamples)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP(int mc)
java: BackgroundSubtractorLSBP createBackgroundSubtractorLSBP()
FUNC <Ptr_SyntheticSequenceGenerator cv.bgsegm..createSyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=2.0, ARG double wavelength=20.0, ARG double wavespeed=0.2, ARG double objspeed=6.0]>
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed, double objspeed)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object, double amplitude)
java: SyntheticSequenceGenerator createSyntheticSequenceGenerator(Mat background, Mat object)
CLASS cv.bgsegm::.BackgroundSubtractorCNT : BackgroundSubtractor
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMinPixelStability []>
java: int getMinPixelStability()
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMinPixelStability [ARG int value=]>
java: void setMinPixelStability(int value)
FUNC <int cv.bgsegm.BackgroundSubtractorCNT.getMaxPixelStability []>
java: int getMaxPixelStability()
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setMaxPixelStability [ARG int value=]>
java: void setMaxPixelStability(int value)
FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getUseHistory []>
java: boolean getUseHistory()
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setUseHistory [ARG bool value=]>
java: void setUseHistory(boolean value)
FUNC <bool cv.bgsegm.BackgroundSubtractorCNT.getIsParallel []>
java: boolean getIsParallel()
FUNC <void cv.bgsegm.BackgroundSubtractorCNT.setIsParallel [ARG bool value=]>
java: void setIsParallel(boolean value)
CLASS cv.bgsegm::.BackgroundSubtractorGMG : BackgroundSubtractor
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDefaultLearningRate []>
java: double getDefaultLearningRate()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDefaultLearningRate [ARG double lr=]>
java: void setDefaultLearningRate(double lr)
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getNumFrames []>
java: int getNumFrames()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setNumFrames [ARG int nframes=]>
java: void setNumFrames(int nframes)
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getQuantizationLevels []>
java: int getQuantizationLevels()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setQuantizationLevels [ARG int nlevels=]>
java: void setQuantizationLevels(int nlevels)
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getBackgroundPrior []>
java: double getBackgroundPrior()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setBackgroundPrior [ARG double bgprior=]>
java: void setBackgroundPrior(double bgprior)
FUNC <int cv.bgsegm.BackgroundSubtractorGMG.getSmoothingRadius []>
java: int getSmoothingRadius()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setSmoothingRadius [ARG int radius=]>
java: void setSmoothingRadius(int radius)
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getDecisionThreshold []>
java: double getDecisionThreshold()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setDecisionThreshold [ARG double thresh=]>
java: void setDecisionThreshold(double thresh)
FUNC <bool cv.bgsegm.BackgroundSubtractorGMG.getUpdateBackgroundModel []>
java: boolean getUpdateBackgroundModel()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setUpdateBackgroundModel [ARG bool update=]>
java: void setUpdateBackgroundModel(boolean update)
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMinVal []>
java: double getMinVal()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMinVal [ARG double val=]>
java: void setMinVal(double val)
FUNC <double cv.bgsegm.BackgroundSubtractorGMG.getMaxVal []>
java: double getMaxVal()
FUNC <void cv.bgsegm.BackgroundSubtractorGMG.setMaxVal [ARG double val=]>
java: void setMaxVal(double val)
CLASS cv.bgsegm::.BackgroundSubtractorGSOC : BackgroundSubtractor
FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorGSOC.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS cv.bgsegm::.BackgroundSubtractorLSBP : BackgroundSubtractor
FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.bgsegm.BackgroundSubtractorLSBP.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS cv.bgsegm::.BackgroundSubtractorLSBPDesc : 
CLASS cv.bgsegm::.BackgroundSubtractorMOG : BackgroundSubtractor
FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getHistory []>
java: int getHistory()
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setHistory [ARG int nframes=]>
java: void setHistory(int nframes)
FUNC <int cv.bgsegm.BackgroundSubtractorMOG.getNMixtures []>
java: int getNMixtures()
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNMixtures [ARG int nmix=]>
java: void setNMixtures(int nmix)
FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setBackgroundRatio [ARG double backgroundRatio=]>
java: void setBackgroundRatio(double backgroundRatio)
FUNC <double cv.bgsegm.BackgroundSubtractorMOG.getNoiseSigma []>
java: double getNoiseSigma()
FUNC <void cv.bgsegm.BackgroundSubtractorMOG.setNoiseSigma [ARG double noiseSigma=]>
java: void setNoiseSigma(double noiseSigma)
CLASS cv.bgsegm::.SyntheticSequenceGenerator : Algorithm
FUNC < cv.bgsegm.SyntheticSequenceGenerator.SyntheticSequenceGenerator [ARG Mat background=, ARG Mat object=, ARG double amplitude=, ARG double wavelength=, ARG double wavespeed=, ARG double objspeed=]>
java:  SyntheticSequenceGenerator(Mat background, Mat object, double amplitude, double wavelength, double wavespeed, double objspeed)
FUNC <void cv.bgsegm.SyntheticSequenceGenerator.getNextFrame [ARG Mat frame=, ARG Mat gtMask=]>
java: void getNextFrame(Mat frame, Mat gtMask)

=== MODULE: bioinspired (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired) ===


Files (5):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retina.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retinafasttonemapping.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/transientareassegmentationmodule.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Bioinspired : , name: Bioinspired, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp =====
Namespaces: []
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retina.hpp =====
Namespaces: ['cv', 'cv.bioinspired']

--- Incoming ---
[   'enum cv.bioinspired.<unnamed>',
    '',
    [],
    [   ['const cv.bioinspired.RETINA_COLOR_RANDOM', '0', [], [], None, ''],
        ['const cv.bioinspired.RETINA_COLOR_DIAGONAL', '1', [], [], None, ''],
        ['const cv.bioinspired.RETINA_COLOR_BAYER', '2', [], [], None, '']],
    None]
ok: CONST RETINA_COLOR_RANDOM=0
ok: CONST RETINA_COLOR_DIAGONAL=1
ok: CONST RETINA_COLOR_BAYER=2

--- Incoming ---
['class cv.bioinspired.Retina', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.bioinspired::.Retina : Algorithm, name: Retina, base: Algorithm

--- Incoming ---
['cv.bioinspired.Retina.getInputSize', 'Size', ['/V'], [], 'Size']
ok: FUNC <Size cv.bioinspired.Retina.getInputSize []>

--- Incoming ---
['cv.bioinspired.Retina.getOutputSize', 'Size', ['/V'], [], 'Size']
ok: FUNC <Size cv.bioinspired.Retina.getOutputSize []>

--- Incoming ---
[   'cv.bioinspired.Retina.setup',
    'void',
    ['/V'],
    [   ['String', 'retinaParameterFile', '""', []],
        ['bool', 'applyDefaultSetupOnFailure', 'true', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.setup [ARG String retinaParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>

--- Incoming ---
['cv.bioinspired.Retina.printSetup', 'String', ['/V'], [], 'String']
ok: FUNC <String cv.bioinspired.Retina.printSetup []>

--- Incoming ---
[   'cv.bioinspired.Retina.write',
    'void',
    ['/V'],
    [['String', 'fs', '', []]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.write [ARG String fs=]>

--- Incoming ---
[   'cv.bioinspired.Retina.setupOPLandIPLParvoChannel',
    'void',
    ['/V'],
    [   ['bool', 'colorMode', 'true', ['/C']],
        ['bool', 'normaliseOutput', 'true', ['/C']],
        ['float', 'photoreceptorsLocalAdaptationSensitivity', '0.7f', ['/C']],
        ['float', 'photoreceptorsTemporalConstant', '0.5f', ['/C']],
        ['float', 'photoreceptorsSpatialConstant', '0.53f', ['/C']],
        ['float', 'horizontalCellsGain', '0.f', ['/C']],
        ['float', 'HcellsTemporalConstant', '1.f', ['/C']],
        ['float', 'HcellsSpatialConstant', '7.f', ['/C']],
        ['float', 'ganglionCellsSensitivity', '0.7f', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.setupOPLandIPLParvoChannel [ARG bool colorMode=true, ARG bool normaliseOutput=true, ARG float photoreceptorsLocalAdaptationSensitivity=0.7f, ARG float photoreceptorsTemporalConstant=0.5f, ARG float photoreceptorsSpatialConstant=0.53f, ARG float horizontalCellsGain=0.f, ARG float HcellsTemporalConstant=1.f, ARG float HcellsSpatialConstant=7.f, ARG float ganglionCellsSensitivity=0.7f]>

--- Incoming ---
[   'cv.bioinspired.Retina.setupIPLMagnoChannel',
    'void',
    ['/V'],
    [   ['bool', 'normaliseOutput', 'true', ['/C']],
        ['float', 'parasolCells_beta', '0.f', ['/C']],
        ['float', 'parasolCells_tau', '0.f', ['/C']],
        ['float', 'parasolCells_k', '7.f', ['/C']],
        ['float', 'amacrinCellsTemporalCutFrequency', '1.2f', ['/C']],
        ['float', 'V0CompressionParameter', '0.95f', ['/C']],
        ['float', 'localAdaptintegration_tau', '0.f', ['/C']],
        ['float', 'localAdaptintegration_k', '7.f', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.setupIPLMagnoChannel [ARG bool normaliseOutput=true, ARG float parasolCells_beta=0.f, ARG float parasolCells_tau=0.f, ARG float parasolCells_k=7.f, ARG float amacrinCellsTemporalCutFrequency=1.2f, ARG float V0CompressionParameter=0.95f, ARG float localAdaptintegration_tau=0.f, ARG float localAdaptintegration_k=7.f]>

--- Incoming ---
[   'cv.bioinspired.Retina.run',
    'void',
    ['/V'],
    [['Mat', 'inputImage', '', []]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.run [ARG Mat inputImage=]>

--- Incoming ---
[   'cv.bioinspired.Retina.applyFastToneMapping',
    'void',
    ['/V'],
    [   ['Mat', 'inputImage', '', []],
        ['Mat', 'outputToneMappedImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>

--- Incoming ---
[   'cv.bioinspired.Retina.getParvo',
    'void',
    ['/V'],
    [['Mat', 'retinaOutput_parvo', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.getParvo [ARG Mat retinaOutput_parvo=]>

--- Incoming ---
[   'cv.bioinspired.Retina.getParvoRAW',
    'void',
    ['/V'],
    [['Mat', 'retinaOutput_parvo', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.getParvoRAW [ARG Mat retinaOutput_parvo=]>

--- Incoming ---
[   'cv.bioinspired.Retina.getMagno',
    'void',
    ['/V'],
    [['Mat', 'retinaOutput_magno', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.getMagno [ARG Mat retinaOutput_magno=]>

--- Incoming ---
[   'cv.bioinspired.Retina.getMagnoRAW',
    'void',
    ['/V'],
    [['Mat', 'retinaOutput_magno', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.getMagnoRAW [ARG Mat retinaOutput_magno=]>

--- Incoming ---
['cv.bioinspired.Retina.getMagnoRAW', 'Mat', ['/V'], [], 'Mat']
ok: FUNC <Mat cv.bioinspired.Retina.getMagnoRAW []>

--- Incoming ---
['cv.bioinspired.Retina.getParvoRAW', 'Mat', ['/V'], [], 'Mat']
ok: FUNC <Mat cv.bioinspired.Retina.getParvoRAW []>

--- Incoming ---
[   'cv.bioinspired.Retina.setColorSaturation',
    'void',
    ['/V'],
    [   ['bool', 'saturateColors', 'true', ['/C']],
        ['float', 'colorSaturationValue', '4.0f', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.setColorSaturation [ARG bool saturateColors=true, ARG float colorSaturationValue=4.0f]>

--- Incoming ---
['cv.bioinspired.Retina.clearBuffers', 'void', ['/V'], [], 'void']
ok: FUNC <void cv.bioinspired.Retina.clearBuffers []>

--- Incoming ---
[   'cv.bioinspired.Retina.activateMovingContoursProcessing',
    'void',
    ['/V'],
    [['bool', 'activate', '', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.activateMovingContoursProcessing [ARG bool activate=]>

--- Incoming ---
[   'cv.bioinspired.Retina.activateContoursProcessing',
    'void',
    ['/V'],
    [['bool', 'activate', '', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.Retina.activateContoursProcessing [ARG bool activate=]>

--- Incoming ---
[   'cv.bioinspired.Retina.create',
    'Ptr_Retina',
    ['/S'],
    [['Size', 'inputSize', '', []]],
    'Ptr<Retina>']
ok: FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=]>

--- Incoming ---
[   'cv.bioinspired.Retina.create',
    'Ptr_Retina',
    ['/S'],
    [   ['Size', 'inputSize', '', []],
        ['bool', 'colorMode', '', ['/C']],
        ['int', 'colorSamplingMethod', 'RETINA_COLOR_BAYER', []],
        ['bool', 'useRetinaLogSampling', 'false', ['/C']],
        ['float', 'reductionFactor', '1.0f', ['/C']],
        ['float', 'samplingStrength', '10.0f', ['/C']]],
    'Ptr<Retina>']
ok: FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=, ARG bool colorMode=, ARG int colorSamplingMethod=RETINA_COLOR_BAYER, ARG bool useRetinaLogSampling=false, ARG float reductionFactor=1.0f, ARG float samplingStrength=10.0f]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/retinafasttonemapping.hpp =====
Namespaces: ['cv', 'cv.bioinspired']

--- Incoming ---
['class cv.bioinspired.RetinaFastToneMapping', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.bioinspired::.RetinaFastToneMapping : Algorithm, name: RetinaFastToneMapping, base: Algorithm

--- Incoming ---
[   'cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping',
    'void',
    ['/V'],
    [   ['Mat', 'inputImage', '', []],
        ['Mat', 'outputToneMappedImage', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>

--- Incoming ---
[   'cv.bioinspired.RetinaFastToneMapping.setup',
    'void',
    ['/V'],
    [   ['float', 'photoreceptorsNeighborhoodRadius', '3.f', ['/C']],
        ['float', 'ganglioncellsNeighborhoodRadius', '1.f', ['/C']],
        ['float', 'meanLuminanceModulatorK', '1.f', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.RetinaFastToneMapping.setup [ARG float photoreceptorsNeighborhoodRadius=3.f, ARG float ganglioncellsNeighborhoodRadius=1.f, ARG float meanLuminanceModulatorK=1.f]>

--- Incoming ---
[   'cv.bioinspired.RetinaFastToneMapping.create',
    'Ptr_RetinaFastToneMapping',
    ['/S'],
    [['Size', 'inputSize', '', []]],
    'Ptr<RetinaFastToneMapping>']
ok: FUNC <Ptr_RetinaFastToneMapping cv.bioinspired.RetinaFastToneMapping.create [ARG Size inputSize=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/transientareassegmentationmodule.hpp =====
Namespaces: ['cv', 'cv.bioinspired']

--- Incoming ---
[   'class cv.bioinspired.TransientAreasSegmentationModule',
    ': cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv.bioinspired::.TransientAreasSegmentationModule : Algorithm, name: TransientAreasSegmentationModule, base: Algorithm

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.getSize',
    'Size',
    ['/V'],
    [],
    'Size']
ok: FUNC <Size cv.bioinspired.TransientAreasSegmentationModule.getSize []>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.setup',
    'void',
    ['/V'],
    [   ['String', 'segmentationParameterFile', '""', []],
        ['bool', 'applyDefaultSetupOnFailure', 'true', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.setup [ARG String segmentationParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.printSetup',
    'String',
    ['/V'],
    [],
    'String']
ok: FUNC <String cv.bioinspired.TransientAreasSegmentationModule.printSetup []>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.write',
    'void',
    ['/V'],
    [['String', 'fs', '', []]],
    'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.write [ARG String fs=]>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.run',
    'void',
    ['/V'],
    [['Mat', 'inputToSegment', '', []], ['int', 'channelIndex', '0', ['/C']]],
    'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.run [ARG Mat inputToSegment=, ARG int channelIndex=0]>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture',
    'void',
    ['/V'],
    [['Mat', 'transientAreas', '', ['/O']]],
    'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture [ARG Mat transientAreas=]>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers',
    'void',
    ['/V'],
    [],
    'void']
ok: FUNC <void cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers []>

--- Incoming ---
[   'cv.bioinspired.TransientAreasSegmentationModule.create',
    'Ptr_TransientAreasSegmentationModule',
    ['/S'],
    [['Size', 'inputSize', '', []]],
    'Ptr<TransientAreasSegmentationModule>']
ok: FUNC <Ptr_TransientAreasSegmentationModule cv.bioinspired.TransientAreasSegmentationModule.create [ARG Size inputSize=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp =====
Namespaces: ['cv', 'cv.bioinspired']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/bioinspired/include/opencv2/bioinspired/bioinspired.hpp


===== Generating... =====
CLASS cv::.Bioinspired : 
[CONST RETINA_COLOR_RANDOM=0, CONST RETINA_COLOR_DIAGONAL=1, CONST RETINA_COLOR_BAYER=2]
CLASS cv.bioinspired::.Retina : Algorithm
FUNC <Size cv.bioinspired.Retina.getInputSize []>
java: Size getInputSize()
FUNC <Size cv.bioinspired.Retina.getOutputSize []>
java: Size getOutputSize()
FUNC <void cv.bioinspired.Retina.setup [ARG String retinaParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>
java: void setup(String retinaParameterFile, boolean applyDefaultSetupOnFailure)
java: void setup(String retinaParameterFile)
java: void setup()
FUNC <String cv.bioinspired.Retina.printSetup []>
java: String printSetup()
FUNC <void cv.bioinspired.Retina.write [ARG String fs=]>
java: void write(String fs)
FUNC <void cv.bioinspired.Retina.setupOPLandIPLParvoChannel [ARG bool colorMode=true, ARG bool normaliseOutput=true, ARG float photoreceptorsLocalAdaptationSensitivity=0.7f, ARG float photoreceptorsTemporalConstant=0.5f, ARG float photoreceptorsSpatialConstant=0.53f, ARG float horizontalCellsGain=0.f, ARG float HcellsTemporalConstant=1.f, ARG float HcellsSpatialConstant=7.f, ARG float ganglionCellsSensitivity=0.7f]>
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant, float HcellsSpatialConstant, float ganglionCellsSensitivity)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant, float HcellsSpatialConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain, float HcellsTemporalConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant, float horizontalCellsGain)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant, float photoreceptorsSpatialConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity, float photoreceptorsTemporalConstant)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput, float photoreceptorsLocalAdaptationSensitivity)
java: void setupOPLandIPLParvoChannel(boolean colorMode, boolean normaliseOutput)
java: void setupOPLandIPLParvoChannel(boolean colorMode)
java: void setupOPLandIPLParvoChannel()
FUNC <void cv.bioinspired.Retina.setupIPLMagnoChannel [ARG bool normaliseOutput=true, ARG float parasolCells_beta=0.f, ARG float parasolCells_tau=0.f, ARG float parasolCells_k=7.f, ARG float amacrinCellsTemporalCutFrequency=1.2f, ARG float V0CompressionParameter=0.95f, ARG float localAdaptintegration_tau=0.f, ARG float localAdaptintegration_k=7.f]>
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter, float localAdaptintegration_tau, float localAdaptintegration_k)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter, float localAdaptintegration_tau)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency, float V0CompressionParameter)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k, float amacrinCellsTemporalCutFrequency)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau, float parasolCells_k)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta, float parasolCells_tau)
java: void setupIPLMagnoChannel(boolean normaliseOutput, float parasolCells_beta)
java: void setupIPLMagnoChannel(boolean normaliseOutput)
java: void setupIPLMagnoChannel()
FUNC <void cv.bioinspired.Retina.run [ARG Mat inputImage=]>
java: void run(Mat inputImage)
FUNC <void cv.bioinspired.Retina.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>
java: void applyFastToneMapping(Mat inputImage, Mat outputToneMappedImage)
FUNC <void cv.bioinspired.Retina.getParvo [ARG Mat retinaOutput_parvo=]>
java: void getParvo(Mat retinaOutput_parvo)
FUNC <void cv.bioinspired.Retina.getParvoRAW [ARG Mat retinaOutput_parvo=]>
java: void getParvoRAW(Mat retinaOutput_parvo)
FUNC <void cv.bioinspired.Retina.getMagno [ARG Mat retinaOutput_magno=]>
java: void getMagno(Mat retinaOutput_magno)
FUNC <void cv.bioinspired.Retina.getMagnoRAW [ARG Mat retinaOutput_magno=]>
java: void getMagnoRAW(Mat retinaOutput_magno)
FUNC <Mat cv.bioinspired.Retina.getMagnoRAW []>
java: Mat getMagnoRAW()
FUNC <Mat cv.bioinspired.Retina.getParvoRAW []>
java: Mat getParvoRAW()
FUNC <void cv.bioinspired.Retina.setColorSaturation [ARG bool saturateColors=true, ARG float colorSaturationValue=4.0f]>
java: void setColorSaturation(boolean saturateColors, float colorSaturationValue)
java: void setColorSaturation(boolean saturateColors)
java: void setColorSaturation()
FUNC <void cv.bioinspired.Retina.clearBuffers []>
java: void clearBuffers()
FUNC <void cv.bioinspired.Retina.activateMovingContoursProcessing [ARG bool activate=]>
java: void activateMovingContoursProcessing(boolean activate)
FUNC <void cv.bioinspired.Retina.activateContoursProcessing [ARG bool activate=]>
java: void activateContoursProcessing(boolean activate)
FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=]>
java: Retina create(Size inputSize)
FUNC <Ptr_Retina cv.bioinspired.Retina.create [ARG Size inputSize=, ARG bool colorMode=, ARG int colorSamplingMethod=RETINA_COLOR_BAYER, ARG bool useRetinaLogSampling=false, ARG float reductionFactor=1.0f, ARG float samplingStrength=10.0f]>
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling, float reductionFactor, float samplingStrength)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling, float reductionFactor)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod, boolean useRetinaLogSampling)
java: Retina create(Size inputSize, boolean colorMode, int colorSamplingMethod)
java: Retina create(Size inputSize, boolean colorMode)
CLASS cv.bioinspired::.RetinaFastToneMapping : Algorithm
FUNC <void cv.bioinspired.RetinaFastToneMapping.applyFastToneMapping [ARG Mat inputImage=, ARG Mat outputToneMappedImage=]>
java: void applyFastToneMapping(Mat inputImage, Mat outputToneMappedImage)
FUNC <void cv.bioinspired.RetinaFastToneMapping.setup [ARG float photoreceptorsNeighborhoodRadius=3.f, ARG float ganglioncellsNeighborhoodRadius=1.f, ARG float meanLuminanceModulatorK=1.f]>
java: void setup(float photoreceptorsNeighborhoodRadius, float ganglioncellsNeighborhoodRadius, float meanLuminanceModulatorK)
java: void setup(float photoreceptorsNeighborhoodRadius, float ganglioncellsNeighborhoodRadius)
java: void setup(float photoreceptorsNeighborhoodRadius)
java: void setup()
FUNC <Ptr_RetinaFastToneMapping cv.bioinspired.RetinaFastToneMapping.create [ARG Size inputSize=]>
java: RetinaFastToneMapping create(Size inputSize)
CLASS cv.bioinspired::.TransientAreasSegmentationModule : Algorithm
FUNC <Size cv.bioinspired.TransientAreasSegmentationModule.getSize []>
java: Size getSize()
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.setup [ARG String segmentationParameterFile="", ARG bool applyDefaultSetupOnFailure=true]>
java: void setup(String segmentationParameterFile, boolean applyDefaultSetupOnFailure)
java: void setup(String segmentationParameterFile)
java: void setup()
FUNC <String cv.bioinspired.TransientAreasSegmentationModule.printSetup []>
java: String printSetup()
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.write [ARG String fs=]>
java: void write(String fs)
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.run [ARG Mat inputToSegment=, ARG int channelIndex=0]>
java: void run(Mat inputToSegment, int channelIndex)
java: void run(Mat inputToSegment)
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.getSegmentationPicture [ARG Mat transientAreas=]>
java: void getSegmentationPicture(Mat transientAreas)
FUNC <void cv.bioinspired.TransientAreasSegmentationModule.clearAllBuffers []>
java: void clearAllBuffers()
FUNC <Ptr_TransientAreasSegmentationModule cv.bioinspired.TransientAreasSegmentationModule.create [ARG Size inputSize=]>
java: TransientAreasSegmentationModule create(Size inputSize)

=== MODULE: face (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face) ===


Files (10):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemarkAAM.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/bif.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facerec.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/face_alignment.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemark.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/mace.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/predict_collector.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemark_train.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemarkLBF.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Face : , name: Face, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.FaceRecognizer', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.FaceRecognizer : Algorithm, name: FaceRecognizer, base: Algorithm

--- Incoming ---
[   'cv.face.FaceRecognizer.train',
    'void',
    ['/V', '/PV'],
    [['vector_Mat', 'src', '', []], ['Mat', 'labels', '', []]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.train [ARG vector_Mat src=, ARG Mat labels=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.update',
    'void',
    ['/V'],
    [['vector_Mat', 'src', '', []], ['Mat', 'labels', '', []]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.update [ARG vector_Mat src=, ARG Mat labels=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.predict',
    'int',
    ['=predict_label', '/C'],
    [['Mat', 'src', '', []]],
    'int']
ok: FUNC <int cv.face.FaceRecognizer.predict [ARG Mat src=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.predict',
    'void',
    ['/C'],
    [   ['Mat', 'src', '', []],
        ['int', 'label', '', ['/O', '/Ref']],
        ['double', 'confidence', '', ['/O', '/Ref']]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG int label=, ARG double confidence=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.predict',
    'void',
    ['=predict_collect', '/C', '/V', '/PV'],
    [['Mat', 'src', '', []], ['Ptr_PredictCollector', 'collector', '', []]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG Ptr_PredictCollector collector=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.write',
    'void',
    ['/C', '/V'],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.write [ARG String filename=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.read',
    'void',
    ['/V'],
    [['String', 'filename', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.read [ARG String filename=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.setLabelInfo',
    'void',
    ['/V'],
    [['int', 'label', '', []], ['String', 'strInfo', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.face.FaceRecognizer.setLabelInfo [ARG int label=, ARG String strInfo=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.getLabelInfo',
    'String',
    ['/C', '/V'],
    [['int', 'label', '', []]],
    'String']
ok: FUNC <String cv.face.FaceRecognizer.getLabelInfo [ARG int label=]>

--- Incoming ---
[   'cv.face.FaceRecognizer.getLabelsByString',
    'vector_int',
    ['/C', '/V'],
    [['String', 'str', '', ['/C', '/Ref']]],
    'std::vector<int>']
ok: FUNC <vector_int cv.face.FaceRecognizer.getLabelsByString [ARG String str=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemarkAAM.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.FacemarkAAM', ': cv::face::FacemarkTrain', [], [], None]
ok: class CLASS cv.face::.FacemarkAAM : FacemarkTrain, name: FacemarkAAM, base: FacemarkTrain


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/bif.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.BIF', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.BIF : Algorithm, name: BIF, base: Algorithm

--- Incoming ---
['cv.face.BIF.getNumBands', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.face.BIF.getNumBands []>

--- Incoming ---
['cv.face.BIF.getNumRotations', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.face.BIF.getNumRotations []>

--- Incoming ---
[   'cv.face.BIF.compute',
    'void',
    ['/C', '/V', '/PV'],
    [['Mat', 'image', '', []], ['Mat', 'features', '', ['/O']]],
    'void']
ok: FUNC <void cv.face.BIF.compute [ARG Mat image=, ARG Mat features=]>

--- Incoming ---
[   'cv.face.BIF.create',
    'Ptr_BIF',
    ['/S'],
    [['int', 'num_bands', '8', []], ['int', 'num_rotations', '12', []]],
    'Ptr<BIF>']
ok: FUNC <Ptr_BIF cv.face.BIF.create [ARG int num_bands=8, ARG int num_rotations=12]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facerec.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
[   'class cv.face.BasicFaceRecognizer',
    ': cv::face::FaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.BasicFaceRecognizer : FaceRecognizer, name: BasicFaceRecognizer, base: FaceRecognizer

--- Incoming ---
['cv.face.BasicFaceRecognizer.getNumComponents', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.face.BasicFaceRecognizer.getNumComponents []>

--- Incoming ---
[   'cv.face.BasicFaceRecognizer.setNumComponents',
    'void',
    [],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.BasicFaceRecognizer.setNumComponents [ARG int val=]>

--- Incoming ---
['cv.face.BasicFaceRecognizer.getThreshold', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.face.BasicFaceRecognizer.getThreshold []>

--- Incoming ---
[   'cv.face.BasicFaceRecognizer.setThreshold',
    'void',
    [],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.BasicFaceRecognizer.setThreshold [ARG double val=]>

--- Incoming ---
[   'cv.face.BasicFaceRecognizer.getProjections',
    'vector_Mat',
    ['/C'],
    [],
    'std::vector<cv::Mat>']
ok: FUNC <vector_Mat cv.face.BasicFaceRecognizer.getProjections []>

--- Incoming ---
['cv.face.BasicFaceRecognizer.getLabels', 'Mat', ['/C'], [], 'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getLabels []>

--- Incoming ---
['cv.face.BasicFaceRecognizer.getEigenValues', 'Mat', ['/C'], [], 'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getEigenValues []>

--- Incoming ---
['cv.face.BasicFaceRecognizer.getEigenVectors', 'Mat', ['/C'], [], 'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getEigenVectors []>

--- Incoming ---
['cv.face.BasicFaceRecognizer.getMean', 'Mat', ['/C'], [], 'cv::Mat']
ok: FUNC <Mat cv.face.BasicFaceRecognizer.getMean []>

--- Incoming ---
[   'class cv.face.EigenFaceRecognizer',
    ': cv::face::BasicFaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.EigenFaceRecognizer : BasicFaceRecognizer, name: EigenFaceRecognizer, base: BasicFaceRecognizer

--- Incoming ---
[   'cv.face.EigenFaceRecognizer.create',
    'Ptr_EigenFaceRecognizer',
    ['/S'],
    [   ['int', 'num_components', '0', []],
        ['double', 'threshold', 'DBL_MAX', []]],
    'Ptr<EigenFaceRecognizer>']
ok: FUNC <Ptr_EigenFaceRecognizer cv.face.EigenFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>

--- Incoming ---
[   'class cv.face.FisherFaceRecognizer',
    ': cv::face::BasicFaceRecognizer',
    [],
    [],
    None]
ok: class CLASS cv.face::.FisherFaceRecognizer : BasicFaceRecognizer, name: FisherFaceRecognizer, base: BasicFaceRecognizer

--- Incoming ---
[   'cv.face.FisherFaceRecognizer.create',
    'Ptr_FisherFaceRecognizer',
    ['/S'],
    [   ['int', 'num_components', '0', []],
        ['double', 'threshold', 'DBL_MAX', []]],
    'Ptr<FisherFaceRecognizer>']
ok: FUNC <Ptr_FisherFaceRecognizer cv.face.FisherFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>

--- Incoming ---
['class cv.face.LBPHFaceRecognizer', ': cv::face::FaceRecognizer', [], [], None]
ok: class CLASS cv.face::.LBPHFaceRecognizer : FaceRecognizer, name: LBPHFaceRecognizer, base: FaceRecognizer

--- Incoming ---
['cv.face.LBPHFaceRecognizer.getGridX', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getGridX []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.setGridX',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setGridX [ARG int val=]>

--- Incoming ---
['cv.face.LBPHFaceRecognizer.getGridY', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getGridY []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.setGridY',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setGridY [ARG int val=]>

--- Incoming ---
['cv.face.LBPHFaceRecognizer.getRadius', 'int', ['/C', '/V', '/PV'], [], 'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getRadius []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.setRadius',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setRadius [ARG int val=]>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.getNeighbors',
    'int',
    ['/C', '/V', '/PV'],
    [],
    'int']
ok: FUNC <int cv.face.LBPHFaceRecognizer.getNeighbors []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.setNeighbors',
    'void',
    ['/V', '/PV'],
    [['int', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setNeighbors [ARG int val=]>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.getThreshold',
    'double',
    ['/C', '/V', '/PV'],
    [],
    'double']
ok: FUNC <double cv.face.LBPHFaceRecognizer.getThreshold []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.setThreshold',
    'void',
    ['/V', '/PV'],
    [['double', 'val', '', []]],
    'void']
ok: FUNC <void cv.face.LBPHFaceRecognizer.setThreshold [ARG double val=]>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.getHistograms',
    'vector_Mat',
    ['/C', '/V', '/PV'],
    [],
    'std::vector<cv::Mat>']
ok: FUNC <vector_Mat cv.face.LBPHFaceRecognizer.getHistograms []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.getLabels',
    'Mat',
    ['/C', '/V', '/PV'],
    [],
    'cv::Mat']
ok: FUNC <Mat cv.face.LBPHFaceRecognizer.getLabels []>

--- Incoming ---
[   'cv.face.LBPHFaceRecognizer.create',
    'Ptr_LBPHFaceRecognizer',
    ['/S'],
    [   ['int', 'radius', '1', []],
        ['int', 'neighbors', '8', []],
        ['int', 'grid_x', '8', []],
        ['int', 'grid_y', '8', []],
        ['double', 'threshold', 'DBL_MAX', []]],
    'Ptr<LBPHFaceRecognizer>']
ok: FUNC <Ptr_LBPHFaceRecognizer cv.face.LBPHFaceRecognizer.create [ARG int radius=1, ARG int neighbors=8, ARG int grid_x=8, ARG int grid_y=8, ARG double threshold=DBL_MAX]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/face_alignment.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.FacemarkKazemi', ': cv::face::Facemark', [], [], None]
ok: class CLASS cv.face::.FacemarkKazemi : Facemark, name: FacemarkKazemi, base: Facemark


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemark.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.Facemark', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.Facemark : Algorithm, name: Facemark, base: Algorithm

--- Incoming ---
[   'cv.face.Facemark.loadModel',
    'void',
    ['/V', '/PV'],
    [['String', 'model', '', []]],
    'void']
ok: FUNC <void cv.face.Facemark.loadModel [ARG String model=]>

--- Incoming ---
[   'cv.face.Facemark.fit',
    'bool',
    ['/V', '/PV'],
    [   ['Mat', 'image', '', []],
        ['Mat', 'faces', '', []],
        ['vector_Mat', 'landmarks', '', ['/O']]],
    'bool']
ok: FUNC <bool cv.face.Facemark.fit [ARG Mat image=, ARG vector_Rect faces=, ARG vector_vector_Point2f landmarks=]>

--- Incoming ---
['cv.face.createFacemarkAAM', 'Ptr_Facemark', [], [], 'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkAAM []>

--- Incoming ---
['cv.face.createFacemarkLBF', 'Ptr_Facemark', [], [], 'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkLBF []>

--- Incoming ---
['cv.face.createFacemarkKazemi', 'Ptr_Facemark', [], [], 'Ptr<Facemark>']
ok: FUNC <Ptr_Facemark cv.face..createFacemarkKazemi []>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/mace.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.MACE', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.face::.MACE : Algorithm, name: MACE, base: Algorithm

--- Incoming ---
[   'cv.face.MACE.salt',
    'void',
    ['/V', '/PV'],
    [['String', 'passphrase', '', ['/C', '/Ref']]],
    'void']
ok: FUNC <void cv.face.MACE.salt [ARG String passphrase=]>

--- Incoming ---
[   'cv.face.MACE.train',
    'void',
    ['/V', '/PV'],
    [['vector_Mat', 'images', '', []]],
    'void']
ok: FUNC <void cv.face.MACE.train [ARG vector_Mat images=]>

--- Incoming ---
[   'cv.face.MACE.same',
    'bool',
    ['/C', '/V', '/PV'],
    [['Mat', 'query', '', []]],
    'bool']
ok: FUNC <bool cv.face.MACE.same [ARG Mat query=]>

--- Incoming ---
[   'cv.face.MACE.load',
    'Ptr_MACE',
    ['/S'],
    [   ['String', 'filename', '', ['/C', '/Ref']],
        ['String', 'objname', 'String()', ['/C', '/Ref']]],
    'cv::Ptr<MACE>']
ok: FUNC <Ptr_MACE cv.face.MACE.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   'cv.face.MACE.create',
    'Ptr_MACE',
    ['/S'],
    [['int', 'IMGSIZE', '64', []]],
    'cv::Ptr<MACE>']
ok: FUNC <Ptr_MACE cv.face.MACE.create [ARG int IMGSIZE=64]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/predict_collector.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.PredictCollector', '', [], [], None]
ok: class CLASS cv.face::.PredictCollector : , name: PredictCollector, base: 

--- Incoming ---
[   'class cv.face.StandardCollector',
    ': cv::face::PredictCollector',
    [],
    [],
    None]
ok: class CLASS cv.face::.StandardCollector : PredictCollector, name: StandardCollector, base: PredictCollector

--- Incoming ---
['cv.face.StandardCollector.getMinLabel', 'int', ['/C'], [], 'int']
ok: FUNC <int cv.face.StandardCollector.getMinLabel []>

--- Incoming ---
['cv.face.StandardCollector.getMinDist', 'double', ['/C'], [], 'double']
ok: FUNC <double cv.face.StandardCollector.getMinDist []>

--- Incoming ---
[   'cv.face.StandardCollector.getResults',
    'vector_pair_int_and_double',
    ['/C'],
    [['bool', 'sorted', 'false', []]],
    'std::vector< std::pair<int, double> >']
ok: FUNC <vector_pair_int_and_double cv.face.StandardCollector.getResults [ARG bool sorted=false]>

--- Incoming ---
[   'cv.face.StandardCollector.create',
    'Ptr_StandardCollector',
    ['/S'],
    [['double', 'threshold', 'DBL_MAX', []]],
    'Ptr<StandardCollector>']
ok: FUNC <Ptr_StandardCollector cv.face.StandardCollector.create [ARG double threshold=DBL_MAX]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemark_train.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
[   'cv.face.getFacesHAAR',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Mat', 'faces', '', ['/O']],
        ['String', 'face_cascade_name', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.face..getFacesHAAR [ARG Mat image=, ARG Mat faces=, ARG String face_cascade_name=]>

--- Incoming ---
[   'cv.face.loadDatasetList',
    'bool',
    [],
    [   ['String', 'imageList', '', []],
        ['String', 'annotationList', '', []],
        ['vector_String', 'images', '', ['/Ref']],
        ['vector_String', 'annotations', '', ['/Ref']]],
    'bool']
ok: FUNC <bool cv.face..loadDatasetList [ARG String imageList=, ARG String annotationList=, ARG vector_String images=, ARG vector_String annotations=]>

--- Incoming ---
[   'cv.face.loadTrainingData',
    'bool',
    [],
    [   ['String', 'filename', '', []],
        ['vector_String', 'images', '', ['/Ref']],
        ['Mat', 'facePoints', '', ['/O']],
        ['char', 'delim', "' '", []],
        ['float', 'offset', '0.0f', []]],
    'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG String filename=, ARG vector_String images=, ARG Mat facePoints=, ARG char delim=' ', ARG float offset=0.0f]>

--- Incoming ---
[   'cv.face.loadTrainingData',
    'bool',
    [],
    [   ['String', 'imageList', '', []],
        ['String', 'groundTruth', '', []],
        ['vector_String', 'images', '', ['/Ref']],
        ['Mat', 'facePoints', '', ['/O']],
        ['float', 'offset', '0.0f', []]],
    'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG String imageList=, ARG String groundTruth=, ARG vector_String images=, ARG Mat facePoints=, ARG float offset=0.0f]>

--- Incoming ---
[   'cv.face.loadTrainingData',
    'bool',
    [],
    [   ['vector_String', 'filename', '', []],
        ['vector_vector_Point2f', 'trainlandmarks', '', ['/Ref']],
        ['vector_String', 'trainimages', '', ['/Ref']]],
    'bool']
ok: FUNC <bool cv.face..loadTrainingData [ARG vector_String filename=, ARG vector_vector_Point2f trainlandmarks=, ARG vector_String trainimages=]>

--- Incoming ---
[   'cv.face.loadFacePoints',
    'bool',
    [],
    [   ['String', 'filename', '', []],
        ['Mat', 'points', '', ['/O']],
        ['float', 'offset', '0.0f', []]],
    'bool']
ok: FUNC <bool cv.face..loadFacePoints [ARG String filename=, ARG Mat points=, ARG float offset=0.0f]>

--- Incoming ---
[   'cv.face.drawFacemarks',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Mat', 'points', '', []],
        ['Scalar', 'color', 'Scalar(255,0,0)', []]],
    'void']
ok: FUNC <void cv.face..drawFacemarks [ARG Mat image=, ARG Mat points=, ARG Scalar color=Scalar(255,0,0)]>

--- Incoming ---
['class cv.face.FacemarkTrain', ': cv::face::Facemark', [], [], None]
ok: class CLASS cv.face::.FacemarkTrain : Facemark, name: FacemarkTrain, base: Facemark


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/face/include/opencv2/face/facemarkLBF.hpp =====
Namespaces: ['cv', 'cv.face']

--- Incoming ---
['class cv.face.FacemarkLBF', ': cv::face::FacemarkTrain', [], [], None]
ok: class CLASS cv.face::.FacemarkLBF : FacemarkTrain, name: FacemarkLBF, base: FacemarkTrain


===== Generating... =====
CLASS cv::.Face : 
FUNC <Ptr_Facemark cv.face..createFacemarkAAM []>
java: Facemark createFacemarkAAM()
FUNC <Ptr_Facemark cv.face..createFacemarkLBF []>
java: Facemark createFacemarkLBF()
FUNC <Ptr_Facemark cv.face..createFacemarkKazemi []>
java: Facemark createFacemarkKazemi()
FUNC <bool cv.face..getFacesHAAR [ARG Mat image=, ARG Mat faces=, ARG String face_cascade_name=]>
java: boolean getFacesHAAR(Mat image, Mat faces, String face_cascade_name)
FUNC <bool cv.face..loadDatasetList [ARG String imageList=, ARG String annotationList=, ARG vector_String images=, ARG vector_String annotations=]>
java: boolean loadDatasetList(String imageList, String annotationList, List<String> images, List<String> annotations)
FUNC <bool cv.face..loadTrainingData [ARG String filename=, ARG vector_String images=, ARG Mat facePoints=, ARG char delim=' ', ARG float offset=0.0f]>
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints, char delim, float offset)
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints, char delim)
java: boolean loadTrainingData(String filename, List<String> images, Mat facePoints)
FUNC <bool cv.face..loadTrainingData [ARG String imageList=, ARG String groundTruth=, ARG vector_String images=, ARG Mat facePoints=, ARG float offset=0.0f]>
java: boolean loadTrainingData(String imageList, String groundTruth, List<String> images, Mat facePoints, float offset)
java: boolean loadTrainingData(String imageList, String groundTruth, List<String> images, Mat facePoints)
FUNC <bool cv.face..loadTrainingData [ARG vector_String filename=, ARG vector_vector_Point2f trainlandmarks=, ARG vector_String trainimages=]>
java: boolean loadTrainingData(List<String> filename, List<MatOfPoint2f> trainlandmarks, List<String> trainimages)
FUNC <bool cv.face..loadFacePoints [ARG String filename=, ARG Mat points=, ARG float offset=0.0f]>
java: boolean loadFacePoints(String filename, Mat points, float offset)
java: boolean loadFacePoints(String filename, Mat points)
FUNC <void cv.face..drawFacemarks [ARG Mat image=, ARG Mat points=, ARG Scalar color=Scalar(255,0,0)]>
java: void drawFacemarks(Mat image, Mat points, Scalar color)
java: void drawFacemarks(Mat image, Mat points)
CLASS cv.face::.BIF : Algorithm
FUNC <int cv.face.BIF.getNumBands []>
java: int getNumBands()
FUNC <int cv.face.BIF.getNumRotations []>
java: int getNumRotations()
FUNC <void cv.face.BIF.compute [ARG Mat image=, ARG Mat features=]>
java: void compute(Mat image, Mat features)
FUNC <Ptr_BIF cv.face.BIF.create [ARG int num_bands=8, ARG int num_rotations=12]>
java: BIF create(int num_bands, int num_rotations)
java: BIF create(int num_bands)
java: BIF create()
CLASS cv.face::.BasicFaceRecognizer : FaceRecognizer
FUNC <int cv.face.BasicFaceRecognizer.getNumComponents []>
java: int getNumComponents()
FUNC <void cv.face.BasicFaceRecognizer.setNumComponents [ARG int val=]>
java: void setNumComponents(int val)
FUNC <double cv.face.BasicFaceRecognizer.getThreshold []>
java: double getThreshold()
FUNC <void cv.face.BasicFaceRecognizer.setThreshold [ARG double val=]>
java: void setThreshold(double val)
FUNC <vector_Mat cv.face.BasicFaceRecognizer.getProjections []>
java: List<Mat> getProjections()
FUNC <Mat cv.face.BasicFaceRecognizer.getLabels []>
java: Mat getLabels()
FUNC <Mat cv.face.BasicFaceRecognizer.getEigenValues []>
java: Mat getEigenValues()
FUNC <Mat cv.face.BasicFaceRecognizer.getEigenVectors []>
java: Mat getEigenVectors()
FUNC <Mat cv.face.BasicFaceRecognizer.getMean []>
java: Mat getMean()
CLASS cv.face::.EigenFaceRecognizer : BasicFaceRecognizer
FUNC <Ptr_EigenFaceRecognizer cv.face.EigenFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>
java: EigenFaceRecognizer create(int num_components, double threshold)
java: EigenFaceRecognizer create(int num_components)
java: EigenFaceRecognizer create()
CLASS cv.face::.FaceRecognizer : Algorithm
FUNC <void cv.face.FaceRecognizer.train [ARG vector_Mat src=, ARG Mat labels=]>
java: void train(List<Mat> src, Mat labels)
FUNC <void cv.face.FaceRecognizer.update [ARG vector_Mat src=, ARG Mat labels=]>
java: void update(List<Mat> src, Mat labels)
FUNC <int cv.face.FaceRecognizer.predict [ARG Mat src=]>
java: int predict_label(Mat src)
FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG int label=, ARG double confidence=]>
java: void predict(Mat src, int[] label, double[] confidence)
FUNC <void cv.face.FaceRecognizer.predict [ARG Mat src=, ARG Ptr_PredictCollector collector=]>
java: void predict_collect(Mat src, PredictCollector collector)
FUNC <void cv.face.FaceRecognizer.write [ARG String filename=]>
java: void write(String filename)
FUNC <void cv.face.FaceRecognizer.read [ARG String filename=]>
java: void read(String filename)
FUNC <void cv.face.FaceRecognizer.setLabelInfo [ARG int label=, ARG String strInfo=]>
java: void setLabelInfo(int label, String strInfo)
FUNC <String cv.face.FaceRecognizer.getLabelInfo [ARG int label=]>
java: String getLabelInfo(int label)
FUNC <vector_int cv.face.FaceRecognizer.getLabelsByString [ARG String str=]>
java: MatOfInt getLabelsByString(String str)
CLASS cv.face::.Facemark : Algorithm
FUNC <void cv.face.Facemark.loadModel [ARG String model=]>
java: void loadModel(String model)
FUNC <bool cv.face.Facemark.fit [ARG Mat image=, ARG vector_Rect faces=, ARG vector_vector_Point2f landmarks=]>
java: boolean fit(Mat image, MatOfRect faces, List<MatOfPoint2f> landmarks)
CLASS cv.face::.FacemarkAAM : FacemarkTrain
CLASS cv.face::.FacemarkKazemi : Facemark
CLASS cv.face::.FacemarkLBF : FacemarkTrain
CLASS cv.face::.FacemarkTrain : Facemark
CLASS cv.face::.FisherFaceRecognizer : BasicFaceRecognizer
FUNC <Ptr_FisherFaceRecognizer cv.face.FisherFaceRecognizer.create [ARG int num_components=0, ARG double threshold=DBL_MAX]>
java: FisherFaceRecognizer create(int num_components, double threshold)
java: FisherFaceRecognizer create(int num_components)
java: FisherFaceRecognizer create()
CLASS cv.face::.LBPHFaceRecognizer : FaceRecognizer
FUNC <int cv.face.LBPHFaceRecognizer.getGridX []>
java: int getGridX()
FUNC <void cv.face.LBPHFaceRecognizer.setGridX [ARG int val=]>
java: void setGridX(int val)
FUNC <int cv.face.LBPHFaceRecognizer.getGridY []>
java: int getGridY()
FUNC <void cv.face.LBPHFaceRecognizer.setGridY [ARG int val=]>
java: void setGridY(int val)
FUNC <int cv.face.LBPHFaceRecognizer.getRadius []>
java: int getRadius()
FUNC <void cv.face.LBPHFaceRecognizer.setRadius [ARG int val=]>
java: void setRadius(int val)
FUNC <int cv.face.LBPHFaceRecognizer.getNeighbors []>
java: int getNeighbors()
FUNC <void cv.face.LBPHFaceRecognizer.setNeighbors [ARG int val=]>
java: void setNeighbors(int val)
FUNC <double cv.face.LBPHFaceRecognizer.getThreshold []>
java: double getThreshold()
FUNC <void cv.face.LBPHFaceRecognizer.setThreshold [ARG double val=]>
java: void setThreshold(double val)
FUNC <vector_Mat cv.face.LBPHFaceRecognizer.getHistograms []>
java: List<Mat> getHistograms()
FUNC <Mat cv.face.LBPHFaceRecognizer.getLabels []>
java: Mat getLabels()
FUNC <Ptr_LBPHFaceRecognizer cv.face.LBPHFaceRecognizer.create [ARG int radius=1, ARG int neighbors=8, ARG int grid_x=8, ARG int grid_y=8, ARG double threshold=DBL_MAX]>
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x, int grid_y, double threshold)
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x, int grid_y)
java: LBPHFaceRecognizer create(int radius, int neighbors, int grid_x)
java: LBPHFaceRecognizer create(int radius, int neighbors)
java: LBPHFaceRecognizer create(int radius)
java: LBPHFaceRecognizer create()
CLASS cv.face::.MACE : Algorithm
FUNC <void cv.face.MACE.salt [ARG String passphrase=]>
java: void salt(String passphrase)
FUNC <void cv.face.MACE.train [ARG vector_Mat images=]>
java: void train(List<Mat> images)
FUNC <bool cv.face.MACE.same [ARG Mat query=]>
java: boolean same(Mat query)
FUNC <Ptr_MACE cv.face.MACE.load [ARG String filename=, ARG String objname=String()]>
java: MACE load(String filename, String objname)
java: MACE load(String filename)
FUNC <Ptr_MACE cv.face.MACE.create [ARG int IMGSIZE=64]>
java: MACE create(int IMGSIZE)
java: MACE create()
CLASS cv.face::.PredictCollector : 
CLASS cv.face::.StandardCollector : PredictCollector
FUNC <int cv.face.StandardCollector.getMinLabel []>
java: int getMinLabel()
FUNC <double cv.face.StandardCollector.getMinDist []>
java: double getMinDist()
FUNC <vector_pair_int_and_double cv.face.StandardCollector.getResults [ARG bool sorted=false]>
SKIP:vector_pair_int_and_double cv::face::StandardCollector::getResults(bool sorted = false)	 due to RET type vector_pair_int_and_double
FUNC <Ptr_StandardCollector cv.face.StandardCollector.create [ARG double threshold=DBL_MAX]>
java: StandardCollector create(double threshold)
java: StandardCollector create()

=== MODULE: tracking (/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking) ===


Files (9):
['/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/feature.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_internals.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_legacy.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp',
 '/home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp']

Common headers (0):
[]
ok: class CLASS cv::.Tracking : , name: Tracking, base: 


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking.hpp =====
Namespaces: ['cv']

--- Incoming ---
['class cv.TrackerCSRT', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerCSRT : Tracker, name: TrackerCSRT, base: Tracker

--- Incoming ---
[   'struct cv.TrackerCSRT.Params',
    '',
    ['/Simple'],
    [   ['bool', 'use_hog', '', ['/RW']],
        ['bool', 'use_color_names', '', ['/RW']],
        ['bool', 'use_gray', '', ['/RW']],
        ['bool', 'use_rgb', '', ['/RW']],
        ['bool', 'use_channel_weights', '', ['/RW']],
        ['bool', 'use_segmentation', '', ['/RW']],
        ['string', 'window_function', '', ['/RW']],
        ['float', 'kaiser_alpha', '', ['/RW']],
        ['float', 'cheb_attenuation', '', ['/RW']],
        ['float', 'template_size', '', ['/RW']],
        ['float', 'gsl_sigma', '', ['/RW']],
        ['float', 'hog_orientations', '', ['/RW']],
        ['float', 'hog_clip', '', ['/RW']],
        ['float', 'padding', '', ['/RW']],
        ['float', 'filter_lr', '', ['/RW']],
        ['float', 'weights_lr', '', ['/RW']],
        ['int', 'num_hog_channels_used', '', ['/RW']],
        ['int', 'admm_iterations', '', ['/RW']],
        ['int', 'histogram_bins', '', ['/RW']],
        ['float', 'histogram_lr', '', ['/RW']],
        ['int', 'background_ratio', '', ['/RW']],
        ['int', 'number_of_scales', '', ['/RW']],
        ['float', 'scale_sigma_factor', '', ['/RW']],
        ['float', 'scale_model_max_area', '', ['/RW']],
        ['float', 'scale_lr', '', ['/RW']],
        ['float', 'scale_step', '', ['/RW']],
        ['float', 'psr_threshold', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerCSRT.TrackerCSRT_Params : , name: TrackerCSRT_Params, base: 

--- Incoming ---
['cv.TrackerCSRT.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerCSRT.Params.TrackerCSRT_Params []>

--- Incoming ---
[   'cv.TrackerCSRT.create',
    'Ptr_TrackerCSRT',
    ['/S'],
    [   [   'TrackerCSRT_Params',
            'parameters',
            'TrackerCSRT::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerCSRT>']
ok: FUNC <Ptr_TrackerCSRT cv.TrackerCSRT.create [ARG TrackerCSRT_Params parameters=TrackerCSRT::Params()]>

--- Incoming ---
[   'cv.TrackerCSRT.setInitialMask',
    'void',
    ['/V', '/PV'],
    [['Mat', 'mask', '', []]],
    'void']
ok: FUNC <void cv.TrackerCSRT.setInitialMask [ARG Mat mask=]>

--- Incoming ---
['class cv.TrackerKCF', ': cv::Tracker', [], [], None]
ok: class CLASS cv::.TrackerKCF : Tracker, name: TrackerKCF, base: Tracker

--- Incoming ---
[   'enum cv.TrackerKCF.MODE',
    '',
    [],
    [   ['const cv.TrackerKCF.GRAY', '(1 << 0)', [], [], None, ''],
        ['const cv.TrackerKCF.CN', '(1 << 1)', [], [], None, ''],
        ['const cv.TrackerKCF.CUSTOM', '(1 << 2)', [], [], None, '']],
    None]
ok: CONST GRAY=(1 << 0)
ok: CONST CN=(1 << 1)
ok: CONST CUSTOM=(1 << 2)

--- Incoming ---
[   'struct cv.TrackerKCF.Params',
    '',
    ['/Simple'],
    [   ['float', 'detect_thresh', '', ['/RW']],
        ['float', 'sigma', '', ['/RW']],
        ['float', 'lambda', '', ['/RW']],
        ['float', 'interp_factor', '', ['/RW']],
        ['float', 'output_sigma_factor', '', ['/RW']],
        ['float', 'pca_learning_rate', '', ['/RW']],
        ['bool', 'resize', '', ['/RW']],
        ['bool', 'split_coeff', '', ['/RW']],
        ['bool', 'wrap_kernel', '', ['/RW']],
        ['bool', 'compress_feature', '', ['/RW']],
        ['int', 'max_patch_size', '', ['/RW']],
        ['int', 'compressed_size', '', ['/RW']],
        ['int', 'desc_pca', '', ['/RW']],
        ['int', 'desc_npca', '', ['/RW']]],
    None]
ok: class CLASS cv::TrackerKCF.TrackerKCF_Params : , name: TrackerKCF_Params, base: 

--- Incoming ---
['cv.TrackerKCF.Params.Params', '', [], [], None]
ok: FUNC < cv.TrackerKCF.Params.TrackerKCF_Params []>

--- Incoming ---
[   'cv.TrackerKCF.create',
    'Ptr_TrackerKCF',
    ['/S'],
    [   [   'TrackerKCF_Params',
            'parameters',
            'TrackerKCF::Params()',
            ['/C', '/Ref']]],
    'Ptr<TrackerKCF>']
ok: FUNC <Ptr_TrackerKCF cv.TrackerKCF.create [ARG TrackerKCF_Params parameters=TrackerKCF::Params()]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_by_matching.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/feature.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm']

--- Incoming ---
[   'enum cv.detail.CvFeatureParams.FeatureType',
    '',
    [],
    [   ['const cv.detail.CvFeatureParams.HAAR', '0', [], [], None, ''],
        ['const cv.detail.CvFeatureParams.LBP', '1', [], [], None, ''],
        ['const cv.detail.CvFeatureParams.HOG', '2', [], [], None, '']],
    None]
class not found: CONST HAAR=0
ok: CONST CvFeatureParams_HAAR=0
class not found: CONST LBP=1
ok: CONST CvFeatureParams_LBP=1
class not found: CONST HOG=2
ok: CONST CvFeatureParams_HOG=2


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_internals.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm']

--- Incoming ---
[   'enum cv.detail.TrackerContribSamplerCSC.<unnamed>',
    '',
    [],
    [   [   'const cv.detail.TrackerContribSamplerCSC.MODE_INIT_POS',
            '1',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerContribSamplerCSC.MODE_INIT_NEG',
            '2',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerContribSamplerCSC.MODE_TRACK_POS',
            '3',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerContribSamplerCSC.MODE_TRACK_NEG',
            '4',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerContribSamplerCSC.MODE_DETECT',
            '5',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST MODE_INIT_POS=1
ok: CONST TrackerContribSamplerCSC_MODE_INIT_POS=1
class not found: CONST MODE_INIT_NEG=2
ok: CONST TrackerContribSamplerCSC_MODE_INIT_NEG=2
class not found: CONST MODE_TRACK_POS=3
ok: CONST TrackerContribSamplerCSC_MODE_TRACK_POS=3
class not found: CONST MODE_TRACK_NEG=4
ok: CONST TrackerContribSamplerCSC_MODE_TRACK_NEG=4
class not found: CONST MODE_DETECT=5
ok: CONST TrackerContribSamplerCSC_MODE_DETECT=5

--- Incoming ---
[   'enum cv.detail.TrackerSamplerCS.<unnamed>',
    '',
    [],
    [   [   'const cv.detail.TrackerSamplerCS.MODE_POSITIVE',
            '1',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCS.MODE_NEGATIVE',
            '2',
            [],
            [],
            None,
            ''],
        [   'const cv.detail.TrackerSamplerCS.MODE_CLASSIFY',
            '3',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST MODE_POSITIVE=1
ok: CONST TrackerSamplerCS_MODE_POSITIVE=1
class not found: CONST MODE_NEGATIVE=2
ok: CONST TrackerSamplerCS_MODE_NEGATIVE=2
class not found: CONST MODE_CLASSIFY=3
ok: CONST TrackerSamplerCS_MODE_CLASSIFY=3


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking_legacy.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm', 'cv.legacy']

--- Incoming ---
['class cv.legacy.Tracker', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.legacy::.legacy_Tracker : Algorithm, name: legacy_Tracker, base: Algorithm

--- Incoming ---
[   'cv.legacy.Tracker.init',
    'bool',
    [],
    [['Mat', 'image', '', []], ['Rect2d', 'boundingBox', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.legacy.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   'cv.legacy.Tracker.update',
    'bool',
    [],
    [['Mat', 'image', '', []], ['Rect2d', 'boundingBox', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv.legacy.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
['class cv.legacy.TrackerMIL', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerMIL : legacy_Tracker, name: legacy_TrackerMIL, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerMIL.create',
    'Ptr_legacy_TrackerMIL',
    ['/S'],
    [],
    'Ptr<legacy::TrackerMIL>']
ok: FUNC <Ptr_legacy_TrackerMIL cv.legacy.TrackerMIL.create []>

--- Incoming ---
['class cv.legacy.TrackerBoosting', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerBoosting : legacy_Tracker, name: legacy_TrackerBoosting, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerBoosting.create',
    'Ptr_legacy_TrackerBoosting',
    ['/S'],
    [],
    'Ptr<legacy::TrackerBoosting>']
ok: FUNC <Ptr_legacy_TrackerBoosting cv.legacy.TrackerBoosting.create []>

--- Incoming ---
['class cv.legacy.TrackerMedianFlow', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerMedianFlow : legacy_Tracker, name: legacy_TrackerMedianFlow, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerMedianFlow.create',
    'Ptr_legacy_TrackerMedianFlow',
    ['/S'],
    [],
    'Ptr<legacy::TrackerMedianFlow>']
ok: FUNC <Ptr_legacy_TrackerMedianFlow cv.legacy.TrackerMedianFlow.create []>

--- Incoming ---
['class cv.legacy.TrackerTLD', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerTLD : legacy_Tracker, name: legacy_TrackerTLD, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerTLD.create',
    'Ptr_legacy_TrackerTLD',
    ['/S'],
    [],
    'Ptr<legacy::TrackerTLD>']
ok: FUNC <Ptr_legacy_TrackerTLD cv.legacy.TrackerTLD.create []>

--- Incoming ---
['class cv.legacy.TrackerKCF', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerKCF : legacy_Tracker, name: legacy_TrackerKCF, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerKCF.create',
    'Ptr_legacy_TrackerKCF',
    ['/S'],
    [],
    'Ptr<legacy::TrackerKCF>']
ok: FUNC <Ptr_legacy_TrackerKCF cv.legacy.TrackerKCF.create []>

--- Incoming ---
['class cv.legacy.TrackerMOSSE', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerMOSSE : legacy_Tracker, name: legacy_TrackerMOSSE, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerMOSSE.create',
    'Ptr_legacy_TrackerMOSSE',
    ['/S'],
    [],
    'Ptr<legacy::TrackerMOSSE>']
ok: FUNC <Ptr_legacy_TrackerMOSSE cv.legacy.TrackerMOSSE.create []>

--- Incoming ---
['class cv.legacy.MultiTracker', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.legacy::.legacy_MultiTracker : Algorithm, name: legacy_MultiTracker, base: Algorithm

--- Incoming ---
['cv.legacy.MultiTracker.MultiTracker', '', [], [], None]
ok: FUNC < cv.legacy.MultiTracker.MultiTracker []>

--- Incoming ---
[   'cv.legacy.MultiTracker.add',
    'bool',
    [],
    [   ['Ptr_legacy_Tracker', 'newTracker', '', []],
        ['Mat', 'image', '', []],
        ['Rect2d', 'boundingBox', '', ['/C', '/Ref']]],
    'bool']
ok: FUNC <bool cv.legacy.MultiTracker.add [ARG Ptr_legacy_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>

--- Incoming ---
[   'cv.legacy.MultiTracker.update',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['vector_Rect2d', 'boundingBox', '', ['/O', '/Ref']]],
    'bool']
ok: FUNC <bool cv.legacy.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>

--- Incoming ---
[   'cv.legacy.MultiTracker.getObjects',
    'vector_Rect2d',
    ['/C'],
    [],
    'std::vector<Rect2d>']
ok: FUNC <vector_Rect2d cv.legacy.MultiTracker.getObjects []>

--- Incoming ---
[   'cv.legacy.MultiTracker.create',
    'Ptr_MultiTracker',
    ['/S'],
    [],
    'Ptr<MultiTracker>']
ok: FUNC <Ptr_MultiTracker cv.legacy.MultiTracker.create []>

--- Incoming ---
['class cv.legacy.TrackerCSRT', ': cv::legacy::Tracker', [], [], None]
ok: class CLASS cv.legacy::.legacy_TrackerCSRT : legacy_Tracker, name: legacy_TrackerCSRT, base: legacy_Tracker

--- Incoming ---
[   'cv.legacy.TrackerCSRT.create',
    'Ptr_legacy_TrackerCSRT',
    ['/S'],
    [],
    'Ptr<legacy::TrackerCSRT>']
ok: FUNC <Ptr_legacy_TrackerCSRT cv.legacy.TrackerCSRT.create []>

--- Incoming ---
[   'cv.legacy.TrackerCSRT.setInitialMask',
    'void',
    ['/V', '/PV'],
    [['Mat', 'mask', '', []]],
    'void']
ok: FUNC <void cv.legacy.TrackerCSRT.setInitialMask [ARG Mat mask=]>

--- Incoming ---
[   'cv.legacy.upgradeTrackingAPI',
    'Ptr_Tracker',
    [],
    [['Ptr_legacy_Tracker', 'legacy_tracker', '', ['/C', '/Ref']]],
    'Ptr<cv::Tracker>']
ok: FUNC <Ptr_Tracker cv.legacy..upgradeTrackingAPI [ARG Ptr_legacy_Tracker legacy_tracker=]>


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm', 'cv.legacy']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tracking.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm', 'cv.legacy']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/kalman_filters.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm', 'cv.detail.tld', 'cv.legacy']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/tldDataset.hpp


===== Header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp =====
Namespaces: ['cv', 'cv.detail', 'cv.detail.tbm', 'cv.detail.tld', 'cv.legacy']
Ignore header: /home/derek/Documents/thesis-ecj/ecj/opencv/../opencv_contrib/modules/tracking/include/opencv2/tracking/onlineBoosting.hpp


===== Generating... =====
CLASS cv::.TrackerCSRT : Tracker
FUNC <Ptr_TrackerCSRT cv.TrackerCSRT.create [ARG TrackerCSRT_Params parameters=TrackerCSRT::Params()]>
java: TrackerCSRT create(TrackerCSRT_Params parameters)
java: TrackerCSRT create()
FUNC <void cv.TrackerCSRT.setInitialMask [ARG Mat mask=]>
java: void setInitialMask(Mat mask)
CLASS cv::TrackerCSRT.TrackerCSRT_Params : 
FUNC < cv.TrackerCSRT.Params.TrackerCSRT_Params []>
java:  TrackerCSRT_Params()
FUNC <bool cv.TrackerCSRT.Params.get_use_hog []>
java: boolean get_use_hog()
FUNC <void cv.TrackerCSRT.Params.set_use_hog [ARG bool use_hog=]>
java: void set_use_hog(boolean use_hog)
FUNC <bool cv.TrackerCSRT.Params.get_use_color_names []>
java: boolean get_use_color_names()
FUNC <void cv.TrackerCSRT.Params.set_use_color_names [ARG bool use_color_names=]>
java: void set_use_color_names(boolean use_color_names)
FUNC <bool cv.TrackerCSRT.Params.get_use_gray []>
java: boolean get_use_gray()
FUNC <void cv.TrackerCSRT.Params.set_use_gray [ARG bool use_gray=]>
java: void set_use_gray(boolean use_gray)
FUNC <bool cv.TrackerCSRT.Params.get_use_rgb []>
java: boolean get_use_rgb()
FUNC <void cv.TrackerCSRT.Params.set_use_rgb [ARG bool use_rgb=]>
java: void set_use_rgb(boolean use_rgb)
FUNC <bool cv.TrackerCSRT.Params.get_use_channel_weights []>
java: boolean get_use_channel_weights()
FUNC <void cv.TrackerCSRT.Params.set_use_channel_weights [ARG bool use_channel_weights=]>
java: void set_use_channel_weights(boolean use_channel_weights)
FUNC <bool cv.TrackerCSRT.Params.get_use_segmentation []>
java: boolean get_use_segmentation()
FUNC <void cv.TrackerCSRT.Params.set_use_segmentation [ARG bool use_segmentation=]>
java: void set_use_segmentation(boolean use_segmentation)
FUNC <string cv.TrackerCSRT.Params.get_window_function []>
java: String get_window_function()
FUNC <void cv.TrackerCSRT.Params.set_window_function [ARG string window_function=]>
java: void set_window_function(String window_function)
FUNC <float cv.TrackerCSRT.Params.get_kaiser_alpha []>
java: float get_kaiser_alpha()
FUNC <void cv.TrackerCSRT.Params.set_kaiser_alpha [ARG float kaiser_alpha=]>
java: void set_kaiser_alpha(float kaiser_alpha)
FUNC <float cv.TrackerCSRT.Params.get_cheb_attenuation []>
java: float get_cheb_attenuation()
FUNC <void cv.TrackerCSRT.Params.set_cheb_attenuation [ARG float cheb_attenuation=]>
java: void set_cheb_attenuation(float cheb_attenuation)
FUNC <float cv.TrackerCSRT.Params.get_template_size []>
java: float get_template_size()
FUNC <void cv.TrackerCSRT.Params.set_template_size [ARG float template_size=]>
java: void set_template_size(float template_size)
FUNC <float cv.TrackerCSRT.Params.get_gsl_sigma []>
java: float get_gsl_sigma()
FUNC <void cv.TrackerCSRT.Params.set_gsl_sigma [ARG float gsl_sigma=]>
java: void set_gsl_sigma(float gsl_sigma)
FUNC <float cv.TrackerCSRT.Params.get_hog_orientations []>
java: float get_hog_orientations()
FUNC <void cv.TrackerCSRT.Params.set_hog_orientations [ARG float hog_orientations=]>
java: void set_hog_orientations(float hog_orientations)
FUNC <float cv.TrackerCSRT.Params.get_hog_clip []>
java: float get_hog_clip()
FUNC <void cv.TrackerCSRT.Params.set_hog_clip [ARG float hog_clip=]>
java: void set_hog_clip(float hog_clip)
FUNC <float cv.TrackerCSRT.Params.get_padding []>
java: float get_padding()
FUNC <void cv.TrackerCSRT.Params.set_padding [ARG float padding=]>
java: void set_padding(float padding)
FUNC <float cv.TrackerCSRT.Params.get_filter_lr []>
java: float get_filter_lr()
FUNC <void cv.TrackerCSRT.Params.set_filter_lr [ARG float filter_lr=]>
java: void set_filter_lr(float filter_lr)
FUNC <float cv.TrackerCSRT.Params.get_weights_lr []>
java: float get_weights_lr()
FUNC <void cv.TrackerCSRT.Params.set_weights_lr [ARG float weights_lr=]>
java: void set_weights_lr(float weights_lr)
FUNC <int cv.TrackerCSRT.Params.get_num_hog_channels_used []>
java: int get_num_hog_channels_used()
FUNC <void cv.TrackerCSRT.Params.set_num_hog_channels_used [ARG int num_hog_channels_used=]>
java: void set_num_hog_channels_used(int num_hog_channels_used)
FUNC <int cv.TrackerCSRT.Params.get_admm_iterations []>
java: int get_admm_iterations()
FUNC <void cv.TrackerCSRT.Params.set_admm_iterations [ARG int admm_iterations=]>
java: void set_admm_iterations(int admm_iterations)
FUNC <int cv.TrackerCSRT.Params.get_histogram_bins []>
java: int get_histogram_bins()
FUNC <void cv.TrackerCSRT.Params.set_histogram_bins [ARG int histogram_bins=]>
java: void set_histogram_bins(int histogram_bins)
FUNC <float cv.TrackerCSRT.Params.get_histogram_lr []>
java: float get_histogram_lr()
FUNC <void cv.TrackerCSRT.Params.set_histogram_lr [ARG float histogram_lr=]>
java: void set_histogram_lr(float histogram_lr)
FUNC <int cv.TrackerCSRT.Params.get_background_ratio []>
java: int get_background_ratio()
FUNC <void cv.TrackerCSRT.Params.set_background_ratio [ARG int background_ratio=]>
java: void set_background_ratio(int background_ratio)
FUNC <int cv.TrackerCSRT.Params.get_number_of_scales []>
java: int get_number_of_scales()
FUNC <void cv.TrackerCSRT.Params.set_number_of_scales [ARG int number_of_scales=]>
java: void set_number_of_scales(int number_of_scales)
FUNC <float cv.TrackerCSRT.Params.get_scale_sigma_factor []>
java: float get_scale_sigma_factor()
FUNC <void cv.TrackerCSRT.Params.set_scale_sigma_factor [ARG float scale_sigma_factor=]>
java: void set_scale_sigma_factor(float scale_sigma_factor)
FUNC <float cv.TrackerCSRT.Params.get_scale_model_max_area []>
java: float get_scale_model_max_area()
FUNC <void cv.TrackerCSRT.Params.set_scale_model_max_area [ARG float scale_model_max_area=]>
java: void set_scale_model_max_area(float scale_model_max_area)
FUNC <float cv.TrackerCSRT.Params.get_scale_lr []>
java: float get_scale_lr()
FUNC <void cv.TrackerCSRT.Params.set_scale_lr [ARG float scale_lr=]>
java: void set_scale_lr(float scale_lr)
FUNC <float cv.TrackerCSRT.Params.get_scale_step []>
java: float get_scale_step()
FUNC <void cv.TrackerCSRT.Params.set_scale_step [ARG float scale_step=]>
java: void set_scale_step(float scale_step)
FUNC <float cv.TrackerCSRT.Params.get_psr_threshold []>
java: float get_psr_threshold()
FUNC <void cv.TrackerCSRT.Params.set_psr_threshold [ARG float psr_threshold=]>
java: void set_psr_threshold(float psr_threshold)
CLASS cv::.TrackerKCF : Tracker
[CONST GRAY=(1 << 0), CONST CN=(1 << 1), CONST CUSTOM=(1 << 2)]
FUNC <Ptr_TrackerKCF cv.TrackerKCF.create [ARG TrackerKCF_Params parameters=TrackerKCF::Params()]>
java: TrackerKCF create(TrackerKCF_Params parameters)
java: TrackerKCF create()
CLASS cv::TrackerKCF.TrackerKCF_Params : 
FUNC < cv.TrackerKCF.Params.TrackerKCF_Params []>
java:  TrackerKCF_Params()
FUNC <float cv.TrackerKCF.Params.get_detect_thresh []>
java: float get_detect_thresh()
FUNC <void cv.TrackerKCF.Params.set_detect_thresh [ARG float detect_thresh=]>
java: void set_detect_thresh(float detect_thresh)
FUNC <float cv.TrackerKCF.Params.get_sigma []>
java: float get_sigma()
FUNC <void cv.TrackerKCF.Params.set_sigma [ARG float sigma=]>
java: void set_sigma(float sigma)
FUNC <float cv.TrackerKCF.Params.get_lambda []>
java: float get_lambda()
FUNC <void cv.TrackerKCF.Params.set_lambda [ARG float lambda=]>
java: void set_lambda(float lambda)
FUNC <float cv.TrackerKCF.Params.get_interp_factor []>
java: float get_interp_factor()
FUNC <void cv.TrackerKCF.Params.set_interp_factor [ARG float interp_factor=]>
java: void set_interp_factor(float interp_factor)
FUNC <float cv.TrackerKCF.Params.get_output_sigma_factor []>
java: float get_output_sigma_factor()
FUNC <void cv.TrackerKCF.Params.set_output_sigma_factor [ARG float output_sigma_factor=]>
java: void set_output_sigma_factor(float output_sigma_factor)
FUNC <float cv.TrackerKCF.Params.get_pca_learning_rate []>
java: float get_pca_learning_rate()
FUNC <void cv.TrackerKCF.Params.set_pca_learning_rate [ARG float pca_learning_rate=]>
java: void set_pca_learning_rate(float pca_learning_rate)
FUNC <bool cv.TrackerKCF.Params.get_resize []>
java: boolean get_resize()
FUNC <void cv.TrackerKCF.Params.set_resize [ARG bool resize=]>
java: void set_resize(boolean resize)
FUNC <bool cv.TrackerKCF.Params.get_split_coeff []>
java: boolean get_split_coeff()
FUNC <void cv.TrackerKCF.Params.set_split_coeff [ARG bool split_coeff=]>
java: void set_split_coeff(boolean split_coeff)
FUNC <bool cv.TrackerKCF.Params.get_wrap_kernel []>
java: boolean get_wrap_kernel()
FUNC <void cv.TrackerKCF.Params.set_wrap_kernel [ARG bool wrap_kernel=]>
java: void set_wrap_kernel(boolean wrap_kernel)
FUNC <bool cv.TrackerKCF.Params.get_compress_feature []>
java: boolean get_compress_feature()
FUNC <void cv.TrackerKCF.Params.set_compress_feature [ARG bool compress_feature=]>
java: void set_compress_feature(boolean compress_feature)
FUNC <int cv.TrackerKCF.Params.get_max_patch_size []>
java: int get_max_patch_size()
FUNC <void cv.TrackerKCF.Params.set_max_patch_size [ARG int max_patch_size=]>
java: void set_max_patch_size(int max_patch_size)
FUNC <int cv.TrackerKCF.Params.get_compressed_size []>
java: int get_compressed_size()
FUNC <void cv.TrackerKCF.Params.set_compressed_size [ARG int compressed_size=]>
java: void set_compressed_size(int compressed_size)
FUNC <int cv.TrackerKCF.Params.get_desc_pca []>
java: int get_desc_pca()
FUNC <void cv.TrackerKCF.Params.set_desc_pca [ARG int desc_pca=]>
java: void set_desc_pca(int desc_pca)
FUNC <int cv.TrackerKCF.Params.get_desc_npca []>
java: int get_desc_npca()
FUNC <void cv.TrackerKCF.Params.set_desc_npca [ARG int desc_npca=]>
java: void set_desc_npca(int desc_npca)
CLASS cv::.Tracking : 
[CONST TrackerContribSamplerCSC_MODE_INIT_POS=1, CONST TrackerContribSamplerCSC_MODE_INIT_NEG=2, CONST TrackerContribSamplerCSC_MODE_TRACK_POS=3, CONST TrackerContribSamplerCSC_MODE_TRACK_NEG=4, CONST TrackerContribSamplerCSC_MODE_DETECT=5, CONST TrackerSamplerCS_MODE_POSITIVE=1, CONST TrackerSamplerCS_MODE_NEGATIVE=2, CONST TrackerSamplerCS_MODE_CLASSIFY=3]
[CONST CvFeatureParams_HAAR=0, CONST CvFeatureParams_LBP=1, CONST CvFeatureParams_HOG=2]
FUNC <Ptr_Tracker cv.legacy..upgradeTrackingAPI [ARG Ptr_legacy_Tracker legacy_tracker=]>
java: Tracker legacy_upgradeTrackingAPI(legacy_Tracker legacy_tracker)
CLASS cv.legacy::.legacy_MultiTracker : Algorithm
FUNC < cv.legacy.MultiTracker.MultiTracker []>
java:  legacy_MultiTracker()
FUNC <bool cv.legacy.MultiTracker.add [ARG Ptr_legacy_Tracker newTracker=, ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean add(legacy_Tracker newTracker, Mat image, Rect2d boundingBox)
FUNC <bool cv.legacy.MultiTracker.update [ARG Mat image=, ARG vector_Rect2d boundingBox=]>
java: boolean update(Mat image, MatOfRect2d boundingBox)
FUNC <vector_Rect2d cv.legacy.MultiTracker.getObjects []>
java: MatOfRect2d getObjects()
FUNC <Ptr_MultiTracker cv.legacy.MultiTracker.create []>
SKIP:static Ptr_MultiTracker cv::legacy::MultiTracker::create()	 due to RET type Ptr_MultiTracker
CLASS cv.legacy::.legacy_Tracker : Algorithm
FUNC <bool cv.legacy.Tracker.init [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean init(Mat image, Rect2d boundingBox)
FUNC <bool cv.legacy.Tracker.update [ARG Mat image=, ARG Rect2d boundingBox=]>
java: boolean update(Mat image, Rect2d boundingBox)
CLASS cv.legacy::.legacy_TrackerBoosting : legacy_Tracker
FUNC <Ptr_legacy_TrackerBoosting cv.legacy.TrackerBoosting.create []>
java: legacy_TrackerBoosting create()
CLASS cv.legacy::.legacy_TrackerCSRT : legacy_Tracker
FUNC <Ptr_legacy_TrackerCSRT cv.legacy.TrackerCSRT.create []>
java: legacy_TrackerCSRT create()
FUNC <void cv.legacy.TrackerCSRT.setInitialMask [ARG Mat mask=]>
java: void setInitialMask(Mat mask)
CLASS cv.legacy::.legacy_TrackerKCF : legacy_Tracker
FUNC <Ptr_legacy_TrackerKCF cv.legacy.TrackerKCF.create []>
java: legacy_TrackerKCF create()
CLASS cv.legacy::.legacy_TrackerMIL : legacy_Tracker
FUNC <Ptr_legacy_TrackerMIL cv.legacy.TrackerMIL.create []>
java: legacy_TrackerMIL create()
CLASS cv.legacy::.legacy_TrackerMOSSE : legacy_Tracker
FUNC <Ptr_legacy_TrackerMOSSE cv.legacy.TrackerMOSSE.create []>
java: legacy_TrackerMOSSE create()
CLASS cv.legacy::.legacy_TrackerMedianFlow : legacy_Tracker
FUNC <Ptr_legacy_TrackerMedianFlow cv.legacy.TrackerMedianFlow.create []>
java: legacy_TrackerMedianFlow create()
CLASS cv.legacy::.legacy_TrackerTLD : legacy_Tracker
FUNC <Ptr_legacy_TrackerTLD cv.legacy.TrackerTLD.create []>
java: legacy_TrackerTLD create()
