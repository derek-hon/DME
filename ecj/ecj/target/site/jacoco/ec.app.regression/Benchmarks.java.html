<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Benchmarks.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.app.regression</a> &gt; <span class="el_source">Benchmarks.java</span></div><h1>Benchmarks.java</h1><pre class="source lang-java linenums">package ec.app.regression;
import ec.util.*;
import ec.*;
import ec.gp.*;
import ec.gp.koza.*;
import ec.simple.*;
import java.io.*;
import java.util.*;

/* 
 * Benchmarks.java
 * U    
 * Created: Thu Jul 14 10:35:11 EDT 2011
 * By: Sean Luke
 *
 * This is an expansion of the Regression.java file to provide a first cut at a standardized
 * regression benchmark for Genetic Programming.  The package provides both training and
 * testing data and functions for the following problems:
 
 &lt;ol&gt;
 &lt;li&gt;John Koza's three  problems (quartic, quintic, and sextic, drawn from his GP-1 and GP-2 books.  These are known as &lt;b&gt;koza-1&lt;/b&gt; through &lt;b&gt;koza-3&lt;/b&gt;
 &lt;li&gt;Twelve problems drawn from &quot;Semantically-based Crossover in Genetic Programming: Application to Real-valued Symbolic Regression&quot; (GPEM 2011),
 by Nguyen Quang Uy, Nguyen Xuan Hoai, Michael O’Neill, R.I. McKay, Edgar Galv ́an-L ́opez.  These are known as
 &lt;b&gt;nguyen-1&lt;/b&gt; through &lt;b&gt;nguyen-10&lt;/b&gt;
 &lt;li&gt;Fifteen problems drawn from &quot;Accuracy in Symbolic Regression&quot; (GPEM 2011), by Michael Korns.  These are known as &lt;b&gt;KORNS1&lt;/b&gt; through &lt;b&gt;KORNS15&lt;/b&gt;
 &lt;li&gt;Fifteen problems drawn from &quot;Improving Symbolic Regression with Interval Arithmetic and Linear Scaling&quot; (EuroGP 2003), by Maarten Keijzer.  These are known as &lt;b&gt;keijzer-1&lt;/b&gt; through &lt;b&gt;keijzer-15&lt;/b&gt;
 &lt;li&gt;Fifteen problems drawn from &quot;Order of Nonlinearity as a Complexity Measure for Models Generated by Symbolic Regression via Pareto Genetic Programming&quot; (IEEE TransEC 13:2), by Ekaterina J. Vladislavleva, Guido F. Smits, and Dick den Hertog.  These are known as &lt;b&gt;vladislavleva-1&lt;/b&gt; through &lt;b&gt;vladislavleva-8&lt;/b&gt;
 &lt;li&gt;Two problems drawn from &quot;Evolutionary Consequences of Coevolving Targets&quot; (Evolutionary Computation 5(4)) by Ludo Pagie and Paulien Hogeweg, 1997.
 &lt;li&gt;You can also provide your own data sets via a text file.

 &lt;p&gt;These problems differ in a variety of ways.  Some have both training and testing data points.  Some have one variable, others up to five variables.  Some build their random points based on random samples, other based on a grid of samples distributed through the space.  Different problems also use different function sets.
 
 &lt;p&gt;The functions below are all described precisely in the paper &quot;Genetic Programming Needs Better Benchmarks&quot; (GECCO 2012) by James McDermmott, David R. white, Sean Luke, Luca Manzoni, Mauro Castelli, Leonardo Vanneschi, Wojciech Jaskowski, Krzysztof Krawiec, Robin Harper, Kenneth De Jong, and Una-May O'Reilly.  The descriptions, shown in Tables 2 and 3, explain the function set, number of variables, objective function, training set, testing set, and source of each problem.
 
 &lt;p&gt;In addition we include one more function: PAGIE2, a 3-variable version of PAGIE1. We describe PAGIE2 as follows:
 
 &lt;ul&gt;
 &lt;li&gt;Variables: 3
 li&gt;Function: (1 / (1 + x^(-4)) + 1 / (1 + y^(-4)) + 1 / (1 + z^(-4)))
 &lt;li&gt;Testing Set: Grid points from -5 to 5 respectively in each dimension, spaced out in intervals of 0.4.
 &lt;li&gt;Training Set: none
 &lt;li&gt;Function Set: standard Koza with three terminals (X1, X2, X3).
 &lt;/ul&gt;

 *
 *
 */

/**
 * Benchmarks by various people in the literature.
 *
 */
<span class="nc" id="L53">public class Benchmarks extends GPProblem implements SimpleProblemForm</span>
    {
    private static final long serialVersionUID = 1;

    //////////////////////////// problem tags
        
    // From GP-1 and GP-2
    public static final int KOZA1 = 0 ;
    public static final int KOZA2 = 1 ;
    public static final int KOZA3 = 2 ;
        
    // From Semantically-based Crossover in Genetic Programming: Application to Real-valued Symbolic Regression
    // Nguyen Quang Uy, Nguyen Xuan Hoai, Michael O’Neill, R.I. McKay, Edgar Galv ́an-L ́opez
    // GPEM 2011
    public static final int NGUYEN1 = 3 ;
    public static final int NGUYEN2 = 4 ;  // identical to standard Koza
    public static final int NGUYEN3 = 5 ;
    public static final int NGUYEN4 = 6 ;
    public static final int NGUYEN5 = 7 ;
    public static final int NGUYEN6 = 8 ;
    public static final int NGUYEN7 = 9 ;
    public static final int NGUYEN8 = 10 ;
    public static final int NGUYEN9 = 11 ;
    public static final int NGUYEN10 = 12 ;
    
    // From Pagie and Hogeweg 1997: Ludo Pagie, Paulien Hogeweg: Evolutionary Consequences of Coevolving
    // Targets. Evolutionary Computation 5(4): 401-418 (1997).
    public static final int PAGIE1 = 13;        // 2D
    public static final int PAGIE2 = 14;        // 3D
        
    // From Accuracy in Symbolic Regression -- GPTP 2011
    public static final int KORNS1 = 15 ;
    public static final int KORNS2 = 16 ;
    public static final int KORNS3 = 17 ;
    public static final int KORNS4 = 18 ;
    public static final int KORNS5 = 19 ;
    public static final int KORNS6 = 20 ;
    public static final int KORNS7 = 21 ;
    public static final int KORNS8 = 22 ;
    public static final int KORNS9 = 23 ;
    public static final int KORNS10 = 24 ;
    public static final int KORNS11 = 25 ;
    public static final int KORNS12 = 26 ;
    public static final int KORNS13 = 27 ;
    public static final int KORNS14 = 28 ;
    public static final int KORNS15 = 29 ;
        
    // From Improving Symbolic Regression with Interval Arithmetic and Linear Scaling
    // Maarten Keijzer -- EuroGP 2003
    public static final int KEIJZER1 = 30 ;
    public static final int KEIJZER2 = 31 ;
    public static final int KEIJZER3 = 32 ;
    public static final int KEIJZER4 = 33 ;
    public static final int KEIJZER5 = 34 ;
    public static final int KEIJZER6 = 35 ;
    public static final int KEIJZER7 = 36 ;                         
    public static final int KEIJZER8 = 37 ;
    public static final int KEIJZER9 = 38 ;
    public static final int KEIJZER10 = 39 ;
    public static final int KEIJZER11 = 40 ;
    public static final int KEIJZER12 = 41 ;
    public static final int KEIJZER13 = 42 ;
    public static final int KEIJZER14 = 43 ;
    public static final int KEIJZER15 = 44 ;
        
    // From Order of Nonlinearity as a Complexity Measure for Models Generated by Symbolic Regression via Pareto Genetic Programming
    // Ekaterina J. Vladislavleva, Guido F. Smits, and Dick den Hertog
    public static final int VLADISLAVLEVA1 = 45 ;
    public static final int VLADISLAVLEVA2 = 46 ;
    public static final int VLADISLAVLEVA3 = 47 ;
    public static final int VLADISLAVLEVA4 = 48 ;
    public static final int VLADISLAVLEVA5 = 49 ;
    public static final int VLADISLAVLEVA6 = 50 ;                           
    public static final int VLADISLAVLEVA7 = 51 ;
    public static final int VLADISLAVLEVA8 = 52 ;

        
        
        
    // parameter names
<span class="nc" id="L133">    public static final String names[] = </span>
        { 
        &quot;koza-1&quot;, &quot;koza-2&quot;, &quot;koza-3&quot;,
        &quot;nguyen-1&quot;, &quot;nguyen-2&quot;, &quot;nguyen-3&quot;, &quot;nguyen-4&quot;, &quot;nguyen-5&quot;, &quot;nguyen-6&quot;, &quot;nguyen-7&quot;, &quot;nguyen-8&quot;, &quot;nguyen-9&quot;, &quot;nguyen-10&quot;,
        &quot;pagie-1&quot;, &quot;pagie-2&quot;,
        &quot;korns-1&quot;, &quot;korns-2&quot;, &quot;korns-3&quot;, &quot;korns-4&quot;, &quot;korns-5&quot;, &quot;korns-6&quot;, &quot;korns-7&quot;, &quot;korns-8&quot;, &quot;korns-9&quot;, &quot;korns-10&quot;, &quot;korns-11&quot;, &quot;korns-12&quot;, &quot;korns-13&quot;, &quot;korns-14&quot;, &quot;korns-15&quot;,
        &quot;keijzer-1&quot;, &quot;keijzer-2&quot;, &quot;keijzer-3&quot;, &quot;keijzer-4&quot;, &quot;keijzer-5&quot;, &quot;keijzer-6&quot;, &quot;keijzer-7&quot;, &quot;keijzer-8&quot;, &quot;keijzer-9&quot;, &quot;keijzer-10&quot;, &quot;keijzer-11&quot;, &quot;keijzer-12&quot;, &quot;keijzer-13&quot;, &quot;keijzer-14&quot;, &quot;keijzer-15&quot;, 
        &quot;vladislavleva-1&quot;, &quot;vladislavleva-2&quot;, &quot;vladislavleva-3&quot;, &quot;vladislavleva-4&quot;, &quot;vladislavleva-5&quot;, &quot;vladislavleva-6&quot;, &quot;vladislavleva-7&quot;, &quot;vladislavleva-8&quot;
        }; 
                
                
    // expected function sets.  &quot;fn&quot; means &quot;function set with n terminals x_1 ... x_n&quot;
<span class="nc" id="L145">    public static final String fs[] = </span>
        {
        &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;,
        &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza1&quot;, &quot;koza2&quot;, &quot;koza2&quot;,
        &quot;koza2&quot;, &quot;koza3&quot;,
        &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, &quot;korns5&quot;, 
        &quot;keijzer1&quot;, &quot;keijzer1&quot;, &quot;keijzer1&quot;/* revised from GECCO paper */,  &quot;keijzer1&quot;, &quot;keijzer3&quot;, &quot;keijzer1&quot;, &quot;keijzer1&quot;, &quot;keijzer1&quot;, &quot;keijzer1&quot;, &quot;keijzer2&quot;, &quot;keijzer2&quot;, &quot;keijzer2&quot;, &quot;keijzer2&quot;, &quot;keijzer2&quot;, &quot;keijzer2&quot;,
        &quot;vladislavleva-b2&quot;, &quot;vladislavleva-c1&quot;, &quot;vladislavleva-c2&quot;, &quot;vladislavleva-a5&quot;, &quot;vladislavleva-a3&quot;, &quot;vladislavleva-b2&quot;, &quot;vladislavleva-c2&quot;, &quot;vladislavleva-a2&quot;
        };
        
        
    
    // function sets with various variable lengths
<span class="nc" id="L158">    public static final String fs_vars[][] = </span>
        {
        { },
        { &quot;koza1&quot;, &quot;keijzer1&quot;, &quot;vladislavleva-c1&quot; },
        { &quot;koza2&quot;, &quot;keijzer2&quot;, &quot;vladislavleva-a2&quot;, &quot;vladislavleva-b2&quot;, &quot;vladislavleva-c2&quot; },
        { &quot;koza3&quot;, &quot;keijzer3&quot;, &quot;vladislavleva-a3&quot; },
        { },
        { &quot;korns5&quot;, &quot;vladislavleva-a5&quot; },
        };
        
        
    /** Hyperbolic Arc Sin -- not standard in Java Math library */
    static double asinh(double x)
        {
<span class="nc" id="L172">        return Math.log(x + Math.sqrt(x*x + 1.0));</span>
        }
        
        
    //// Input Sample Generation
        
        
    /** Produce random sample points between min and max, inclusive, in each dimension.  */
    public double[][] generateRandomSamples(EvolutionState state, double[] min, double[] max, int numPoints, int threadnum)
        {
<span class="nc" id="L182">        int vars = max.length;</span>
<span class="nc" id="L183">        double[][] d = new double[numPoints][vars];</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        for(int i = 0 ; i &lt; d.length; i++)</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            for(int j = 0; j &lt; vars; j++)</span>
                // below we're doing nextDouble(true, true), which means to select from the
                // FULLY CLOSED interval [0.0, 1.0], including both 0.0 and 1.0.
<span class="nc" id="L188">                d[i][j] = state.random[threadnum].nextDouble(true, true) * (max[j] - min[j]) + min[j];</span>
<span class="nc" id="L189">        return d;</span>
        }
                
    /** Produce random sample points between min and max, inclusive, in one dimension.  */
    public double[][] generateRandomSamples(EvolutionState state, double min, double max, int numPoints, int threadnum)
        {
<span class="nc" id="L195">        return generateRandomSamples(state, new double[] { min }, new double[] { max }, numPoints, threadnum);</span>
        }

    // recursive trick to dump the full mesh into a bag.  Enter this by setting variable to 0,  Yuck, expensive.  But O(n).
    void buildIntervalPoints(EvolutionState state, ArrayList list, double[] min, double[] max, double[] interval, double current[], int variable, int threadnum)
        {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (variable == min.length)  // we're out of variables, base case</span>
            {
<span class="nc" id="L203">            double[] d = new double[min.length];</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for(int i = 0; i &lt; d.length; i++)</span>
<span class="nc" id="L205">                d[i] = current[i];      // not sure if System.arraycopy would be faster, probably not in this case</span>
<span class="nc" id="L206">            list.add(d);</span>
<span class="nc" id="L207">            }</span>
        else
            {
<span class="nc" id="L210">            int jumps = (int)((max[variable] - min[variable]) / interval[variable]) + 1;</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            for(int j = 0; j &lt; jumps; j++)</span>
                {
<span class="nc" id="L214">                current[variable] = min[variable] + interval[variable] * j;</span>
<span class="nc" id="L215">                buildIntervalPoints(state, list, min, max, interval, current, variable + 1, threadnum);</span>
                }
            }
<span class="nc" id="L218">        }</span>



    /** Produce sample points evenly spaced out between min and max in each dimension, with the given spacing interval per-dimension.  */
    public double[][] generateIntervalSpacedSamples(EvolutionState state, double[] min, double[] max, double[] interval, int threadnum)
        {
        // gather all the points in the mesh recursively
<span class="nc" id="L226">        ArrayList list = new ArrayList();</span>
<span class="nc" id="L227">        double[] current = new double[min.length];</span>
<span class="nc" id="L228">        buildIntervalPoints(state, list, min, max, interval, current, 0, threadnum);</span>
                
        // Convert to an array
<span class="nc" id="L231">        return (double[][])(list.toArray(new double[0][]));</span>
        }
                
                
    /** Produce sample points evenly spaced out between min and max in one dimension, with the given spacing interval.  One dimension only. */
    public double[][] generateIntervalSpacedSamples(EvolutionState state, double min, double max, double interval, int threadnum)
        {
<span class="nc" id="L238">        return generateIntervalSpacedSamples(state, new double[] { min }, new double[] { max }, new double[] { interval }, threadnum);</span>
        }
                
        
    /** Produce sample points for a given benchmark problem.  */
    public double[][] trainPoints(EvolutionState state, int benchmark, int threadnum)
        {
<span class="nc bnc" id="L245" title="All 27 branches missed.">        switch(benchmark)</span>
            {
            case KOZA1:
            case KOZA2:
            case KOZA3:
<span class="nc" id="L250">                return generateRandomSamples(state, -1, 1, 20, threadnum);</span>
                                
            case NGUYEN1:
            case NGUYEN2:
            case NGUYEN3:
            case NGUYEN4:
            case NGUYEN5:
            case NGUYEN6:
<span class="nc" id="L258">                return generateRandomSamples(state, -1, 1, 20, threadnum);</span>
                        
            case NGUYEN7:
<span class="nc" id="L261">                return generateRandomSamples(state, 0, 2, 20, threadnum);</span>

            case NGUYEN8:
<span class="nc" id="L264">                return generateRandomSamples(state, 0, 4, 20, threadnum);</span>

            case NGUYEN9:
            case NGUYEN10:
<span class="nc" id="L268">                return generateRandomSamples(state, new double[] { 0, 0 }, new double[] { 1, 1 }, 100, threadnum);</span>
                        
            case PAGIE1:
<span class="nc" id="L271">                return generateIntervalSpacedSamples(state, new double[] { -5.0, -5.0 }, new double[] { 5.0, 5.0 }, new double[] { 0.4, 0.4 }, threadnum);</span>
            case PAGIE2:
<span class="nc" id="L273">                return generateIntervalSpacedSamples(state, new double[] { -5.0, -5.0, -5.0 }, new double[] { 5.0, 5.0, 5.0 }, new double[] { 0.4, 0.4, 0.4 }, threadnum);</span>
            
            
            case KORNS1:
            case KORNS2:
            case KORNS3:
            case KORNS4:
            case KORNS5:
            case KORNS6:
            case KORNS7:
            case KORNS8:
            case KORNS9:
            case KORNS10:
            case KORNS11:
            case KORNS12:
            case KORNS13:
            case KORNS14:
            case KORNS15:
<span class="nc" id="L291">                return generateRandomSamples(state, new double[] { -50, -50, -50, -50, -50 }, new double[] { 50, 50, 50, 50, 50 }, 10000, threadnum);  // 10000 !!</span>
                        
            case KEIJZER1:
<span class="nc" id="L294">                return generateIntervalSpacedSamples(state, -1, 1, 0.1, threadnum);</span>
                                
            case KEIJZER2:
<span class="nc" id="L297">                return generateIntervalSpacedSamples(state, -2, 2, 0.1, threadnum);</span>

            case KEIJZER3:
<span class="nc" id="L300">                return generateIntervalSpacedSamples(state, -3, 3, 0.1, threadnum);</span>

            case KEIJZER4:
<span class="nc" id="L303">                return generateIntervalSpacedSamples(state, 0, 10, 0.05, threadnum);</span>
                                
            case KEIJZER5:      // revised from GECCO paper
<span class="nc" id="L306">                return generateRandomSamples(state, new double[] { -1, 1, -1 }, new double[] { 1, 2, 1 }, 1000, threadnum);</span>
                                
            case KEIJZER6:
<span class="nc" id="L309">                return generateIntervalSpacedSamples(state, 1, 50, 1, threadnum);</span>
                                
            case KEIJZER7:                          
<span class="nc" id="L312">                return generateIntervalSpacedSamples(state, 1, 100, 1, threadnum);</span>
            case KEIJZER8:
            case KEIJZER9:
<span class="nc" id="L315">                return generateIntervalSpacedSamples(state, 0, 100, 1, threadnum);</span>

            case KEIJZER10:
<span class="nc" id="L318">                return generateRandomSamples(state, new double[] { 0, 0 }, new double[] { 1, 1 }, 100, threadnum);</span>

            case KEIJZER11:
            case KEIJZER12:
            case KEIJZER13:
            case KEIJZER14:
            case KEIJZER15:
<span class="nc" id="L325">                return generateRandomSamples(state, new double[] { -3, -3 }, new double[] { 3, 3 }, 20, threadnum);</span>
                                
            case VLADISLAVLEVA1:
<span class="nc" id="L328">                return generateRandomSamples(state, new double[] { 0.3, 0.3 }, new double[] { 4, 4 }, 100, threadnum);</span>
                                
            case VLADISLAVLEVA2:      // revised from GECCO paper
<span class="nc" id="L331">                return generateIntervalSpacedSamples(state, 0.05, 10, 0.1, threadnum);</span>
                                
            case VLADISLAVLEVA3:
<span class="nc" id="L334">                return generateIntervalSpacedSamples(state, new double[] { 0.05, 0.05 }, new double[] { 10, 10.05 }, new double[] { 0.1, 2 }, threadnum);</span>
                                
            case VLADISLAVLEVA4:
<span class="nc" id="L337">                return generateRandomSamples(state, new double[] { 0.05, 0.05, 0.05, 0.05, 0.05}, new double[] { 6.05, 6.05, 6.05, 6.05, 6.05 }, 1024, threadnum);</span>
                                
            case VLADISLAVLEVA5:
<span class="nc" id="L340">                return generateRandomSamples(state, new double[] { 0.05, 1, 0.05 }, new double[] { 2, 2, 2 }, 300, threadnum);</span>
                                
            case VLADISLAVLEVA6:                            
<span class="nc" id="L343">                return generateRandomSamples(state, new double[] { 0.1, 0.1 }, new double[] { 5.9, 5.9 }, 30, threadnum);</span>

            case VLADISLAVLEVA7:
<span class="nc" id="L346">                return generateRandomSamples(state, new double[] { 0.05, 0.05 }, new double[] { 6.05, 6.05 }, 300, threadnum);</span>

            case VLADISLAVLEVA8:
<span class="nc" id="L349">                return generateRandomSamples(state, new double[] { 0.05, 0.05 }, new double[] { 6.05, 6.05 }, 50, threadnum);</span>
                        
            default:
<span class="nc" id="L352">                return null;</span>
            }
        }



    /** Produce test sample points for a given benchmark problem, to test generalization.  */
    public double[][] testPoints(EvolutionState state, int benchmark, int threadnum, double[][] trainpoints)
        {
<span class="nc bnc" id="L361" title="All 23 branches missed.">        switch(benchmark)</span>
            {
            case KOZA1:
            case KOZA2:
            case KOZA3:
<span class="nc" id="L366">                return trainpoints;</span>
                                
            case NGUYEN1:
            case NGUYEN2:
            case NGUYEN3:
            case NGUYEN4:
            case NGUYEN5:
            case NGUYEN6:
            case NGUYEN7:
            case NGUYEN8:
            case NGUYEN9:
            case NGUYEN10:
<span class="nc" id="L378">                return trainpoints;</span>
                
            case PAGIE1:
            case PAGIE2:
<span class="nc" id="L382">                return trainpoints;</span>
                        
            case KORNS1:
            case KORNS2:
            case KORNS3:
            case KORNS4:
            case KORNS5:
            case KORNS6:
            case KORNS7:
            case KORNS8:
            case KORNS9:
            case KORNS10:
            case KORNS11:
            case KORNS12:
            case KORNS13:
            case KORNS14:
            case KORNS15:
<span class="nc" id="L399">                return generateRandomSamples(state, new double[] { -50, -50, -50, -50, -50 }, new double[] { 50, 50, 50, 50, 50 }, 10000, threadnum);  // 10000 !!</span>
                        
            case KEIJZER1:
<span class="nc" id="L402">                return generateIntervalSpacedSamples(state, -1, 1, 0.001, threadnum);</span>
                                
            case KEIJZER2:
<span class="nc" id="L405">                return generateIntervalSpacedSamples(state, -2, 2, 0.001, threadnum);</span>

            case KEIJZER3:
<span class="nc" id="L408">                return generateIntervalSpacedSamples(state, -3, 3, 0.001, threadnum);</span>

            case KEIJZER4:
<span class="nc" id="L411">                return generateIntervalSpacedSamples(state, 0.05, 10.05, 0.05, threadnum);</span>
                                
            case KEIJZER5:      // revised from GECCO paper
<span class="nc" id="L414">                return generateRandomSamples(state, new double[] { -1, 1, -1 }, new double[] { 1, 2, 1 }, 10000, threadnum);  // 10000 cases for testing, different than for training</span>
                                
            case KEIJZER6:
<span class="nc" id="L417">                return generateIntervalSpacedSamples(state, 1, 120, 1, threadnum);</span>
                                
            case KEIJZER7:                          
<span class="nc" id="L420">                return generateIntervalSpacedSamples(state, 1, 100, 0.1, threadnum);</span>
            case KEIJZER8:
            case KEIJZER9:
<span class="nc" id="L423">                return generateIntervalSpacedSamples(state, 0, 100, 0.1, threadnum);</span>

            case KEIJZER10:
<span class="nc" id="L426">                return generateIntervalSpacedSamples(state, new double[] { 0, 0 }, new double[] { 1, 1 }, new double[] { 0.01, 0.01 }, threadnum);</span>

            case KEIJZER11:
            case KEIJZER12:
            case KEIJZER13:
            case KEIJZER14:
            case KEIJZER15:
<span class="nc" id="L433">                return generateIntervalSpacedSamples(state, new double[] { -3.0, -3.0 }, new double[] { 3.0, 3.0 }, new double[] { 0.01, 0.01 }, threadnum);</span>
                                
            case VLADISLAVLEVA1:      // revised from GECCO paper
<span class="nc" id="L436">                return generateIntervalSpacedSamples(state, new double[] { -0.2, -0.2 }, new double[] { 4.2, 4.2 }, new double[] { 0.1, 0.1 }, threadnum);</span>
                                
            case VLADISLAVLEVA2:
<span class="nc" id="L439">                return generateIntervalSpacedSamples(state, -0.5, 10.5, 0.05, threadnum);</span>
                                
            case VLADISLAVLEVA3:
<span class="nc" id="L442">                return generateIntervalSpacedSamples(state, new double[] { -0.5, -0.5 }, new double[] { 10.5, 10.5 }, new double[] { 0.05, 0.5 }, threadnum);  // note 0.05 and 0.5, and also 10.5 which is different from training</span>
                                
            case VLADISLAVLEVA4:
<span class="nc" id="L445">                return generateRandomSamples(state, new double[] { -0.25, -0.25, -0.25, -0.25, -0.25}, new double[] { 6.35, 6.35, 6.35, 6.35, 6.35 }, 5000, threadnum);</span>
                                
            case VLADISLAVLEVA5:
<span class="nc" id="L448">                return generateIntervalSpacedSamples(state, new double[] { -0.05,  0.95, -0.05 }, new double[] { 2.1, 2.05, 2.1 }, new double[] { 0.15, 0.15, 0.1 }, threadnum);  // note 0.05 and 0.5, and also 10.5 which is different from training</span>
                                
            case VLADISLAVLEVA6:                            
<span class="nc" id="L451">                return generateIntervalSpacedSamples(state, new double[] { -0.05, -0.05 }, new double[] { 6.05, 6.05 }, new double[] { 0.02, 0.02 }, threadnum);  // note 0.05 and 0.5, and also 10.5 which is different from training</span>

            case VLADISLAVLEVA7:
<span class="nc" id="L454">                return generateRandomSamples(state, new double[] { -0.25, -0.25 }, new double[] { 6.35, 6.35 }, 1000, threadnum);</span>

            case VLADISLAVLEVA8:
<span class="nc" id="L457">                return generateIntervalSpacedSamples(state, new double[] { -0.25, -0.25 }, new double[] { 6.35, 6.35 }, new double[] { 0.2, 0.2 }, threadnum);  // note 0.05 and 0.5, and also 10.5 which is different from training</span>

            default:
<span class="nc" id="L460">                return null;</span>
            }
        }







    /** Return the function applied to the given data by benchmark problem.  */
    public double func(EvolutionState state, double[] xs, int benchmark) throws IllegalArgumentException
        {
<span class="nc" id="L473">        double x = xs[0];</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        double y = (xs.length &gt; 1 ? xs[1] : 0);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        double z = (xs.length &gt; 2 ? xs[2] : 0);</span>
                
<span class="nc bnc" id="L477" title="All 52 branches missed.">        switch(benchmark)</span>
            {
            case KOZA1:
<span class="nc" id="L480">                return x*x*x*x + x*x*x + x*x + x;       // traditional</span>
            case KOZA2:
<span class="nc" id="L482">                return x*x*x*x*x - 2.0*x*x*x + x;       // Quintic, from  J. R. Koza, GP II, 1994</span>
            case KOZA3:
<span class="nc" id="L484">                return x*x*x*x*x*x - 2.0*x*x*x*x + x*x;  // Sextic, from J. R. Koza, GP II, 1994</span>
            case NGUYEN1:
<span class="nc" id="L486">                return x*x*x + x*x + x;</span>
            case NGUYEN2:                                                   // identical to KOZA1
<span class="nc" id="L488">                return x*x*x*x + x*x*x + x*x + x;</span>
            case NGUYEN3:
<span class="nc" id="L490">                return x*x*x*x*x + x*x*x*x + x*x*x + x*x + x;</span>
            case NGUYEN4:
<span class="nc" id="L492">                return x*x*x*x*x*x + x*x*x*x*x + x*x*x*x + x*x*x + x*x + x;</span>
            case NGUYEN5:
<span class="nc" id="L494">                return Math.sin(x*x) * Math.cos(x) - 1.0;</span>
            case NGUYEN6:
<span class="nc" id="L496">                return Math.sin(x) + Math.sin(x*x + x);</span>
            case NGUYEN7:
<span class="nc" id="L498">                return Math.log(x+1) + Math.log(x*x + 1.0);</span>
            case NGUYEN8:                           // Note this presumes you don't have sqrt(x) in your function set!
<span class="nc" id="L500">                return Math.sqrt(x);</span>
            case NGUYEN9:
<span class="nc" id="L502">                return Math.sin(x) + Math.sin(y*y);</span>
            case NGUYEN10:
<span class="nc" id="L504">                return 2 * Math.sin(x) * Math.cos(y);</span>
                //case NGUYEN11:
                //    return Math.pow(x, y);
                //case NGUYEN12:
                //    return x*x*x*x - x*x*x + (y*y)/2.0 - y;
            case PAGIE1:
                // otherwise known as 1 / (1 + Math.pow(x, -4)) + 1 / (1 + Math.pow(y, -4))
<span class="nc" id="L511">                return 1.0 / (1.0 + 1.0 / (x * x * x * x)) + 1.0 / (1.0 + 1.0 / (y * y * y * y)); </span>
            case PAGIE2:
                // otherwise known as (1 / (1 + Math.pow(x, -4)) + 1 / (1 + Math.pow(y, -4)) + 1 / (1 + Math.pow(z, -4)));
<span class="nc" id="L514">                return 1.0 / (1.0 + 1.0 / ( x * x * x * x)) + 1.0 / (1.0 + 1.0 / (y * y * y * y)) + 1.0 / (1.0 + 1.0 / (z * z * z * z));</span>
            case KORNS1:
<span class="nc" id="L516">                return 1.57 + (24.3 * xs[3]);</span>
            case KORNS2:
<span class="nc" id="L518">                return 0.23 + (14.2 * ((xs[3]+ xs[1])/(3.0 * xs[4])));</span>
            case KORNS3:
<span class="nc" id="L520">                return -5.41 + (4.9 * (((xs[3] - xs[0]) + (xs[1]/xs[4])) / (3 * xs[4])));</span>
            case KORNS4:
<span class="nc" id="L522">                return -2.3 + (0.13 * Math.sin(xs[2]));</span>
            case KORNS5:
<span class="nc" id="L524">                return 3.0 + (2.13 * Math.log(xs[4]));</span>
            case KORNS6:
<span class="nc" id="L526">                return 1.3 + (0.13 * Math.sqrt(xs[0]));</span>
            case KORNS7:
<span class="nc" id="L528">                return 213.80940889 - (213.80940889 * Math.exp(-0.54723748542 * xs[0]));</span>
            case KORNS8:
<span class="nc" id="L530">                return 6.87 + (11.0 * Math.sqrt(7.23 * xs[0] * xs[3] * xs[4]));</span>
            case KORNS9:        // revised from GECCO paper
<span class="nc" id="L532">                return Math.sqrt(xs[0]) / Math.log(xs[1]) * Math.exp(xs[2]) / (xs[3] * xs[3]);</span>
            case KORNS10:
<span class="nc" id="L534">                return 0.81 + (24.3 * (((2.0 * xs[1]) + (3.0 * (xs[2] * xs[2]))) / ((4.0 * (xs[3]*xs[3]*xs[3])) + (5.0 * (xs[4]*xs[4]*xs[4]*xs[4])))));</span>
            case KORNS11:
<span class="nc" id="L536">                return 6.87 + (11.0 * Math.cos(7.23 * xs[0]*xs[0]*xs[0]));</span>
            case KORNS12:
<span class="nc" id="L538">                return 2.0 - (2.1 * (Math.cos(9.8 * xs[0]) * Math.sin(1.3 * xs[4])));</span>
            case KORNS13:
<span class="nc" id="L540">                return 32.0 - (3.0 * ((Math.tan(xs[0]) / Math.tan(xs[1])) * (Math.tan(xs[2])/Math.tan(xs[3]))));</span>
            case KORNS14:
<span class="nc" id="L542">                return 22.0 - (4.2 * ((Math.cos(xs[0]) - Math.tan(xs[1]))*(Math.tanh(xs[2])/Math.sin(xs[3]))));</span>
            case KORNS15:
<span class="nc" id="L544">                return 12.0 - (6.0 * ((Math.tan(xs[0])/Math.exp(xs[1])) * (Math.log(xs[2]) - Math.tan(xs[3]))));</span>
            case KEIJZER1:  // fall thru
            case KEIJZER2:  // fall thru
            case KEIJZER3:
<span class="nc" id="L548">                return 0.3 * x * Math.sin(2 * Math.PI * x);</span>
            case KEIJZER4:
<span class="nc" id="L550">                return x*x*x * Math.exp(-x)*Math.cos(x)*Math.sin(x)* (Math.sin(x)*Math.sin(x)*Math.cos(x) - 1);</span>
            case KEIJZER5:
<span class="nc" id="L552">                return (30.0 * x * z) / ((x - 10.0) * y * y);</span>
            case KEIJZER6:
                { 
<span class="nc" id="L555">                double sum = 0;</span>
<span class="nc" id="L556">                double fx = Math.floor(x);</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                for(int i = 1; i &lt; fx + 1; i++)  // up to and including floor(x)</span>
<span class="nc" id="L558">                    sum += (1.0 / i);</span>
<span class="nc" id="L559">                return sum; </span>
                }
            case KEIJZER7:                          // Note this presumes you don't have log(x) in your function set!
<span class="nc" id="L562">                return Math.log(x);</span>
            case KEIJZER8:                          // same as NGUYEN8
<span class="nc" id="L564">                return Math.sqrt(x);</span>
            case KEIJZER9:
<span class="nc" id="L566">                return asinh(x);   // Not a function in Math</span>
            case KEIJZER10:
<span class="nc" id="L568">                return Math.pow(x, y);</span>
            case KEIJZER11:
<span class="nc" id="L570">                return x * y + Math.sin((x - 1.0) * (y - 1.0));</span>
            case KEIJZER12:
<span class="nc" id="L572">                return x*x*x*x - x*x*x + y*y/2.0 - y;</span>
            case KEIJZER13:
<span class="nc" id="L574">                return 6.0 * Math.sin(x) * Math.cos(y);</span>
            case KEIJZER14:
<span class="nc" id="L576">                return 8.0 / (2.0 + x*x + y*y);</span>
            case KEIJZER15:
<span class="nc" id="L578">                return x*x*x / 5.0 + y*y*y/2.0 - y - x;</span>
            case VLADISLAVLEVA1:
<span class="nc" id="L580">                return Math.exp(-(x-1)*(x-1)) / (1.2 + (y - 2.5)*(y-2.5));</span>
            case VLADISLAVLEVA2:
<span class="nc" id="L582">                return Math.exp(-x)*x*x*x*Math.cos(x)*Math.sin(x)*(Math.cos(x)*Math.sin(x)*Math.sin(x) - 1);</span>
            case VLADISLAVLEVA3:
<span class="nc" id="L584">                return Math.exp(-x)*x*x*x*Math.cos(x)*Math.sin(x)*(Math.cos(x)*Math.sin(x)*Math.sin(x) - 1) * (y - 5);</span>
            case VLADISLAVLEVA4:
                {
<span class="nc" id="L587">                double sum = 0;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                for(int i = 0; i &lt; 5; i++)</span>
<span class="nc" id="L589">                    sum += (xs[i] - 3) * (xs[i] - 3);</span>
<span class="nc" id="L590">                return 10.0 / (5.0 + sum);</span>
                }
            case VLADISLAVLEVA5:
<span class="nc" id="L593">                return (30.0 * (x - 1.0) * (z - 1.0)) / (y * y * (x - 10.0));</span>
            case VLADISLAVLEVA6:
<span class="nc" id="L595">                return 6.0 * Math.sin(x) * Math.cos(y);</span>
            case VLADISLAVLEVA7:
<span class="nc" id="L597">                return (x - 3.0) * (y - 3.0) + 2 * Math.sin((x - 4.0) * (y - 4.0));</span>
            case VLADISLAVLEVA8:
<span class="nc" id="L599">                return ((x - 3.0) * (x - 3.0) * (x - 3.0) * (x - 3.0) + (y - 3.0) * (y - 3.0) * (y - 3.0) - (y - 3.0)) / ((y - 2.0) * (y - 2.0) * (y - 2.0) * (y - 2.0) + 10.0);</span>
            default:
<span class="nc" id="L601">                throw new IllegalArgumentException(&quot;Invalid benchmark value &quot; + benchmark);</span>
            }
        // never reaches here
        }
        




    /////// Computation of delta error between expected value and provided value



    final static double PROBABLY_ZERO = 1.11E-15;
    final static double BIG_NUMBER = 1.0e15;                // the same as lilgp uses

    /** Returns the error between the result and the expected result of a single
        data point. */
    public double error(double result, double expectedResult)
        {
<span class="nc" id="L621">        double delta = Math.abs(result - expectedResult);</span>

        // It's possible to get NaN because cos(infinity) and
        // sin(infinity) are undefined (hence cos(exp(3000)) zings ya!)
        // So since NaN is NOT =,&lt;,&gt;,etc. any other number, including
        // NaN, we're CAREFULLY wording our cutoff to include NaN.

<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (! (delta &lt; BIG_NUMBER ) )   // *NOT* (delta &gt;= BIG_NUMBER)</span>
<span class="nc" id="L629">            delta = BIG_NUMBER;</span>

        // very slight math errors can creep in when evaluating
        // two equivalent by differently-ordered functions, like
        // x * (x*x*x + x*x)  vs. x*x*x*x + x*x
        // So we're assuming that very small values are actually zero

<span class="nc bnc" id="L636" title="All 2 branches missed.">        else if (delta &lt; PROBABLY_ZERO)  // slightly off</span>
<span class="nc" id="L637">            delta = 0.0;</span>
<span class="nc" id="L638">        return delta;</span>
        }









    ///// Setup

    // parameters
    public static final String P_TESTING_FILE = &quot;testing-file&quot;;
    public static final String P_TRAINING_FILE = &quot;training-file&quot;;
    public static final String P_PROBLEM_TYPE = &quot;type&quot;;

    public double[] currentValue;
    
    // these are read-only during evaluation-time, so
    // they can be just light-cloned and not deep cloned.
    // cool, huh?
    
    public double[][] trainingInputs;
    public double[] trainingOutputs;
    public double[][] testingInputs;
    public double[] testingOutputs;

    // don't bother cloning the inputs and outputs; they're read-only :-)
    // don't bother cloning the current value, it's only set during evaluation

    public void setup(EvolutionState state, Parameter base)
        {
        // very important, remember this
<span class="nc" id="L673">        super.setup(state,base);</span>

        // verify our input is the right class (or subclasses from it)
<span class="nc bnc" id="L676" title="All 2 branches missed.">        if (!(input instanceof RegressionData))</span>
<span class="nc" id="L677">            state.output.fatal(&quot;GPData class must subclass from &quot; + RegressionData.class,</span>
<span class="nc" id="L678">                base.push(P_DATA), null);</span>

        // should we load our x parameters from a file, or generate them randomly?
<span class="nc" id="L681">        InputStream training_file = state.parameters.getResource(base.push(P_TRAINING_FILE), null);</span>
<span class="nc" id="L682">        InputStream testing_file = state.parameters.getResource(base.push(P_TESTING_FILE), null);</span>
<span class="nc" id="L683">        String problem = state.parameters.getString(base.push(P_PROBLEM_TYPE), null);</span>
<span class="nc" id="L684">        int benchmark = -1;</span>
                
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (problem == null)</span>
            {
<span class="nc" id="L688">            state.output.message(&quot;Loading benchmark data from files&quot;);</span>
<span class="nc bnc" id="L689" title="All 4 branches missed.">            if ((testing_file == null || training_file == null))            // must provide both</span>
                {
<span class="nc" id="L691">                state.output.fatal(&quot;If you don't specify a problem type, you must provide a training file and a testing file&quot;,</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    (training_file == null ? base.push(P_TRAINING_FILE) : base.push(P_TESTING_FILE)));</span>
                }
            else  // load from files
                {
                try
                    {
<span class="nc" id="L698">                    int numInputs = 0;</span>
                                        
                    // first load the number of input variables
<span class="nc" id="L701">                    Scanner scan = new Scanner(training_file);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                    if (scan.hasNextInt()) </span>
<span class="nc" id="L703">                        numInputs = scan.nextInt();</span>
<span class="nc" id="L704">                    else state.output.fatal(&quot;Number of input variables not provided at beginning of training file &quot;, base.push(P_TRAINING_FILE), null);</span>
                                        
                    // Load into an array list each element
<span class="nc" id="L707">                    ArrayList input = new ArrayList();</span>
<span class="nc" id="L708">                    ArrayList output = new ArrayList();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                    while(scan.hasNextDouble())</span>
                        {
<span class="nc" id="L711">                        double[] in = new double[numInputs];</span>
<span class="nc" id="L712">                        double out = 0;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                        for(int i = 0; i &lt; numInputs; i++)</span>
                            {
<span class="nc bnc" id="L715" title="All 2 branches missed.">                            if (scan.hasNextDouble())</span>
<span class="nc" id="L716">                                in[i] = scan.nextDouble();</span>
<span class="nc" id="L717">                            else state.output.fatal(&quot;Non-normal number of data points in training file &quot;, base.push(P_TRAINING_FILE), null);</span>
                            }
<span class="nc bnc" id="L719" title="All 2 branches missed.">                        if (scan.hasNextDouble())</span>
<span class="nc" id="L720">                            out = scan.nextDouble();</span>
<span class="nc" id="L721">                        else state.output.fatal(&quot;Non-normal number of data points in training file &quot;, base.push(P_TRAINING_FILE), null);</span>
<span class="nc" id="L722">                        input.add(in);</span>
<span class="nc" id="L723">                        output.add(new Double(out));</span>
<span class="nc" id="L724">                        }</span>
                                        
                    // dump to arrays
<span class="nc" id="L727">                    int len = input.size();</span>
<span class="nc" id="L728">                    trainingInputs = new double[len][numInputs];</span>
<span class="nc" id="L729">                    trainingOutputs = new double[len];</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                    for(int i = 0; i &lt; len; i++)</span>
                        {
<span class="nc" id="L732">                        trainingInputs[i] = (double[])(input.get(i));</span>
<span class="nc" id="L733">                        trainingOutputs[i] = ((Double)(output.get(i))).doubleValue();</span>
                        }

        
                    // same thing for testing


<span class="nc" id="L740">                    scan = new Scanner(testing_file);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                    if (scan.hasNextInt()) </span>
<span class="nc" id="L742">                        numInputs = scan.nextInt();</span>
<span class="nc" id="L743">                    else state.output.fatal(&quot;Number of input variables not provided at beginning of testing file &quot;, base.push(P_TESTING_FILE), null);</span>
                                        
                    // Load into an array list each element
<span class="nc" id="L746">                    input = new ArrayList();</span>
<span class="nc" id="L747">                    output = new ArrayList();</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                    while(scan.hasNextDouble())</span>
                        {
<span class="nc" id="L750">                        double[] in = new double[numInputs];</span>
<span class="nc" id="L751">                        double out = 0;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                        for(int i = 0; i &lt; numInputs; i++)</span>
                            {
<span class="nc bnc" id="L754" title="All 2 branches missed.">                            if (scan.hasNextDouble())</span>
<span class="nc" id="L755">                                in[i] = scan.nextDouble();</span>
<span class="nc" id="L756">                            else state.output.fatal(&quot;Non-normal number of data points in testing file &quot;, base.push(P_TESTING_FILE), null);</span>
                            }
<span class="nc bnc" id="L758" title="All 2 branches missed.">                        if (scan.hasNextDouble())</span>
<span class="nc" id="L759">                            out = scan.nextDouble();</span>
<span class="nc" id="L760">                        else state.output.fatal(&quot;Non-normal number of data points in testing file &quot;, base.push(P_TESTING_FILE), null);</span>
<span class="nc" id="L761">                        input.add(in);</span>
<span class="nc" id="L762">                        output.add(new Double(out));</span>
<span class="nc" id="L763">                        }</span>
                                        
                    // dump to arrays
<span class="nc" id="L766">                    len = input.size();</span>
<span class="nc" id="L767">                    testingInputs = new double[len][numInputs];</span>
<span class="nc" id="L768">                    testingOutputs= new double[len];</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                    for(int i = 0; i &lt; len; i++)</span>
                        {
<span class="nc" id="L771">                        testingInputs[i] = (double[])(input.get(i));</span>
<span class="nc" id="L772">                        testingOutputs[i] = ((Double)(output.get(i))).doubleValue();</span>
                        }
                    }
<span class="nc" id="L775">                catch (NumberFormatException e)</span>
                    {
<span class="nc" id="L777">                    state.output.fatal(&quot;Some tokens in the file were not numbers.&quot;);</span>
<span class="nc" id="L778">                    }</span>
                }
            }
        else
            {
            // determine benchmark
<span class="nc bnc" id="L784" title="All 2 branches missed.">            for(int i = 0; i &lt; names.length; i++)</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                if (names[i].equals(problem))  // got it</span>
<span class="nc" id="L786">                    { benchmark = i ; break; }</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (benchmark == -1) // uh oh</span>
<span class="nc" id="L788">                state.output.fatal(&quot;Could not find benchmark &quot; + problem, base.push(P_PROBLEM_TYPE), null);</span>
                        
<span class="nc" id="L790">            state.output.message(&quot;Doing benchmark &quot; + names[benchmark]);</span>

            try
                {
<span class="nc" id="L794">                trainingInputs = trainPoints(state, benchmark, 0);</span>
<span class="nc" id="L795">                trainingOutputs = new double[trainingInputs.length];</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                for(int i = 0 ; i &lt; trainingOutputs.length; i++)</span>
<span class="nc" id="L797">                    trainingOutputs[i] = func(state, trainingInputs[i], benchmark);</span>
                }
<span class="nc" id="L799">            catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L801">                state.output.fatal(&quot;Error in generating training data: &quot; + e.getMessage());</span>
<span class="nc" id="L802">                }</span>

            try
                {
<span class="nc" id="L806">                testingInputs = testPoints(state, benchmark, 0, trainingInputs);</span>
<span class="nc" id="L807">                testingOutputs = new double[testingInputs.length];</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                for(int i = 0 ; i &lt; testingOutputs.length; i++)</span>
<span class="nc" id="L809">                    testingOutputs[i] = func(state, testingInputs[i], benchmark);</span>
                }
<span class="nc" id="L811">            catch (IllegalArgumentException e)</span>
                {
<span class="nc" id="L813">                state.output.fatal(&quot;Error in generating testing data: &quot; + e.getMessage());</span>
<span class="nc" id="L814">                }</span>

            }
                        
                
<span class="nc" id="L819">        Parameter param = new Parameter(&quot;gp.tc.0.fset&quot;);  // we assume we have a single tree</span>
<span class="nc" id="L820">        String pval = state.parameters.getString(param, null);</span>
                
        // verify the number of variables match the expected function set
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (problem == null)  // it's being loaded from file</span>
            {
<span class="nc" id="L825">            boolean found = false;</span>
<span class="nc" id="L826">            String[] vars = fs_vars[trainingInputs[0].length];</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">            for(int i = 0; i&lt; vars.length; i++)</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                if (pval.equals(vars[i])) { found = true; break; }</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (!found)</span>
<span class="nc" id="L830">                state.output.warning(&quot;The number of variables in your problem data (&quot; + trainingInputs[0].length +</span>
                    &quot;does not match the variables found in the function set &quot; + pval + &quot;.  Hope you know what you're doing.&quot;,
                    param);
<span class="nc" id="L833">            else state.output.message(&quot;Using function set &quot; + pval);</span>
<span class="nc" id="L834">            }</span>
        else
            {
<span class="nc bnc" id="L837" title="All 2 branches missed.">            if (!(pval.equals(fs[benchmark])))  // uh oh</span>
<span class="nc" id="L838">                state.output.warning(&quot;The number of variables for the &quot; + names[benchmark] + </span>
                    &quot; problem (&quot; + trainingInputs[0].length +
                    &quot;) is normally handled by the function set &quot; + fs[benchmark] +
                    &quot; but you are using &quot; + pval + &quot;.  Hope you know what you're doing.  &quot;+ 
                    &quot;To correct this, try adding the parameter gp.tc.0.fset=&quot; + fs[benchmark],
                    param);
<span class="nc" id="L844">            else state.output.message(&quot;Using function set &quot; + pval);</span>
            }
<span class="nc" id="L846">        }</span>






    ///// Evaluation.  evaluate(...) uses training cases, and describe(...) uses testing cases


    public void evaluate(EvolutionState state, Individual ind, int subpopulation, int threadnum)
        {
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (!ind.evaluated)  // don't bother reevaluating</span>
            {
<span class="nc" id="L860">            RegressionData input = (RegressionData)(this.input);</span>

<span class="nc" id="L862">            int hits = 0;</span>
<span class="nc" id="L863">            double sum = 0.0;</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            for (int y=0;y&lt;trainingInputs.length;y++)</span>
                {
<span class="nc" id="L866">                currentValue = trainingInputs[y];</span>
<span class="nc" id="L867">                ((GPIndividual)ind).trees[0].child.eval(</span>
                    state,threadnum,input,stack,((GPIndividual)ind),this);

<span class="nc" id="L870">                double error = error(input.x, trainingOutputs[y]);</span>
                                
                // We'll keep the auxillary hits measure for tradition only 
<span class="nc" id="L873">                final double HIT_LEVEL = 0.01;</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                if (error &lt;= HIT_LEVEL) hits++; </span>

<span class="nc" id="L876">                sum += error;              </span>
                }
                
            // the fitness better be KozaFitness!
<span class="nc" id="L880">            KozaFitness f = ((KozaFitness)ind.fitness);</span>
<span class="nc" id="L881">            f.setStandardizedFitness(state, sum);</span>
<span class="nc" id="L882">            f.hits = hits;</span>
<span class="nc" id="L883">            ind.evaluated = true;</span>
            }
<span class="nc" id="L885">        }</span>


    public void describe(EvolutionState state, Individual ind, int subpopulation, int threadnum, int log)
        {
<span class="nc" id="L890">        RegressionData input = (RegressionData)(this.input);</span>

        // we do the testing set here
        
<span class="nc" id="L894">        state.output.println(&quot;\n\nPerformance of Best Individual on Testing Set:\n&quot;, log);</span>
                
<span class="nc" id="L896">        int hits = 0;</span>
<span class="nc" id="L897">        double sum = 0.0;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        for (int y=0;y&lt;testingInputs.length;y++)</span>
            {
<span class="nc" id="L900">            currentValue = testingInputs[y];</span>
<span class="nc" id="L901">            ((GPIndividual)ind).trees[0].child.eval(</span>
                state,threadnum,input,stack,((GPIndividual)ind),this);

<span class="nc" id="L904">            double error = error(input.x, testingOutputs[y]);</span>
                        
            // We'll keep the auxillary hits measure for tradition only 
<span class="nc" id="L907">            final double HIT_LEVEL = 0.01;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (error &lt;= HIT_LEVEL) hits++; </span>

<span class="nc" id="L910">            sum += error;              </span>
            }
                        
        // the fitness better be KozaFitness!
<span class="nc" id="L914">        KozaFitness f = (KozaFitness)(ind.fitness.clone());     // make a copy, we're just printing it out</span>
<span class="nc" id="L915">        f.setStandardizedFitness(state, sum);</span>
<span class="nc" id="L916">        f.hits = hits;</span>
                
<span class="nc" id="L918">        f.printFitnessForHumans(state, log);</span>
<span class="nc" id="L919">        }</span>
        
    }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>