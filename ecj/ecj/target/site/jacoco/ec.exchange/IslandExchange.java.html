<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IslandExchange.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.exchange</a> &gt; <span class="el_source">IslandExchange.java</span></div><h1>IslandExchange.java</h1><pre class="source lang-java linenums">/*
  Copyright 2006 by Sean Luke and George Mason University
  Licensed under the Academic Free License version 3.0
  See the file &quot;LICENSE&quot; for more information
*/


package ec.exchange;
import java.util.*;
import java.io.*;
import java.net.*;
import ec.*;
import ec.util.*;

/* 
 * IslandExchange.java
 * 
 * Created Sat Feb 10 13:44:11 EST 2001
 * By: Liviu Panait and Sean Luke
 */

/**
 * IslandExchange is an Exchanger which 
 * implements a simple but quite functional asynchronous
 * island model for doing massive parallel distribution of evolution across
 * beowulf clusters.  One of its really nice features is that because everything
 * is in Java, your cluster can have mixed platforms in it (MacOS, Unix, 
 * Windoze, whatever you like).  You can also have multiple processes running
 * on the same machine, as long as they're given different client ports.
 * IslandExchange operates over TCP/IP with Java sockets, and is compatible 
 * with checkpointing.
 *
 * &lt;p&gt;IslandExchange uses an arbitrary graph topology for migrating individuals
 * from island (EC process) to island over the network.  There are a few
 * restrictions for simplicity, however:

 &lt;ul&gt;
 &lt;li&gt; Every island must have the same kind of subpopulations and species.
 &lt;li&gt; Every subpopulation will send the same number of migrants as any 
 other subpopulation.
 &lt;li&gt; Migrants from a subpopulation will go to the same subpopulation.
 &lt;/ul&gt;

 * &lt;p&gt;Every island is a &lt;i&gt;client&lt;/i&gt;.  Additionally one island is designated
 * a &lt;i&gt;server&lt;/i&gt;.  Note that, just like in the Hair Club for Men, the server
 * is also a client.  The purpose of the server is to synchronize the clients
 * so that they all get set up properly and hook up to each other, then to
 * send them small signal messages (like informing them that another client has
 * discovered the ideal individual), and help them gracefully shut down.  Other
 * than these few signals which are routed through the server to the clients,
 * all other information -- namely the migrants themselves -- are sent directly
 * from client to client in a peer-to-peer fashion.
 *
 * &lt;p&gt;The topology of the network is stored solely in the server's parameter
 * database.  When the clients fire up, they first set up &quot;Mailboxes&quot; (where
 * immigrants from other clients will appear), then they go to the server 
 * and ask it who they should connect to to send migrants.  The server tells
 * them, and then they then hook up.  When a client has finished hooking up, it
 * reports this to the server.  After everyone has hooked up, the server tells
 * the clients to begin evolution, and they're off and running.
 *
 * &lt;p&gt;Islands send immigrants to other islands by copying good individuals
 * (selected with a SelectionMethod) and sending the good individuals to
 * the mailboxes of receiving clients.  Once an individual has been received,
 * it is considered to be unevaluated by the receiving island, even though 
 * it had been previously evaluated by the sending island.
 *
 * &lt;p&gt;The IslandExchange model is typically &lt;i&gt;asynchronous&lt;/i&gt; because migrants may
 * appear in your mailbox at any time; islands do not wait for each other
 * to complete the next generation.  This is a more efficient usage of network
 * bandwidth.  When an island completes its breeding, it looks inside its
 * mailbox for new migrants.  It then replaces some of its newly-bred
 * individuals (chosen entirely at random)
 * with the migrants (we could have increased the population size so we didn't
 * waste that breeding time, but we were lazy).  It then flushes the mailbox,
 * which patiently sits waiting for more individuals.
 *
 * &lt;p&gt;Clients may also be given different start times and modulos for 
 * migrating.  For example, client A might be told that he begins sending immigrants
 * only after generation 6, and then sends immigrants on every 4 generations beyond
 * that.  The purpose for the start times and modulos is so that not every client
 * sends immigrants at the same time; this also makes better use of network bandwidth.
 *
 * &lt;p&gt;When a client goes down, the other clients deal with it gracefully; they
 * simply stop trying to send to it.  But if the server goes down, the clients
 * do not continue operation; they will shut themselves down.  This means that in
 * general you can shut down an entire island model network just by killing the
 * server process.  However, if the server quits because it runs out of generations,
 * it will wait for the clients to all quit before it finally stops.
 *
 * &lt;p&gt;IslandExchange works correctly with checkpointing.  If you restart from
 * a checkpoint, the IslandExchange will start up the clients and servers again
 * and reconnect.  Processes can start from different checkpoints, of course.
 * However, realize that if you restart from a checkpoint, some migrants
 * may have been lost in transit from island to island.  That's the nature of
 * networking without heavy-duty transaction management! This means that we
 * cannot guarantee that restarting from checkpoint will yield the same results
 * as the first run yielded.
 *
 * &lt;p&gt;Islands are not described in the topology parameters by their
 * IP addresses; instead, they are described by &quot;ids&quot;, strings which uniquely 
 * identify each island.  For example, &quot;gilligans-island&quot; might be an id.  :-)
 * This allows you to move your topology to different IP addresses without having
 * to change all your parameter files!  You can even move your topology to totally
 * different machines, and restart from previous checkpoints, and everything
 * should still work correctly.
 *
 * &lt;p&gt;There are times, especially to experiment with dynamics, that you need
 * a &lt;i&gt;synchronous&lt;/i&gt; island model.  If you specify synchronicity, the server's
 * stated modulo and offset override any modulii or offsets specified by clients.
 * Everyone will use the server's modulo and offset.  This means that everyone
 * will trade individuals on the same generation.  Additionally, clients will wait
 * until everyone else has traded, before they are permitted to continue evolving.
 * This has the effect of locking all the clients together generation-wise; no
 * clients can run faster than any other clients.
 * 
 * &lt;p&gt;One last item: normally in this model, the server is also a client.  But 
 * if for some reason you need the server to be a process all by itself, without
 * creating a client as well, you can do that.  You spawn such a server differently
 * than the main execution of ECJ.  To spawn a server on a given server params file
 * (let's say it's server.params) but NOT spawn a client, you do:
 &lt;p&gt;&lt;pre&gt;
 java ec.exchange.IslandExchange -file server.params
 &lt;/pre&gt;
 * &lt;p&gt; ...this sets up a special process which just spawns a server, and doesn't do
 * all the setup of an evolutionary run.  Of course as usual, for each of the 
 * clients, you'll run &lt;tt&gt;java ec.Evolve ...&lt;/tt&gt; instead.

 &lt;p&gt;&lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;
 &lt;p&gt;&lt;i&gt;Note:&lt;/i&gt; some of these parameters are only necessary for creating
 &lt;b&gt;clients&lt;/b&gt;.  Others are necessary for creating the &lt;b&gt;server&lt;/b&gt;.
 &lt;table&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.chatty&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;boolean, default = true&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt; Should we be verbose or silent about our exchanges?
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.select&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;classname, inherits and != ec.SelectionMethod&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The selection method used for picking migrants to emigrate to other islands
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.select-to-die&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;classname, inherits and != ec.SelectionMethod, default is ec.select.RandomSelection&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The selection method used for picking individuals to be replaced by incoming migrants.
 &lt;b&gt;IMPORTANT Note&lt;/b&gt;.  This selection method must &lt;i&gt;not&lt;/i&gt; pick an individual based on fitness.
 The selection method will be called just after breeding but &lt;i&gt;before&lt;/i&gt; evaluation; many individuals
 will not have had a fitness assigned at that point.  You might want to design a SelectionMethod
 other than RandomSelection, however, to do things like not picking elites to die.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.server-addr&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;String&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The IP address of the server
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.server-port&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The port number of the server
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.client-port&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The port number of the client (where it will receive migrants) -- this should be different from the server port.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.id&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;String&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: The &quot;name&quot; the client is giving itself.  Each client should have a unique name.  For example, &quot;gilligans-island&quot;.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.compressed&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;bool = &lt;tt&gt;true&lt;/tt&gt; (default) or &lt;tt&gt;false&lt;/tt&gt;&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: Whether the communication with other islands should be compressed or not.  Compressing uses more CPU, but it may also significantly reduce communication.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.i-am-server&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default)&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;client&lt;/i&gt;: Is this client also the server?  If so, it'll read the server parameters and set up a server as well.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.sync&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default)&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: Are we doing a synchronous island model?  If so, the server's modulo and offset override any client's stated modulo and offset.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.num-islands&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The number of islands in the topology.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.id&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;String&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The ID of island #n in the topology.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.num-mig&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The number of islands that island #n sends immigrants to.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.mig.&lt;/tt&gt;&lt;i&gt;m&lt;/i&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The ID of island #m that island #n sends immigrants to.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.size&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The number of immigrants (per subpopulation) that island #n sends to other islands.  If not set, uses the default parameter below.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.size&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: Default parameter: number of immigrants (per subpopulation) that a given island sends to other islands.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.start&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 0&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The generation when island #n begins sending immigrants. If not set, uses the default parameter below.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.start&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default)&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: Default parameter: the generation when an island begins sending immigrants.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.mod&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The number of generations that island #n waits between sending immigrants.  If not set, uses the default parameter below.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.mod&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;bool = &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; (default)&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: Default parameter: The number of generations an island waits between sending immigrants.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.island.&lt;i&gt;n&lt;/i&gt;.mailbox-capacity&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: The maximum size (per subpopulation) of the mailbox for island #n.  If not set, uses the default parameter below.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.mailbox-capacity&lt;/tt&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 1&lt;/font&gt;&lt;/td&gt;
 &lt;td valign=top&gt;
 &lt;i&gt;server&lt;/i&gt;: Default parameter: the maximum size (per subpopulation) of the mailbox for a given island.
 &lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
 
 &lt;p&gt;&lt;b&gt;Parameter bases&lt;/b&gt;&lt;br&gt;
 &lt;table&gt;

 &lt;tr&gt;&lt;td valign=top&gt;&lt;tt&gt;&lt;i&gt;base&lt;/i&gt;.select&lt;/tt&gt;&lt;/td&gt;
 &lt;td&gt;selection method for the client's migrants&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;
  
 * @author Liviu Panait and Sean Luke
 * @version 2.0
 */

<span class="nc" id="L259">public class IslandExchange extends Exchanger</span>
    {
    private static final long serialVersionUID = 1;

    //// Client information

    /** The server address */
    public static final String P_SERVER_ADDRESS = &quot;server-addr&quot;;

    /** The server port */
    public static final String P_SERVER_PORT = IslandExchangeServer.P_SERVER_PORT;

    /** The client port */
    public static final String P_CLIENT_PORT = &quot;client-port&quot;;

    /** Whether the server is also on this island */
    public static final String P_IS_SERVER = &quot;i-am-server&quot;;
    
    /** The id of the island */
    public static final String P_OWN_ID = &quot;id&quot;;
        
    /** Whether the communication is compressed or not */
    public static final String P_COMPRESSED_COMMUNICATION = &quot;compressed&quot;;

    /** The selection method for sending individuals to other islands */
    public static final String P_SELECT_METHOD = &quot;select&quot;;

    /** The selection method for deciding individuals to be replaced by immigrants */
    public static final String P_SELECT_TO_DIE_METHOD = &quot;select-to-die&quot;;

    /** How long we sleep in between attempts to connect or look for signals */
    public static final int SLEEP_TIME = 100;

    /** How long we sleep between checking for FOUND messages */
    public static final int FOUND_TIMEOUT = 100;

    /** Whether or not we're chatty */
    public static final String P_CHATTY = &quot;chatty&quot;;

    /** Okay signal */
    public static final String OKAY = &quot;okay&quot;;

    /** Synchronize signal */
    public static final String SYNC = &quot;sync&quot;;

    /** Found signal */
    public static final String FOUND = &quot;found&quot;;

    /** Our chattiness */
    boolean chatty;

    /** The thread of the server (is different than null only for the island with the server) */
    public Thread serverThread;

    /** My parameter base -- I need to keep this in order to help the server
        reinitialize contacts */
    // SERIALIZE
    public Parameter base;
    
    /** The address of the server */
    // SERIALIZE
    public String serverAddress;

    /** The port of the server */
    // SERIALIZE
    public int serverPort;

    /** The port of the client mailbox */
    // SERIALIZE
    public int clientPort;

    /** whether the server should be running on the current island or not */
    // SERIALIZE
    public boolean iAmServer;

    /** the id of the current island */
    // SERIALIZE
    public String ownId;

    /** whether the communication is compressed or not */
    // SERIALIZE
    public boolean compressedCommunication;

    /** the selection method for immigrants */
    // SERIALIZE
    public SelectionMethod immigrantsSelectionMethod;

    /** the selection method for individuals to be replaced by immigrants */
    // SERIALIZE
    public SelectionMethod indsToDieSelectionMethod;

    // the mailbox of the current client (exchanger)
    IslandExchangeMailbox mailbox;

    // the thread of the mailbox
    Thread mailboxThread;

    /// Communication with the islands where individuals have to be sent
    // Number of islands to send individuals to
    int number_of_destination_islands;

    /** synchronous or asynchronous communication */
    public boolean synchronous;

    /** how often to send individuals */
    public int modulo;

    /** after how many generations to start sending individuals */
    public int offset;

    /** how many individuals to send each time */
    public int size;

    // Sockets to the destination islands
    Socket[] outSockets;

    // DataOutputStream to the destination islands
    DataOutputStream[] outWriters;

    // so we can print out nice names for our outgoing connections
    public String[] outgoingIds;

    // information on the availability of the different islands
    boolean[] running;

    // the capacity of the mailboxes
    //    int mailboxCapacity;

    // the socket to the server
    Socket serverSocket;

    // reader and writer to the serverSocket
    DataOutputStream toServer;
    DataInputStream fromServer;

    // am I ONLY a server?
    static boolean just_server;

    public static void main(String[] args) throws InterruptedException
        {
<span class="nc" id="L399">        just_server = true;</span>
        int x;
<span class="nc" id="L401">        ParameterDatabase parameters=null;</span>
        Output output;
        boolean store;
        
        // The following is a little chunk of the ec.Evolve code sufficient
        // to get IslandExchange up and running all by itself.
        
<span class="nc" id="L408">        System.err.println(&quot;Island Exchange Server\n&quot; +</span>
            &quot;Used in ECJ by Sean Luke\n&quot;);
        
        
        // 0. find the parameter database
<span class="nc bnc" id="L413" title="All 2 branches missed.">        for(x=0;x&lt;args.length-1;x++)</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            if (args[x].equals(Evolve.A_FILE))</span>
                {
                try
                    {
<span class="nc" id="L418">                    parameters=new ParameterDatabase(</span>
                        // not available in jdk1.1: new File(args[x+1]).getAbsoluteFile(),
<span class="nc" id="L420">                        new File(new File(args[x+1]).getAbsolutePath()),</span>
                        args);
<span class="nc" id="L422">                    break;</span>
                    }
<span class="nc" id="L424">                catch(FileNotFoundException e)</span>
<span class="nc" id="L425">                    { Output.initialError(</span>
                            &quot;A File Not Found Exception was generated upon&quot; +
                            &quot;reading the parameter file \&quot;&quot; + args[x+1] + 
                            &quot;\&quot;.\nHere it is:\n&quot; + e); }
<span class="nc" id="L429">                catch(IOException e)</span>
<span class="nc" id="L430">                    { Output.initialError(</span>
                            &quot;An IO Exception was generated upon reading the&quot; +
                            &quot;parameter file \&quot;&quot; + args[x+1] +
<span class="nc" id="L433">                            &quot;\&quot;.\nHere it is:\n&quot; + e); } </span>
                }
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (parameters==null)</span>
<span class="nc" id="L436">            Output.initialError(</span>
                &quot;No parameter file was specified.&quot; ); 

        // 1. create the output
        //store = (parameters.getBoolean(new Parameter(Evolve.P_STORE),null,false));

<span class="nc" id="L442">        output = new Output(true);</span>
        // output.setFlush(
        //    parameters.getBoolean(new Parameter(Evolve.P_FLUSH),null,false));


        // stdout is always log #0.  stderr is always log #1.
        // stderr accepts announcements, and both are fully verbose 
        // by default.
<span class="nc" id="L450">        output.addLog(ec.util.Log.D_STDOUT,false);</span>
<span class="nc" id="L451">        output.addLog(ec.util.Log.D_STDERR,true); </span>
        
        
        // this is an ugly, ugly, ugly, UGLY HACK
        // it will only work if we don't ask interesting things
        // of our &quot;EvolutionState&quot;  :-)  you know, things like
        // random number generators or generation numbers!
        
<span class="nc" id="L459">        EvolutionState myEvolutionState = new EvolutionState();</span>
        
<span class="nc" id="L461">        myEvolutionState.parameters = parameters;</span>
<span class="nc" id="L462">        myEvolutionState.output = output;</span>
        
        // set me up
<span class="nc" id="L465">        Parameter myBase = new Parameter(EvolutionState.P_EXCHANGER);</span>

<span class="nc" id="L467">        IslandExchange ie = (IslandExchange)parameters.getInstanceForParameterEq(myBase, null, IslandExchange.class);</span>
        
<span class="nc" id="L469">        ie.setup(myEvolutionState,myBase);</span>
<span class="nc" id="L470">        ie.fireUpServer(myEvolutionState,myBase);</span>
<span class="nc" id="L471">        ie.serverThread.join();</span>
        
        // flush the output
<span class="nc" id="L474">        output.flush();</span>
<span class="nc" id="L475">        System.err.flush();</span>
<span class="nc" id="L476">        System.out.flush();</span>
<span class="nc" id="L477">        System.exit(0);</span>
<span class="nc" id="L478">        }</span>

    // sets up the Island Exchanger
    public void setup( final EvolutionState state, final Parameter _base )
        {
<span class="nc" id="L483">        base = _base;</span>

        Parameter p;
        
        // get the port of the server
<span class="nc" id="L488">        p = base.push( P_SERVER_PORT );</span>
<span class="nc" id="L489">        serverPort = state.parameters.getInt( p, null, 1 );</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if( serverPort == 0 )</span>
<span class="nc" id="L491">            state.output.fatal( &quot;Could not get the port of the server, or it is invalid.&quot;, p );</span>

<span class="nc" id="L493">        chatty = state.parameters.getBoolean(base.push(P_CHATTY), null, true);</span>

        // by default, communication is not compressed
<span class="nc" id="L496">        compressedCommunication = state.parameters.getBoolean(base.push(P_COMPRESSED_COMMUNICATION),null,false);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if( compressedCommunication )</span>
            {
            //            state.output.fatal(&quot;JDK 1.5 has broken compression.  For now, you must set &quot; + base.push(P_COMPRESSED_COMMUNICATION) + &quot;=false&quot;);
<span class="nc" id="L500">            state.output.message( &quot;Communication will be compressed&quot; ); </span>
            }
            
        // check whether it has to launch the main server for coordination
<span class="nc" id="L504">        p = base.push( P_IS_SERVER );</span>
<span class="nc" id="L505">        iAmServer = state.parameters.getBoolean( p, null, false );</span>

        // Am I ONLY the server or not?
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (just_server)</span>
            {
            // print out my IP address
            try
                {
<span class="nc" id="L513">                state.output.message(&quot;IP ADDRESS: &quot; + LocalHost.getLocalHost().getHostAddress());</span>
                }
<span class="nc" id="L515">            catch (java.net.UnknownHostException e) { }</span>
            }
        else
            {
            // setup the selection method
<span class="nc" id="L520">            p = base.push( P_SELECT_METHOD );</span>
<span class="nc" id="L521">            immigrantsSelectionMethod = (SelectionMethod)</span>
<span class="nc" id="L522">                state.parameters.getInstanceForParameter( p, null, ec.SelectionMethod.class );</span>
<span class="nc" id="L523">            immigrantsSelectionMethod.setup( state, base );</span>

            // setup the selection method
<span class="nc" id="L526">            p = base.push( P_SELECT_TO_DIE_METHOD );</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if( state.parameters.exists( p, null) )</span>
<span class="nc" id="L528">                indsToDieSelectionMethod = (SelectionMethod)</span>
<span class="nc" id="L529">                    state.parameters.getInstanceForParameter( p, null, ec.SelectionMethod.class );</span>
            else // use RandomSelection
<span class="nc" id="L531">                indsToDieSelectionMethod = new ec.select.RandomSelection();</span>
<span class="nc" id="L532">            indsToDieSelectionMethod.setup( state, base );</span>

            // get the address of the server
<span class="nc" id="L535">            p = base.push( P_SERVER_ADDRESS );</span>
<span class="nc" id="L536">            serverAddress = state.parameters.getStringWithDefault( p, null, &quot;&quot; );</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if( serverAddress.equalsIgnoreCase(&quot;&quot;) )</span>
<span class="nc" id="L538">                state.output.fatal( &quot;Could not get the address of the server.&quot;, p );</span>

            // get the port of the client mailbox
<span class="nc" id="L541">            p = base.push( P_CLIENT_PORT );</span>
<span class="nc" id="L542">            clientPort = state.parameters.getInt( p, null, 1 );</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if( clientPort == 0 )</span>
<span class="nc" id="L544">                state.output.fatal( &quot;Could not get the port of the client, or it is invalid.&quot;, p );</span>

            // get the id of the island
<span class="nc" id="L547">            p = base.push( P_OWN_ID );</span>
<span class="nc" id="L548">            ownId = state.parameters.getStringWithDefault( p, null, &quot;&quot; );</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if( ownId.equals(&quot;&quot;) )</span>
<span class="nc" id="L550">                state.output.fatal( &quot;Could not get the Id of the island.&quot;, p );</span>
            }
<span class="nc" id="L552">        }</span>

    /** Custom serialization */
    private void writeObject(ObjectOutputStream out) throws IOException
        {
        // this is all we need to write out -- everything else
        // gets recreated when we call reinitializeContacts(...) again...
    
<span class="nc" id="L560">        out.writeObject(base);</span>
<span class="nc" id="L561">        out.writeObject(serverAddress);</span>
<span class="nc" id="L562">        out.writeObject(ownId);</span>
<span class="nc" id="L563">        out.writeBoolean(compressedCommunication);</span>
<span class="nc" id="L564">        out.writeObject(immigrantsSelectionMethod);</span>
<span class="nc" id="L565">        out.writeObject(indsToDieSelectionMethod);</span>
<span class="nc" id="L566">        out.writeInt(serverPort);</span>
<span class="nc" id="L567">        out.writeInt(clientPort);</span>
<span class="nc" id="L568">        out.writeBoolean(iAmServer);</span>
<span class="nc" id="L569">        }</span>

    /** Custom serialization */
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException
        {
        // this is all we need to read in -- everything else
        // gets recreated when we call reinitializeContacts(...) again...
    
<span class="nc" id="L577">        base = (Parameter)(in.readObject());</span>
<span class="nc" id="L578">        serverAddress=(String)(in.readObject());</span>
<span class="nc" id="L579">        ownId=(String)(in.readObject());</span>
<span class="nc" id="L580">        compressedCommunication = in.readBoolean();</span>
<span class="nc" id="L581">        immigrantsSelectionMethod=(SelectionMethod)(in.readObject());</span>
<span class="nc" id="L582">        indsToDieSelectionMethod=(SelectionMethod)(in.readObject());</span>
<span class="nc" id="L583">        serverPort = in.readInt();</span>
<span class="nc" id="L584">        clientPort = in.readInt();</span>
<span class="nc" id="L585">        iAmServer = in.readBoolean();</span>
<span class="nc" id="L586">        }</span>
    
    
    /** Fires up the server. */

    public void fireUpServer(EvolutionState state, Parameter serverBase)
        {
<span class="nc" id="L593">        IslandExchangeServer serv = new IslandExchangeServer();</span>
<span class="nc" id="L594">        serv.setupServerFromDatabase(state,serverBase);</span>
<span class="nc" id="L595">        serverThread = serv.spawnThread();</span>
<span class="nc" id="L596">        }</span>
        

    /** Initializes contacts with other processes, if that's what you're doing. Called at the beginning of an evolutionary run, before a population is set up. */
    public void initializeContacts(EvolutionState state)
        {

        // launch the server
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if( iAmServer )</span>
            {
<span class="nc" id="L606">            fireUpServer(state,base);</span>
<span class="nc" id="L607">            state.output.message( &quot;Server Launched.&quot; );</span>
            }
        else
            {
<span class="nc" id="L611">            state.output.message( &quot;I'm just a client.&quot; );</span>
            }



        // In this thread, *I* am the client.  I connect to the server
        // and get the information from the server, then I connect
        // to the clients and go through the synchronization process
        // with the server.  Spawn the mailbox. When the server says &quot;go&quot;, I'm done with
        // this function.


        /** Make our connections and hook up */
<span class="nc" id="L624">        long l = 0;</span>
        try
            { 
            // spin until we get a connection
<span class="nc" id="L628">            state.output.message(&quot;Connecting to Server &quot; + serverAddress + &quot;, port &quot; + serverPort);</span>
            while(true)
                {
                try
                    {
<span class="nc" id="L633">                    serverSocket = new Socket(serverAddress,serverPort);</span>
<span class="nc" id="L634">                    break;</span>
                    }
<span class="nc" id="L636">                catch (IOException e)   // it's not up yet...</span>
                    {
<span class="nc" id="L638">                    l++;</span>
                    try
                        {
<span class="nc" id="L641">                        Thread.sleep( 5000 );</span>
                        }
<span class="nc" id="L643">                    catch( InterruptedException f )</span>
                        {
<span class="nc" id="L645">                        state.output.message(&quot;&quot;+f);</span>
<span class="nc" id="L646">                        }</span>
<span class="nc" id="L647">                    state.output.message(&quot;Retrying&quot;);</span>
<span class="nc" id="L648">                    }</span>
                }
            
            // okay, we're connected.  Send our info.
<span class="nc" id="L652">            state.output.message(&quot;Connected to Server after &quot; + (l * SLEEP_TIME) + &quot; ms&quot;);</span>
<span class="nc" id="L653">            fromServer = new DataInputStream(serverSocket.getInputStream());</span>
<span class="nc" id="L654">            toServer = new DataOutputStream(serverSocket.getOutputStream());</span>

            // sending the server own contact information
<span class="nc" id="L657">            toServer.writeUTF( ownId );</span>
<span class="nc" id="L658">            toServer.flush();</span>

            // Launch the mailbox thread (read from the server how many sockets to allocate
            // on the mailbox. Obtain the port and address of the mailbox.
<span class="nc" id="L662">            mailbox = new IslandExchangeMailbox( state, clientPort, fromServer.readInt(),</span>
<span class="nc" id="L663">                fromServer.readInt(), ownId, chatty, compressedCommunication );</span>
<span class="nc" id="L664">            mailboxThread = new Thread( mailbox );</span>
<span class="nc" id="L665">            mailboxThread.start();</span>

            // record that the mailbox has been created
<span class="nc" id="L668">            state.output.message( &quot;IslandExchangeMailbox created.&quot; );</span>

            // tell the server the address and port of the mailbox
            try
                {
<span class="nc" id="L673">                toServer.writeUTF( LocalHost.getLocalHost().getHostAddress() );</span>
<span class="nc" id="L674">                toServer.flush();</span>
<span class="nc" id="L675">                state.output.message(&quot;My address is: &quot; + LocalHost.getLocalHost().getHostAddress() );</span>
                }
<span class="nc" id="L677">            catch( UnknownHostException e )</span>
                {
<span class="nc" id="L679">                state.output.fatal( &quot;Could not get the address of the local computer.&quot; );</span>
<span class="nc" id="L680">                }</span>
<span class="nc" id="L681">            toServer.writeInt( mailbox.getPort() );</span>
<span class="nc" id="L682">            toServer.flush();</span>

            // read from the server the modulo, offset and size it has to use.
            // this parameters allow an extendable/modifiable version where different
            // islands send different number of individuals (based on the size of their populations)
<span class="nc bnc" id="L687" title="All 2 branches missed.">            synchronous = ( fromServer.readInt() == 1 );</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            if( synchronous )</span>
                {
<span class="nc" id="L690">                state.output.message( &quot;The communication will be synchronous.&quot; );</span>
                }
            else
                {
<span class="nc" id="L694">                state.output.message( &quot;The communication will be asynchronous.&quot; );</span>
                }
<span class="nc" id="L696">            modulo = fromServer.readInt();</span>
<span class="nc" id="L697">            offset = fromServer.readInt();</span>
<span class="nc" id="L698">            size = fromServer.readInt();</span>

            // read the number of islands it has to send messages to
<span class="nc" id="L701">            number_of_destination_islands = fromServer.readInt();</span>

            // allocate the arrays
<span class="nc" id="L704">            outSockets = new Socket[ number_of_destination_islands ];</span>
<span class="nc" id="L705">            outWriters = new DataOutputStream[ number_of_destination_islands ];</span>
<span class="nc" id="L706">            running = new boolean[ number_of_destination_islands ];</span>
<span class="nc" id="L707">            outgoingIds = new String[ number_of_destination_islands ];</span>

            // open connections to each of the destination islands
<span class="nc bnc" id="L710" title="All 2 branches missed.">            for( int y = 0 ; y &lt; number_of_destination_islands ; y++ )</span>
                {
                // get the address and the port
<span class="nc" id="L713">                String address = fromServer.readUTF().trim();</span>
<span class="nc" id="L714">                int port = fromServer.readInt();</span>
                try
                    {
                    try
                        {
<span class="nc" id="L719">                        state.output.message( &quot;Trying to connect to &quot; + address + &quot; : &quot; + port );</span>
                        // try opening a connection
<span class="nc" id="L721">                        outSockets[y] = new Socket( address, port );</span>
                        }
<span class="nc" id="L723">                    catch( UnknownHostException e )</span>
                        {
                        // gracefully handle communication errors
<span class="nc" id="L726">                        state.output.warning( &quot;Unknown host exception while the client was opening a socket to &quot; + address + &quot; : &quot; + port );</span>
<span class="nc" id="L727">                        running[y] = false;</span>
<span class="nc" id="L728">                        continue;</span>
<span class="nc" id="L729">                        }</span>

<span class="nc bnc" id="L731" title="All 2 branches missed.">                    if( compressedCommunication )</span>
                        {
                        /*                        
                                                  outWriters[y] = new DataOutputStream(new CompressingOutputStream(outSockets[y].getOutputStream()));
                                                  // read the mailbox's id, then write my own id
                                                  outgoingIds[y] = new DataInputStream(new CompressingInputStream(outSockets[y].getInputStream())).readUTF().trim();
                        */
                        
<span class="nc" id="L739">                        OutputStream compressedo = Output.makeCompressingOutputStream(outSockets[y].getOutputStream());</span>
<span class="nc" id="L740">                        InputStream compressedi = Output.makeCompressingInputStream(outSockets[y].getInputStream());</span>
<span class="nc bnc" id="L741" title="All 4 branches missed.">                        if (compressedi == null || compressedo == null) </span>
<span class="nc" id="L742">                            state.output.fatal( &quot;You do not appear to have JZLib installed on your system, and so may must have compression turned off for IslandExchange.  &quot;+ </span>
                                &quot;To get JZLib, download from the ECJ website or from http://www.jcraft.com/jzlib/&quot;);
<span class="nc" id="L744">                        outWriters[y] = new DataOutputStream(compressedo);</span>
<span class="nc" id="L745">                        outgoingIds[y] = new DataInputStream(compressedi).readUTF().trim();</span>
<span class="nc" id="L746">                        }</span>
                    else
                        {
<span class="nc" id="L749">                        outWriters[y] = new DataOutputStream(outSockets[y].getOutputStream());</span>

                        // read the mailbox's id, then write my own id
<span class="nc" id="L752">                        outgoingIds[y] = new DataInputStream(outSockets[y].getInputStream()).readUTF().trim();</span>
                        }
                        
<span class="nc" id="L755">                    outWriters[y].writeUTF(ownId);</span>
<span class="nc" id="L756">                    outWriters[y].flush();</span>
            
<span class="nc" id="L758">                    running[y] = true;</span>
                    }
<span class="nc" id="L760">                catch( IOException e )</span>
                    {
                    // this is caused if the server had problems locating information
                    // on the mailbox of the other island, therefore remember the
                    // communication with this island is not setup properly
<span class="nc" id="L765">                    state.output.warning( &quot;IO exception while the client was opening sockets to other islands' mailboxes :&quot; + e );</span>
<span class="nc" id="L766">                    running[y] = false;</span>
<span class="nc" id="L767">                    }</span>
                }

            // synchronization stuff: tells the server it finished connecting to other mailboxes
<span class="nc" id="L771">            toServer.writeUTF( OKAY );</span>
<span class="nc" id="L772">            toServer.flush();</span>

            // wait for the run signal
<span class="nc" id="L775">            fromServer.readUTF();</span>

            }
<span class="nc" id="L778">        catch( IOException e )</span>
            {
<span class="nc" id="L780">            state.output.fatal( &quot;Error communicating to the server.&quot; );</span>
<span class="nc" id="L781">            }</span>

        // at this point, the mailbox is looking for incoming messages
        // form other islands. we have to exit the function. there is
        // one more thing to be done: to check for the server sending a
        // FOUND signal. In order to do this, we set the socket to the
        // server as non-blocking, and verify that for messages from the
        // server in the runComplete function
        try
            {
<span class="nc" id="L791">            serverSocket.setSoTimeout( FOUND_TIMEOUT );</span>
            }
<span class="nc" id="L793">        catch( SocketException e )</span>
            {
<span class="nc" id="L795">            state.output.fatal( &quot;Could not set the connection to the server to non-blocking.&quot; );</span>
<span class="nc" id="L796">            }</span>

<span class="nc" id="L798">        }</span>

    /** Initializes contacts with other processes, if that's what you're doing.  Called after restarting from a checkpoint. */
    public void reinitializeContacts(EvolutionState state)
        {
        // This function is almost the same as initializeContacts.
        // The only main difference is that when reinitializeContacts
        // is called, it's called because I started up from a checkpoint file.
        // This means that I'm in the middle of evolution, so the modulo
        // and start might cause me to update more recently than if I had
        // started fresh.  But maybe it won't make a difference in this method
        // if the way I determine when I'm firing off migrants is on a
        // generation-by-generation basis.

<span class="nc" id="L812">        initializeContacts( state );</span>

<span class="nc" id="L814">        }</span>



    public Population preBreedingExchangePopulation(EvolutionState state)
        {
        // sending individuals to other islands
        // BUT ONLY if my modulo and offset are appropriate for this
        // generation (state.generation)
        // I am responsible for returning a population.  This could
        // be a new population that I created fresh, or I could modify
        // the existing population and return that.

        // else, check whether the immigrants need to be sent
<span class="nc bnc" id="L828" title="All 6 branches missed.">        if( ( state.generation &gt;= offset ) &amp;&amp;</span>
            ( ( modulo == 0 ) || ( ( ( state.generation - offset ) % modulo ) == 0 ) ) )
            {

            // send the individuals!!!!

            // for each of the islands where we have to send individuals
<span class="nc bnc" id="L835" title="All 2 branches missed.">            for( int x = 0 ; x &lt; number_of_destination_islands ; x++ )</span>
                try
                    {

                    // check whether the communication is ok with the current island
<span class="nc bnc" id="L840" title="All 2 branches missed.">                    if( running[x] )</span>
                        {

<span class="nc bnc" id="L843" title="All 2 branches missed.">                        if (chatty) state.output.message( &quot;Sending &quot; + size + &quot; immigrants to island &quot; + outgoingIds[x] );</span>

                        // for each of the subpopulations
<span class="nc bnc" id="L846" title="All 2 branches missed.">                        for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++ )</span>
                            {
                            // send the subpopulation
<span class="nc" id="L849">                            outWriters[x].writeInt( subpop );</span>

                            // send the number of individuals to be sent
                            // it's better to send this information too, such that islands can (potentially)
                            // send different numbers of individuals
<span class="nc" id="L854">                            outWriters[x].writeInt( size );</span>

                            // select &quot;size&quot; individuals and send then to the destination as immigrants
<span class="nc" id="L857">                            immigrantsSelectionMethod.prepareToProduce( state, subpop, 0 );</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                            for( int y = 0 ; y &lt; size ; y++ ) // send all necesary individuals</span>
                                {
<span class="nc" id="L860">                                int index = immigrantsSelectionMethod.produce( subpop, state, 0 );</span>
<span class="nc" id="L861">                                process(state, 0, outgoingIds[x], subpop, state.population.subpops.get(subpop).individuals.get(index)).writeIndividual( state, outWriters[x] );</span>
                                // TODO -- should we move this to the end?
<span class="nc" id="L863">                                outWriters[x].flush();  // just in case the individuals didn't do a println</span>
                                }
<span class="nc" id="L865">                            immigrantsSelectionMethod.finishProducing( state, subpop, 0 ); // end the selection step</span>
                            }
                        }
                    }
<span class="nc" id="L869">                catch( IOException e )</span>
                    {
<span class="nc" id="L871">                    running[x] = false;</span>
<span class="nc" id="L872">                    }</span>
            }

<span class="nc" id="L875">        return state.population;</span>

        }


    public Population postBreedingExchangePopulation(EvolutionState state)
        {
        // receiving individuals from other islands
        // same situation here of course.

        // if synchronous communication, synchronize with the mailbox
        // if( ( state.generation &gt;= offset ) &amp;&amp; synchronous &amp;&amp;
        //    ( ( modulo == 0 ) || ( ( ( state.generation - offset ) % modulo ) == 0 ) ) )
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (synchronous)</span>
            {
<span class="nc" id="L890">            state.output.message( &quot;Waiting for synchronization....&quot; );</span>

            // set the socket to the server to blocking
            try
                {
<span class="nc" id="L895">                serverSocket.setSoTimeout( 0 );</span>
                }
<span class="nc" id="L897">            catch( SocketException e )</span>
                {
<span class="nc" id="L899">                state.output.fatal( &quot;Could not set the connection to the server to blocking.&quot; );</span>
<span class="nc" id="L900">                }</span>

            try
                {
                // send the sync message
<span class="nc" id="L905">                toServer.writeUTF( SYNC );</span>
<span class="nc" id="L906">                toServer.flush();</span>
                // wait for the okay message
<span class="nc" id="L908">                String temp = fromServer.readUTF();</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">                if( temp.equals( IslandExchangeServer.GOODBYE ) )</span>
                    {
<span class="nc" id="L911">                    alreadyReadGoodBye = true;</span>
                    }
                }
<span class="nc" id="L914">            catch( IOException e )</span>
                {
<span class="nc" id="L916">                state.output.fatal( &quot;Could not communicate to the server. Exiting....&quot; );</span>
<span class="nc" id="L917">                }</span>

            // set the socket to the server to non-blocking
            try
                {
<span class="nc" id="L922">                serverSocket.setSoTimeout( FOUND_TIMEOUT );</span>
                }
<span class="nc" id="L924">            catch( SocketException e )</span>
                {
<span class="nc" id="L926">                state.output.fatal( &quot;Could not set the connection to the server to non-blocking.&quot; );</span>
<span class="nc" id="L927">                }</span>
            //state.output.message( &quot;Synchronized. Reading individuals....&quot; );
            }

        // synchronize, because immigrants is also accessed by the mailbox thread
<span class="nc" id="L932">        synchronized( mailbox.immigrants )</span>
            {
<span class="nc bnc" id="L934" title="All 2 branches missed.">            for( int x = 0 ; x &lt; mailbox.immigrants.length ; x++ )</span>
                {
<span class="nc bnc" id="L936" title="All 2 branches missed.">                if( mailbox.nImmigrants[x] &gt; 0 )</span>
                    {
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    if (chatty) state.output.message( &quot;Immigrating &quot; +  mailbox.nImmigrants[x] + &quot; individuals from mailbox for subpopulation &quot; + x );</span>

<span class="nc" id="L940">                    boolean[] selected = new boolean[ state.population.subpops.get(x).individuals.size() ];</span>
<span class="nc" id="L941">                    int[] indices = new int[ mailbox.nImmigrants[x] ];</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                    for( int i = 0 ; i &lt; selected.length ; i++ )</span>
<span class="nc" id="L943">                        selected[i] = false;</span>
<span class="nc" id="L944">                    indsToDieSelectionMethod.prepareToProduce( state, x, 0 );</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                    for( int i = 0 ; i &lt; mailbox.nImmigrants[x] ; i++ )</span>
                        {
                        do {
<span class="nc" id="L948">                            indices[i] = indsToDieSelectionMethod.produce( x, state, 0 );</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                            } while( selected[indices[i]] );</span>
<span class="nc" id="L950">                        selected[indices[i]] = true;</span>
                        }
<span class="nc" id="L952">                    indsToDieSelectionMethod.finishProducing( state, x, 0 );</span>

                    // there is no need to check for the differences in size: the mailbox.immigrants,
                    // state.population.subpops and the mailbox.nextIndexPosition should have the same size
<span class="nc bnc" id="L956" title="All 2 branches missed.">                    for( int y = 0 ; y &lt; mailbox.nImmigrants[x] ; y++ )</span>
                        {

                        // read the individual
<span class="nc" id="L960">                        state.population.subpops.get(x).</span>
<span class="nc" id="L961">                            individuals.set(indices[y],mailbox.immigrants[x][y]);</span>

                        // reset the evaluated flag (the individuals are not evaluated in the current island */
<span class="nc" id="L964">                        state.population.subpops.get(x).</span>
<span class="nc" id="L965">                            individuals.get(indices[y]).evaluated = false;</span>

                        }

                    // reset the number of immigrants in the mailbox for the current subpopulation
                    // this doesn't need another synchronization, because the thread is already synchronized
<span class="nc" id="L971">                    mailbox.nImmigrants[x] = 0;</span>

                    }
                }

<span class="nc" id="L976">            }</span>

<span class="nc" id="L978">        return state.population;</span>
        }

    // if the GOODBYE message sent by the server gets read in the wrong place, this
    // variable is set to true
<span class="nc" id="L983">    boolean alreadyReadGoodBye = false;</span>

    // keeps the message to be returned next time on runComplete
    String message;

    /** Called after preBreedingExchangePopulation(...) to evaluate whether or not
        the exchanger wishes the run to shut down (with ec.EvolutionState.R_FAILURE).
        This would happen for two reasons.  First, another process might have found
        an ideal individual and the global run is now over.  Second, some network
        or operating system error may have occurred and the system needs to be shut
        down gracefully.
        This function does not return a String as soon as it wants to exit (another island found
        the perfect individual, or couldn't connect to the server). Instead, it sets a flag, called
        message, to remember next time to exit. This is due to a need for a graceful
        shutdown, where checkpoints are working properly and save all needed information. */
    public String runComplete(EvolutionState state)
        {
        // first test the flag, and exit if it was previously set
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        if( message != null ) // if an error occured earlier</span>
            {
<span class="nc" id="L1003">            return message;</span>
            }

        // check whether the server sent a FOUND message.
        // if it did, check whether it should exit or not
        try
            {
            // read a line. if it is successful, it means that the server sent a FOUND message
            // (this is the only message the server sends right now), and it should set the flag
            // for exiting next time when in this procedure
<span class="nc" id="L1013">            String ww = fromServer.readUTF();</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if( alreadyReadGoodBye ) // FOUND message sent from the server</span>
                {
                // we should exit because some other individual has
                // found the perfect fit individual
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                if( state.quitOnRunComplete )</span>
                    {
<span class="nc" id="L1020">                    message = &quot;Exit: Another island found the perfect individual.&quot;;</span>
                    //state.output.message( &quot;Another island found the perfect individual. Exiting....&quot; );
<span class="nc" id="L1022">                    toServer.writeUTF( OKAY );</span>
<span class="nc" id="L1023">                    toServer.flush();</span>
                    }
                else
                    {
<span class="nc" id="L1027">                    state.output.message( &quot;Another island found the perfect individual.&quot; );</span>
                    }
                }
            else // ( ww == null ) // the connection with the server was closed
                {
                // we should exit, because we cannot communicate with the
                // server anyway
<span class="nc" id="L1034">                message = &quot;Exit: Could not communicate with the server.&quot;;</span>
                //state.output.warning( &quot;Could not communicate with the server. Exiting....&quot; );
                }
            }
<span class="nc" id="L1038">        catch( InterruptedIOException e )</span>
            {
            // here don't do anything: it reaches this point when the server is on, but nobody found
            // the perfect individual. in this case, it should just return null, so that the
            // execution continues
            }
<span class="nc" id="L1044">        catch( IOException e )</span>
            {
            // some weird error
            // report it in a warning
<span class="nc" id="L1048">            state.output.warning( &quot;Some weird IO exception reported by the system in the IslandExchange::runComplete function.  Is it possible that the server has crashed?&quot; );</span>
<span class="nc" id="L1049">            }</span>

<span class="nc" id="L1051">        return null;</span>
        }

    /** Closes contacts with other processes, if that's what you're doing.  Called at the end of an evolutionary run. result is either ec.EvolutionState.R_SUCCESS or ec.EvolutionState.R_FAILURE, indicating whether or not an ideal individual was found. */
    public void closeContacts(EvolutionState state, int result)
        {
        // if the run was successful (perfect individual was found)
        // then send a message to the server that it was found
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        if( result == EvolutionState.R_SUCCESS )</span>
            {
            try
                {
<span class="nc" id="L1063">                toServer.writeUTF( FOUND );</span>
<span class="nc" id="L1064">                toServer.flush();</span>
                }
<span class="nc" id="L1066">            catch( IOException e ) {}</span>
            }

        // close socket to server
        try
            {
<span class="nc" id="L1072">            serverSocket.close();</span>
            }
<span class="nc" id="L1074">        catch( IOException e )</span>
            {
<span class="nc" id="L1076">            }</span>

<span class="nc" id="L1078">        state.output.message( &quot;Shutting down the mailbox&quot; );</span>
        // close the mailbox and wait for the thread to terminate
<span class="nc" id="L1080">        mailbox.shutDown();</span>
<span class="nc" id="L1081">        mailboxThread.interrupt();</span>
        try
            {
<span class="nc" id="L1084">            mailboxThread.join();</span>
            }
<span class="nc" id="L1086">        catch( InterruptedException e )</span>
            {
<span class="nc" id="L1088">            }</span>
<span class="nc" id="L1089">        state.output.message( &quot;Mailbox shut down&quot; );</span>

        // close out-going sockets
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for( int x = 0 ; x &lt; number_of_destination_islands ; x++ )</span>
            {
            // catch each exception apart (don't take into consideration the running variables)
            try
                {
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if( running[x] )</span>
<span class="nc" id="L1098">                    outSockets[x].close();</span>
                }
<span class="nc" id="L1100">            catch( IOException e )</span>
                {
<span class="nc" id="L1102">                }</span>
            }

        // if the island also hosts the server, wait till it terminates
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if( iAmServer )</span>
            {
<span class="nc" id="L1108">            state.output.message( &quot;Shutting down the server&quot; );</span>
            try
                {
<span class="nc" id="L1111">                serverThread.join();</span>
                }
<span class="nc" id="L1113">            catch( InterruptedException e )</span>
                {
<span class="nc" id="L1115">                }</span>
<span class="nc" id="L1116">            state.output.message( &quot;Server shut down&quot; );</span>
            }

<span class="nc" id="L1119">        }</span>

    /* (non-Javadoc)
     * @see ec.EvolutionState#finish(int)
     */
    public void finish(int result) {
<span class="nc" id="L1125">        }</span>

    /* (non-Javadoc)
     * @see ec.EvolutionState#startFromCheckpoint()
     */
    public void startFromCheckpoint() {
<span class="nc" id="L1131">        }</span>

    /* (non-Javadoc)
     * @see ec.EvolutionState#startFresh()
     */
    public void startFresh() {
<span class="nc" id="L1137">        }</span>

    /* (non-Javadoc)
     * @see ec.EvolutionState#evolve()
     */
    public int evolve()
        throws InternalError {
<span class="nc" id="L1144">        return 0;</span>
        }
        
    }

/** Class that contains all the mailbox functionality. It is supposed to wait on a new thread for incoming
    immigrants from other islands (it will receive in the constructor the number of islands that will send
    messages to the current island). Waiting on sockets is non-blocking, such that the order in which the
    islands send messages is unimportant. When immigrants are received, they are stored in a special buffer
    called immigrants. The storage is managed in a queue-like fashion, such that when the storage is full,
    the first immigrants that came are erased (hopefully the storage will be emptied fast enough such that
    this case doesn't appear too often).
    All accesses to the &quot;immigrants&quot; variable (also applies to nImmigrants) should be done only in the presence
    of synchronization, because there might be other threads using them too. The number of immigrants for each
    of the subpopulations (nImmigrants[x]) is between 0 and the size of the queue structure (received as a
    parameter in the constructor). */
class IslandExchangeMailbox implements Runnable
    {

    /** How much to wait before starting checking for immigrants */
    public static final int SLEEP_BETWEEN_CHECKING_FOR_IMMIGRANTS = 1000;

    /** How much to wait on a socket for a message, before starting to wait on another socket */
    public static final int CHECK_TIMEOUT = 1000;

    /** How much to wait while synchronizing */
    public static final int SYNCHRONIZATION_SLEEP = 100;

    /**  storage for the incoming immigrants: 2 sizes: the subpopulation and the index of the immigrant */
    public Individual[][] immigrants;

    /** the number of immigrants in the storage for each of the subpopulations */
    public int[] nImmigrants;

    // auxiliary variables to manage the queue storages
    int[] nextIndexPosition;

    // the socket where it listens for incomming messages
    ServerSocket serverSocket;

    // the number of islands that send messages to the current mailbox
    int n_incoming;

    // whether the information on sockets is compressed or not (receives this information in the constructor)
    boolean compressedCommunication;

    // the sockets and readers for receiving incoming messages
    Socket[] inSockets;
    DataInputStream[] dataInput;
    public String[] incomingIds;      // so we can print out nice names for our incoming connections

    // the state of the islands it is communicating to
    boolean[] running;

    // the state (to display messages mainly)
    EvolutionState state;

    // synchronization variable
<span class="nc" id="L1202">    boolean[] syncVar = new boolean[1];</span>

    // My ID
    String myId;
    
    boolean chatty;

    /**
       Public constructor used to initialize most of the parameters of the mailbox:
       state_p : the EvolutionState, used mainly for displaying messages
       port : the port used to listen for incoming messages
       n_incoming_p : the number of islands that will send messages to the current island
       how_many : how many immigrants to manage in the queue-like storage for each of the subpopulations
    */
    public IslandExchangeMailbox( final EvolutionState state_p, int port, int n_incoming_p, int how_many, String _myId, boolean chatty, boolean _compressedCommunication )
<span class="nc" id="L1217">        {</span>
<span class="nc" id="L1218">        myId = _myId;</span>
<span class="nc" id="L1219">        compressedCommunication = _compressedCommunication;</span>
        
<span class="nc" id="L1221">        this.chatty = chatty;</span>
    
        // initialize public variables from the parameters of the constructor
<span class="nc" id="L1224">        state = state_p;</span>
<span class="nc" id="L1225">        n_incoming = n_incoming_p;</span>

<span class="nc" id="L1227">        Parameter p_numsubpops = new Parameter( ec.Initializer.P_POP ).push( ec.Population.P_SIZE );</span>
<span class="nc" id="L1228">        int numsubpops = state.parameters.getInt(p_numsubpops,null,1);</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if ( numsubpops == 0 )</span>
            {
            // later on, Population will complain with this fatally, so don't
            // exit here, just deal with it and assume that you'll soon be shut
            // down
            }

        // allocate the storages:
        // - immigrants = storage for the immigrants that will come to the current island
        //   - first dimension: the number of subpopulations
        //   - second dimension: how many immigrants to store for each of the subpopulations.
        // - nextIndexPosition = where to insert next in the queue structure &quot;immigrants&quot;
        // - nImmigrants = how many immigrants there are in the storage &quot;immigrants&quot; for each of the subpopulations
<span class="nc" id="L1242">        immigrants = new Individual[ numsubpops ][ how_many ];</span>
<span class="nc" id="L1243">        nextIndexPosition = new int[ numsubpops ];</span>
<span class="nc" id="L1244">        nImmigrants = new int[ numsubpops ];</span>

        // set the synchronization variable to false (it will be set to true to signal exiting the waiting loop)
<span class="nc" id="L1247">        syncVar[0] = false;</span>

        // create the ServerSocket to listen to incoming messages
        try
            {
<span class="nc" id="L1252">            serverSocket = new ServerSocket( port, n_incoming );</span>
            }
<span class="nc" id="L1254">        catch( IOException e )</span>
            {
<span class="nc" id="L1256">            state.output.fatal( &quot;Could not start mailbox for incoming messages.  Perhaps the port (&quot; + port + &quot;) is bad?\n...or someone else already has it?&quot;);</span>
<span class="nc" id="L1257">            }</span>

        // allocate the sockets and the readers (will be used in the near future)
<span class="nc" id="L1260">        inSockets = new Socket[ n_incoming ];</span>
<span class="nc" id="L1261">        dataInput = new DataInputStream[ n_incoming ];</span>
<span class="nc" id="L1262">        incomingIds = new String[ n_incoming ];</span>

        // allocate the status of the different readers
<span class="nc" id="L1265">        running = new boolean[ n_incoming ];</span>

<span class="nc" id="L1267">        }</span>

    /** The main functionality of the mailbox: waiting for incoming messages and dealing with the incoming immigrants */
    public void run()
        {

        // wait for the &quot;n_incoming&quot; incoming connections from different islands, and initialize
        // the sockets and the readers to communicate with (receive messages from) them. All the
        // sockets are set to be non-blocking, such that they can be checked alternatively without
        // waiting for messages on a particular one.
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        for( int x = 0 ; x &lt; n_incoming ; x++ )</span>
            {
            try
                {
<span class="nc" id="L1281">                inSockets[x] = serverSocket.accept();</span>

                DataOutputStream dataOutput;

<span class="nc bnc" id="L1285" title="All 2 branches missed.">                if( compressedCommunication )</span>
                    {
                    /*
                      dataInput[x] = new DataInputStream(new CompressingInputStream(inSockets[x].getInputStream()));
                      dataOutput = new DataOutputStream(new CompressingOutputStream(inSockets[x].getOutputStream()));
                    */
<span class="nc" id="L1291">                    OutputStream compressedo = Output.makeCompressingOutputStream(inSockets[x].getOutputStream());</span>
<span class="nc" id="L1292">                    InputStream compressedi = Output.makeCompressingInputStream(inSockets[x].getInputStream());</span>
<span class="nc bnc" id="L1293" title="All 4 branches missed.">                    if (compressedi == null || compressedo == null) </span>
<span class="nc" id="L1294">                        state.output.fatal( &quot;You do not appear to have JZLib installed on your system, and so may must have compression turned off for IslandExchange.  &quot;+ </span>
                            &quot;To get JZLib, download from the ECJ website or from http://www.jcraft.com/jzlib/&quot;);

<span class="nc" id="L1297">                    dataInput[x] = new DataInputStream(compressedi);</span>
<span class="nc" id="L1298">                    dataOutput = new DataOutputStream(compressedo);</span>
<span class="nc" id="L1299">                    }</span>
                else
                    {
<span class="nc" id="L1302">                    dataInput[x] = new DataInputStream(inSockets[x].getInputStream());</span>
<span class="nc" id="L1303">                    dataOutput = new DataOutputStream(inSockets[x].getOutputStream());</span>
                    }

                // send my id, then read an id
<span class="nc" id="L1307">                dataOutput.writeUTF(myId);</span>
<span class="nc" id="L1308">                dataOutput.flush();</span>
<span class="nc" id="L1309">                incomingIds[x] = dataInput[x].readUTF().trim();    </span>

<span class="nc" id="L1311">                state.output.message( &quot;Island &quot; + incomingIds[x] + &quot; connected to my mailbox&quot; );</span>

                // set the socket to non-blocking
<span class="nc" id="L1314">                inSockets[x].setSoTimeout( CHECK_TIMEOUT );</span>
<span class="nc" id="L1315">                running[x] = true;</span>
                }
<span class="nc" id="L1317">            catch (IOException e)</span>
                {
<span class="nc" id="L1319">                running[x] = false;</span>
<span class="nc" id="L1320">                state.output.fatal( &quot;An exception was generated while creating communication structures for island &quot; + x + &quot;.  Here it is: &quot; + e );</span>
<span class="nc" id="L1321">                }</span>
            }

<span class="nc" id="L1324">        state.output.message( &quot;All islands have connected to my client.&quot; );</span>

        // variable used for deciding (based on the synchronized variable &quot;syncVar&quot;) when to exit
<span class="nc" id="L1327">        boolean shouldExit = false;</span>

        // enter the main loop
        do
            {

            // wait some (do not check all the time, cause it would be a waste of time and computational resources)
            try
                {
<span class="nc" id="L1336">                Thread.sleep( SLEEP_BETWEEN_CHECKING_FOR_IMMIGRANTS );</span>
                }
<span class="nc" id="L1338">            catch( InterruptedException e )</span>
                {
<span class="nc" id="L1340">                }</span>

            // for each of the connections established with the islands
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            for( int x = 0 ; x &lt; n_incoming ; x++ )</span>
                {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">                if( running[x] )</span>
                    {
                    try
                        {
                        // enter an infinite loop to receive all the messages form the &quot;x&quot;s island
                        // it will exit the loop as soon as there are no more messages coming from
                        // the &quot;x&quot;s island (non-blocking socket)
                        while( true )
                            {
                            // read the subpopulation where the immigrants need to be inserted. In case there
                            // is no incoming message, an exception will be generated and the infinite loop
                            // will be exited (the mailbox will search the next socket (communication link)
                            // for incoming messages
<span class="nc" id="L1358">                            int subpop = dataInput[x].readInt();</span>
                            
                            // if it gets to this point, it means that a number of individuals will be sent
                            // it is the time to set up the receiving storages
                            
                            // set the socket to blocking for reading the individuals
                            try
                                {
<span class="nc" id="L1366">                                inSockets[x].setSoTimeout( 0 );</span>
                                }
<span class="nc" id="L1368">                            catch( SocketException e )</span>
                                {
<span class="nc" id="L1370">                                state.output.warning( &quot;Could not set the socket to blocking while receiving individuals in the mailbox.&quot; );</span>
<span class="nc" id="L1371">                                }</span>
                            
                            // how many individuals will be received in the current dialogue?
<span class="nc" id="L1374">                            int how_many_to_come = dataInput[x].readInt();</span>
                            
<span class="nc bnc" id="L1376" title="All 2 branches missed.">                            if (chatty) state.output.message( &quot;Receiving &quot; + how_many_to_come + &quot; immigrants for subpopulation &quot;  + subpop + &quot; from island &quot; + incomingIds[x]);</span>

                            // synchronize on the immigrants (such that other threads cannot access it during its
                            // being modified)
<span class="nc" id="L1380">                            synchronized( immigrants )</span>
                                {
                                
                                // in case the immigrants buffer was emptied, the nextIndexPosition is not reset (it is not public)
                                // so we have to reset it now
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                                if( nImmigrants[subpop] == 0 ) // if it was reset</span>
<span class="nc" id="L1386">                                    nextIndexPosition[subpop] = 0; // reset the nextIndexPosition[x]</span>
                                
                                // loop in order to receive all the incoming individuals in the current dialogue
<span class="nc bnc" id="L1389" title="All 2 branches missed.">                                for( int ind = 0 ; ind &lt; how_many_to_come ; ind++ )</span>
                                    {
                                    // read the individual
                                    try
                                        {
                                        // read the immigrant in the storage
<span class="nc" id="L1395">                                        immigrants[subpop][nextIndexPosition[subpop]] = state.population.subpops.get(subpop).species.newIndividual( state, dataInput[x] );</span>

                                        //state.output.message( &quot;Individual received.&quot; );
                                        
                                        // increase the queue index
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                                        if( nextIndexPosition[subpop] == immigrants[subpop].length - 1 )</span>
<span class="nc" id="L1401">                                            nextIndexPosition[subpop] = 0;</span>
                                        else
<span class="nc" id="L1403">                                            nextIndexPosition[subpop]++;</span>
                                        
                                        // can increment it without synchronization, as we do synchronization on the immigrants
<span class="nc bnc" id="L1406" title="All 2 branches missed.">                                        if( nImmigrants[subpop] &lt; immigrants[subpop].length )</span>
<span class="nc" id="L1407">                                            nImmigrants[subpop]++;</span>

                                        }
<span class="nc" id="L1410">                                    catch( IOException e )</span>
                                        {
                                        // i hope it will also never happen :)
<span class="nc" id="L1413">                                        state.output.message( &quot;IO exception while communicating with an island&quot; );</span>
<span class="nc" id="L1414">                                        running[x] = false;</span>
<span class="nc" id="L1415">                                        continue;</span>
                                        }
<span class="nc" id="L1417">                                    catch( NumberFormatException e )</span>
                                        {
                                        // it happens when the socket is closed and cannot be doing any reading
<span class="nc" id="L1420">                                        state.output.message( &quot;IO exception while communicating with an island&quot; );</span>
<span class="nc" id="L1421">                                        running[x] = false;</span>
<span class="nc" id="L1422">                                        continue;</span>
<span class="nc" id="L1423">                                        }</span>
                                    }
<span class="nc" id="L1425">                                } // end synchronized block on &quot;immigrants&quot;</span>
                            
                            // set the socket to non-blocking (after current set of immigrants is over)
                            try
                                {
<span class="nc" id="L1430">                                inSockets[x].setSoTimeout( CHECK_TIMEOUT );</span>
                                }
<span class="nc" id="L1432">                            catch( SocketException e )</span>
                                {
<span class="nc" id="L1434">                                state.output.warning( &quot;Could not set the socket to non-blocking while receiving individuals in the mailbox.&quot; );</span>
<span class="nc" id="L1435">                                }</span>
<span class="nc" id="L1436">                            }</span>
                        }
<span class="nc" id="L1438">                    catch( InterruptedIOException e )</span>
                        {
                        // here everything is ok
                        // just that there were no messages
                        }
<span class="nc" id="L1443">                    catch( IOException e )</span>
                        {
                        // now this is not nice
                        // report the error so that the programmer can fix it (hopefully)
<span class="nc" id="L1447">                        state.output.message( &quot;IO exception while communicating with an island&quot; );</span>
<span class="nc" id="L1448">                        running[x] = false;</span>
                        }
<span class="nc" id="L1450">                    catch( NumberFormatException e )</span>
                        {
                        // error received when some sockets break
<span class="nc" id="L1453">                        state.output.message( &quot;Socket closed&quot; );</span>
<span class="nc" id="L1454">                        running[x] = false;</span>
<span class="nc" id="L1455">                        }</span>
                    }
                }

            // again with synchronization, try to access the syncVar to check whether the mailbox needs to finish
            // running (maybe some other island already found the perfect individual, or the resources of the current
            // run have been wasted)
<span class="nc" id="L1462">            synchronized( syncVar )</span>
                {
                // get the value of the syncVar. If it is true, we should exit.
<span class="nc" id="L1465">                shouldExit = syncVar[0];</span>
<span class="nc" id="L1466">                }</span>
            }
<span class="nc bnc" id="L1468" title="All 2 branches missed.">        while( !shouldExit );</span>

        // close the sockets (don't care about the running, but deal with exceptions)
        try
            {
            // close the ServerSocket
<span class="nc" id="L1474">            serverSocket.close();</span>
            }
<span class="nc" id="L1476">        catch( IOException e )</span>
            {
<span class="nc" id="L1478">            }</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        for( int x = 0 ; x &lt; n_incoming ; x++ )</span>
            {
            try
                {
                // close the sockets to communicate (receive messages) with the other islands
<span class="nc" id="L1484">                inSockets[x].close();</span>
                }
<span class="nc" id="L1486">            catch( IOException e )</span>
                {
<span class="nc" id="L1488">                continue;</span>
<span class="nc" id="L1489">                }</span>
            }

<span class="nc" id="L1492">        }</span>

    /**
       Method used to shutdown the mailbox. What it does is that it closes all communication links (sockets)
       and sets the syncVar to true (such that if the run() method is run on another thread, it will exit the
       loop and terminate.
    */
    public void shutDown()
        {

        // set the syncVar to true (such that if another thread executes this.run(), it will exit the main loop
        // (hopefully, the information from the server was correct
<span class="nc" id="L1504">        synchronized( syncVar )</span>
            {
<span class="nc" id="L1506">            syncVar[0] = true;</span>
<span class="nc" id="L1507">            }</span>

<span class="nc" id="L1509">        }</span>

    /**
       Return the port of the ServerSocket (where the islands where the other islands should
       connect in order to send their immigrants).
    */
    public int getPort()
        {
        // return the port of the ServerSocket
<span class="nc" id="L1518">        return serverSocket.getLocalPort();</span>
        }

    }

/**
   The IslandExchangeServer is the class that manages the main server that coordinates all the islands. The class
   implements Runnable (for running on a different thread).
*/
<span class="nc" id="L1527">class IslandExchangeServer implements Runnable</span>
    {
    
    /*

      The server-specific parameters look roughly like this:

      exch.server-port = 8021
      exch.num-islands = 3
      exch.island.0.id = SurvivorIsland
      exch.island.0.num-mig = 1
      exch.island.0.mig.0 = GilligansIsland
      exch.island.0.size = 5
      exch.island.0.mod = 2
      exch.island.0.start = 4
      exch.island.1.id = GilligansIsland
      exch.island.1.mod = 1
      exch.island.1.start = 2
      exch.island.1.size = 10
      exch.island.1.num-mig = 2
      exch.island.1.mig.0 = SurvivorIsland
      exch.island.1.mig.1 = GilligansIsland
      exch.island.2.id = BermudaIsland
      exch.island.2.mod = 2
      ...
    */

    //// Server information

    /** The server port */
    public static final String P_SERVER_PORT = &quot;server-port&quot;;

    /** The number of islands */
    public static final String P_NUM_ISLANDS = &quot;num-islands&quot;;

    /** The parameter for the island's information */
    public static final String P_ISLAND = &quot;island&quot;;

    /** The id */
    public static final String P_ID = &quot;id&quot;;

    // The number of islands that will send immigrants to the current island
    public static final String P_NUM_INCOMING_MIGRATING_COUNTRIES = &quot;num-incoming-mig&quot;;

    /** The number of islands where immigrants will be sent */
    public static final String P_NUM_MIGRATING_COUNTRIES = &quot;num-mig&quot;;

    /** the parameter for migrating islands' ids */
    public static final String P_MIGRATING_ISLAND = &quot;mig&quot;;

    /** The size of the mailbox (for each of the subpopulations) */
    public static final String P_MAILBOX_CAPACITY = &quot;mailbox-capacity&quot;;

    /** The parameter for the modulo (how many generations should pass between consecutive sendings of individuals */
    public static final String P_MODULO = &quot;mod&quot;;

    /** The number of immigrants to be sent */
    public static final String P_SIZE = &quot;size&quot;;

    /** How many generations to pass at the beginning of the evolution before the first emigration from the current island */
    public static final String P_OFFSET = &quot;start&quot;;

    /** Whether the execution should be synchronous or asynchronous */
    public static final String P_SYNCHRONOUS = &quot;sync&quot;;

    /** The run message to be sent to the clients */
    public static final String RUN = &quot;run&quot;;

    /** How much to wait for the found message (on a non-blocking socket) */
    public static final int FOUND_TIMEOUT = 100;

    /** How much to sleep between checking for a FOUND message */
    public static final int SLEEP_TIME = 100;

    /** The final message to be sent to all islands when an individual has been found */
    public static final String GOODBYE = &quot;bye-bye&quot;;

    /** The found message */
    public static final String FOUND = IslandExchange.FOUND;

    /** The okay message */
    public static final String OKAY = IslandExchange.OKAY;

    /** The synchronize message */
    public static final String SYNC = IslandExchange.SYNC;

    /** A class indicating all the information the server knows about
        a given island, including its mod, size, offset, and all the
        migrating islands it hooks to, etc. */
<span class="nc" id="L1616">    public static class IslandExchangeIslandInfo</span>
        {
        /** how often to send individuals */
        public int modulo;
        /** the mailbox capacity (for each of the subpopulations) */
        public int mailbox_capacity;
        /** what generation to start sending individuals */
        public int offset;
        // how many individuals to send
        public int size;
        // to how many islands to send individuals
        public int num_mig;
        // the ids of the contries to send individuals to
        public String[] migrating_island_ids;
        // how many islands will send individuals to the mailbox
        public int num_incoming;

        // also later filled in:
        // the address of the mailbox where to receive information
        public String address;
        // the port of the mailbox
        public int port;
        }

    // The number of islands in the topology
    int numIslands;

    // The port of the server
    int serverPort;

    // the server's socket
    ServerSocket serverSocket;

    // Hashtable for faster lookup of information regarding islands
    Hashtable info;

    // Hashtable to count how many islands send individuals to each of the islands
    Hashtable info_immigrants;

    EvolutionState state;

    // Index of island ids sorted by parameter file
    String[] island_ids;
    
    // Index of island ids sorted by order of connection
    String[] connected_island_ids;


    // variables used if the execution is synchronous
    // int global_modulo, global_offset;
    boolean synchronous;

    // how many individuals asked to be synchronized (when it reaches the total number of
    // running clients, the server resets this variable and allows everybody to continue running)
    boolean[] who_is_synchronized;

    /** This setup should get called from the IslandExchange setup method. */
    public void setupServerFromDatabase(final EvolutionState state_p, final Parameter base)
        {
        // Store the evolution state for further use in other functions ( ie. run )
<span class="nc" id="L1676">        state = state_p;</span>

        // Don't bother with getting the default base -- we're a singleton!
        Parameter p;

        // get the number of islands
<span class="nc" id="L1682">        p = base.push( P_NUM_ISLANDS );</span>
<span class="nc" id="L1683">        numIslands = state.parameters.getInt( p, null, 1 );</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">        if( numIslands == 0 )</span>
<span class="nc" id="L1685">            state.output.fatal( &quot;The number of islands must be &gt;0.&quot;, p );</span>

        // get the port of the server
<span class="nc" id="L1688">        p = base.push( P_SERVER_PORT );</span>
<span class="nc" id="L1689">        serverPort = state.parameters.getInt( p, null, 1 );</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">        if( serverPort == 0 )</span>
<span class="nc" id="L1691">            state.output.fatal( &quot;The server port must be &gt;0.&quot;, p );</span>
        
        // information on the islands = hashtable of ID and socket information
<span class="nc" id="L1694">        info = new Hashtable( numIslands );</span>

        // initialize the hash table to count how many islands send individuals
        // to each of the islands
<span class="nc" id="L1698">        info_immigrants = new Hashtable( numIslands );</span>

        // allocate the ids sorted by parameter file
<span class="nc" id="L1701">        island_ids = new String[ numIslands ];</span>
        
        // allocate the ids sorted by connection
<span class="nc" id="L1704">        connected_island_ids = new String[ numIslands ] ;</span>

        // check whether the execution is synchronous or asynchronous
        // if it is synchronous, there should be two parameters in the parameters file:
        // the global modulo and offset (such that the islands coordinate smoothly)
<span class="nc" id="L1709">        p = base.push( P_SYNCHRONOUS );</span>

        // get the value of the synchronous parameter (default is false)
<span class="nc" id="L1712">        synchronous = state.parameters.getBoolean( p, null, false );</span>

        // if synchronous, read the other two global parameters
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        if( synchronous )</span>
            {
<span class="nc" id="L1717">            state.output.message( &quot;The communication will be synchronous.&quot; );</span>

            /*
            // get the global modulo
            p = base.push( P_MODULO );
            global_modulo = state.parameters.getInt( p, null, 1 );
            if( global_modulo == 0 )
            state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p );
            
            // get the global offset
            p = base.push( P_OFFSET );
            global_offset = state.parameters.getInt( p, null, 0 );
            if( global_offset == -1 )
            state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p );
            */
            }
        else
            {

<span class="nc" id="L1736">            state.output.message( &quot;The communication will be asynchronous.&quot; );</span>

            }

        // get a new local base
<span class="nc" id="L1741">        Parameter islandBase = base.push( P_ISLAND );</span>

        // load the island topology
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
            {

<span class="nc" id="L1747">            IslandExchangeIslandInfo ieii = new IslandExchangeIslandInfo();</span>

<span class="nc" id="L1749">            Parameter localBase = islandBase.push( &quot;&quot; + x );</span>

            // get the id of the current island
<span class="nc" id="L1752">            p = localBase.push( P_ID );</span>
<span class="nc" id="L1753">            island_ids[x] = state.parameters.getStringWithDefault( p, null, &quot;&quot; );</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            if( island_ids[x].equals(&quot;&quot;) )</span>
<span class="nc" id="L1755">                state.output.fatal( &quot;Parameter not found.&quot;, p );</span>

            // get the mailbox capacity of the imigration from the current island
<span class="nc" id="L1758">            p = localBase.push( P_MAILBOX_CAPACITY );</span>
<span class="nc" id="L1759">            ieii.mailbox_capacity = state.parameters.getInt( p, base.push(P_MAILBOX_CAPACITY), 0 );</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            if( ieii.mailbox_capacity == -1 )</span>
<span class="nc" id="L1761">                state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p, base.push(P_MAILBOX_CAPACITY) );</span>

            // get the size of the imigration from the current island
<span class="nc" id="L1764">            p = localBase.push( P_SIZE );</span>
<span class="nc" id="L1765">            ieii.size = state.parameters.getInt( p, base.push(P_SIZE), 0 );</span>
<span class="nc bnc" id="L1766" title="All 2 branches missed.">            if( ieii.size == -1 )</span>
<span class="nc" id="L1767">                state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p, base.push(P_SIZE) );</span>

            // if synchronous execution, use the global modulo and offset
            /* if( synchronous )
               {
               ieii.modulo = global_modulo;
               ieii.offset = global_offset;
               }
               else
               {*/
            // get the modulo of the imigration from the current island
<span class="nc" id="L1778">            p = localBase.push( P_MODULO );</span>
<span class="nc" id="L1779">            ieii.modulo = state.parameters.getInt( p, base.push(P_MODULO), 1 );</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">            if( ieii.modulo == 0 )</span>
<span class="nc" id="L1781">                state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p , base.push(P_MODULO));</span>

            // get the offset of the imigration from the current island
<span class="nc" id="L1784">            p = localBase.push( P_OFFSET );</span>
<span class="nc" id="L1785">            ieii.offset = state.parameters.getInt( p, base.push(P_OFFSET), 0 );</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">            if( ieii.offset == -1 )</span>
<span class="nc" id="L1787">                state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p, base.push(P_OFFSET) );</span>
            /*     } */

            // mark as uninitialized
<span class="nc" id="L1791">            ieii.port = -1;</span>

            // insert the id in the hashset with the ids of the islands
<span class="nc" id="L1794">            info.put( island_ids[x], ieii );</span>
            }

        // get the information on destination islands (with checking for consistency)
<span class="nc bnc" id="L1798" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
            {

<span class="nc" id="L1801">            IslandExchangeIslandInfo ieii = (IslandExchangeIslandInfo)info.get( island_ids[x] );</span>

<span class="nc bnc" id="L1803" title="All 2 branches missed.">            if( ieii == null )</span>
                {
<span class="nc" id="L1805">                state.output.error( &quot;Inexistent information for island &quot; + island_ids[x] + &quot; stored in the server's information database.&quot; );</span>
<span class="nc" id="L1806">                continue;</span>
                }

<span class="nc" id="L1809">            Parameter localBase = islandBase.push( &quot;&quot; + x );</span>

            // get the number of islands where individuals should be sent
<span class="nc" id="L1812">            p = localBase.push( P_NUM_MIGRATING_COUNTRIES );</span>
<span class="nc" id="L1813">            ieii.num_mig = state.parameters.getInt( p, null, 0 );</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if( ieii.num_mig == -1 )</span>
<span class="nc" id="L1815">                state.output.fatal( &quot;Parameter not found, or it has an incorrect value.&quot;, p );</span>

            // if there is at least 1 destination islands
<span class="nc bnc" id="L1818" title="All 2 branches missed.">            if( ieii.num_mig &gt; 0 )</span>
                {

                // allocate the storage for ids
<span class="nc" id="L1822">                ieii.migrating_island_ids = new String[ ieii.num_mig ];</span>

                // store a new base parameter
                Parameter ll;
<span class="nc" id="L1826">                ll = localBase.push( P_MIGRATING_ISLAND );</span>

                // for each of the islands
<span class="nc bnc" id="L1829" title="All 2 branches missed.">                for( int y = 0 ; y &lt; ieii.num_mig ; y++ )</span>
                    {

                    // read the id &amp; check for errors
<span class="nc" id="L1833">                    ieii.migrating_island_ids[y] = state.parameters.getStringWithDefault( ll.push(&quot;&quot;+y), null, null );</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">                    if( ieii.migrating_island_ids[y] == null )</span>
<span class="nc" id="L1835">                        state.output.fatal( &quot;Parameter not found.&quot;, ll.push(&quot;&quot;+y) );</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">                    else if( !info.containsKey( ieii.migrating_island_ids[y] ) )</span>
<span class="nc" id="L1837">                        state.output.fatal( &quot;Unknown island.&quot;, ll.push(&quot;&quot;+y) );</span>
                    else
                        {
                        // insert this knowledge into the hashtable for counting how many islands
                        // send individuals to each island
<span class="nc" id="L1842">                        Integer integer = (Integer)info_immigrants.get( ieii.migrating_island_ids[y] );</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">                        if( integer == null )</span>
<span class="nc" id="L1844">                            info_immigrants.put( ieii.migrating_island_ids[y],</span>
<span class="nc" id="L1845">                                Integer.valueOf(1));</span>
                        else
<span class="nc" id="L1847">                            info_immigrants.put( ieii.migrating_island_ids[y],</span>
<span class="nc" id="L1848">                                Integer.valueOf( integer.intValue() + 1 ) );</span>
                        }
                    }
                }

            // save the information back in the hash table
            // info.put( island_ids[x], ieii );                         // unneccessary -- Sean

            }

<span class="nc bnc" id="L1858" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
            {

<span class="nc" id="L1861">            IslandExchangeIslandInfo ieii = (IslandExchangeIslandInfo)info.get( island_ids[x] );</span>

<span class="nc bnc" id="L1863" title="All 2 branches missed.">            if( ieii == null )</span>
                {
<span class="nc" id="L1865">                state.output.fatal( &quot;Inexistent information for island &quot; + island_ids[x] + &quot; stored in the server's information database.&quot; );</span>
                }

<span class="nc" id="L1868">            Integer integer = (Integer)info_immigrants.get( island_ids[x] );</span>

            // if the information does not exist in the hasthable,
            // it means no islands send individuals there
<span class="nc bnc" id="L1872" title="All 2 branches missed.">            if( integer == null )</span>
<span class="nc" id="L1873">                ieii.num_incoming = 0;</span>
            else
<span class="nc" id="L1875">                ieii.num_incoming = integer.intValue();</span>

            // save the information back in the hash table
            // info.put( island_ids[x], ieii );                 // unneccessary -- Sean

            }

        // allocate and reset this variable to false
<span class="nc" id="L1883">        who_is_synchronized = new boolean[ numIslands ];</span>

<span class="nc bnc" id="L1885" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
<span class="nc" id="L1886">            who_is_synchronized[x] = false;</span>

<span class="nc" id="L1888">        }</span>

    /** The main function running in the thread */
    public void run()
        {

        // sockets to communicate to each of the islands
<span class="nc" id="L1895">        Socket[] con = new Socket[numIslands];</span>

        // readers and writters for communication with each island
<span class="nc" id="L1898">        DataInputStream[] dataIn = new DataInputStream[numIslands];</span>
<span class="nc" id="L1899">        DataOutputStream[] dataOut = new DataOutputStream[numIslands];</span>



        // whether each client is working (and communicating with the server) or not
<span class="nc" id="L1904">        boolean[] clientRunning = new boolean[numIslands];</span>

        // initialize the running status of all clients
<span class="nc bnc" id="L1907" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
<span class="nc" id="L1908">            clientRunning[x] = true;</span>

        try
            {
            // create a server
<span class="nc" id="L1913">            serverSocket = new ServerSocket(serverPort,numIslands);</span>
            }
<span class="nc" id="L1915">        catch ( IOException e )</span>
            {
<span class="nc" id="L1917">            state.output.fatal( &quot;Error creating a socket on port &quot; + serverPort );</span>
<span class="nc" id="L1918">            }</span>

        // for each of the islands
<span class="nc bnc" id="L1921" title="All 2 branches missed.">        for(int x=0;x&lt;numIslands;x++)</span>
            {
            try
                {
                // set up connection with the island
<span class="nc" id="L1926">                con[x] = serverSocket.accept();</span>

                // initialize the reader and the writer
<span class="nc" id="L1929">                dataIn[x] = new DataInputStream(con[x].getInputStream());</span>
<span class="nc" id="L1930">                dataOut[x] = new DataOutputStream(con[x].getOutputStream());</span>

                // read the id
<span class="nc" id="L1933">                connected_island_ids[x] = dataIn[x].readUTF().trim();</span>

<span class="nc" id="L1935">                state.output.message( &quot;Island &quot; + connected_island_ids[x] + &quot; logged in&quot; );</span>

                // check whether the id appears in the information at the server
<span class="nc bnc" id="L1938" title="All 2 branches missed.">                if( !info.containsKey( connected_island_ids[x] ) )</span>
                    {
<span class="nc" id="L1940">                    state.output.error( &quot;Incorrect ID (&quot; + connected_island_ids[x] + &quot;)&quot; );</span>
<span class="nc" id="L1941">                    clientRunning[x] = false;</span>
<span class="nc" id="L1942">                    continue;</span>
                    }

<span class="nc" id="L1945">                IslandExchangeIslandInfo ieii = (IslandExchangeIslandInfo)info.get( connected_island_ids[x] );</span>

                // redundant check, i know....
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                if( ieii == null )</span>
                    {
<span class="nc" id="L1950">                    state.output.error( &quot;Can't get IslandExchangeInfo for &quot; + connected_island_ids[x]  );</span>
<span class="nc" id="L1951">                    clientRunning[x] = false;</span>
<span class="nc" id="L1952">                    continue;</span>
                    }

                // check whether an island with this id already registered with the server
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                if( ieii.port &gt;= 0 )</span>
                    {
<span class="nc" id="L1958">                    state.output.error( &quot;Multiple islands are claiming the same ID (&quot; + connected_island_ids[x] + &quot;)&quot; );</span>
<span class="nc" id="L1959">                    clientRunning[x] = false;</span>
<span class="nc" id="L1960">                    continue;</span>
                    }
            
                // send the number of ids that will be send through the communication link
<span class="nc" id="L1964">                dataOut[x].writeInt( ieii.num_incoming );</span>

                // send the capacity of the mailbox
<span class="nc" id="L1967">                dataOut[x].writeInt( ieii.mailbox_capacity );</span>
                                
<span class="nc" id="L1969">                dataOut[x].flush();</span>

                // read the address and port of the island
<span class="nc" id="L1972">                ieii.address = dataIn[x].readUTF().trim();</span>
<span class="nc" id="L1973">                ieii.port = dataIn[x].readInt();</span>

<span class="nc" id="L1975">                state.output.message( &quot;&quot; + x + &quot;: Island &quot; + connected_island_ids[x] + &quot; has address &quot; +</span>
                    ieii.address + &quot; : &quot; + ieii.port );

                // re-insert the information in the hash table
                // info.put( id, ieii );                                // unnecessary -- Sean
                }
<span class="nc" id="L1981">            catch( IOException e )</span>
                {
<span class="nc" id="L1983">                state.output.error( &quot;Could not open connection #&quot; + x );</span>
<span class="nc" id="L1984">                clientRunning[x] = false;</span>
<span class="nc" id="L1985">                }</span>
            }

<span class="nc" id="L1988">        state.output.exitIfErrors();</span>

        // By this time, all mailboxes have been started and
        // they should be waiting for incoming messages. this is because
        // in order to send the server the information about the address and port
        // of the mailbox, they have to start them first. This is the reason
        // that makes us be able to start connecting without other synchronization
        // stuff right at this point.

        // Now, I think, we've got a 1:1 mapping of keys to items in the info hashtable
        // So we tell everyone who they will communicate to

<span class="nc bnc" id="L2000" title="All 2 branches missed.">        for( int x = 0 ; x &lt; numIslands ; x++ )</span>
            {
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if( clientRunning[x] )</span>
                {
<span class="nc" id="L2004">                IslandExchangeIslandInfo ieii = (IslandExchangeIslandInfo)info.get( connected_island_ids[x] );</span>

<span class="nc bnc" id="L2006" title="All 2 branches missed.">                if( ieii == null )</span>
                    {
<span class="nc" id="L2008">                    state.output.warning( &quot;There is no information about island &quot; + connected_island_ids[x]);</span>
<span class="nc" id="L2009">                    clientRunning[x] = false;</span>
<span class="nc" id="L2010">                    continue;</span>
                    }

                try
                    {
                    // send the synchronous, modulo, offset and size information to the current islands
<span class="nc bnc" id="L2016" title="All 2 branches missed.">                    if( synchronous )</span>
<span class="nc" id="L2017">                        dataOut[x].writeInt( 1 );</span>
                    else
<span class="nc" id="L2019">                        dataOut[x].writeInt( 0 );</span>
<span class="nc" id="L2020">                    dataOut[x].writeInt( ieii.modulo );</span>
<span class="nc" id="L2021">                    dataOut[x].writeInt( ieii.offset );</span>
<span class="nc" id="L2022">                    dataOut[x].writeInt( ieii.size );</span>

                    // send the number of address-port pairs that will be sent
<span class="nc" id="L2025">                    dataOut[x].writeInt( ieii.num_mig );</span>

<span class="nc bnc" id="L2027" title="All 2 branches missed.">                    for( int y = 0 ; y &lt; ieii.num_mig ; y++ )</span>
                        {
                        IslandExchangeIslandInfo temp;

<span class="nc" id="L2031">                        temp = (IslandExchangeIslandInfo)info.get( ieii.migrating_island_ids[y] );</span>

<span class="nc bnc" id="L2033" title="All 2 branches missed.">                        if( temp == null )</span>
                            {
<span class="nc" id="L2035">                            state.output.warning( &quot;There is incorrect information on the island &quot; + connected_island_ids[x]  );</span>
<span class="nc" id="L2036">                            dataOut[x].writeUTF( &quot; &quot; );</span>
<span class="nc" id="L2037">                            dataOut[x].writeInt( -1 );</span>
                            }
                        else
                            {
<span class="nc" id="L2041">                            state.output.message( &quot;Island &quot; + connected_island_ids[x] + &quot; should connect to island &quot; +</span>
                                ieii.migrating_island_ids[y] + &quot; at &quot; + temp.address + &quot; : &quot; + temp.port );
<span class="nc" id="L2043">                            dataOut[x].writeUTF( temp.address );</span>
<span class="nc" id="L2044">                            dataOut[x].writeInt( temp.port );</span>
                            }
                        }
<span class="nc" id="L2047">                    dataOut[x].flush();</span>
                    }
<span class="nc" id="L2049">                catch( IOException e )</span>
                    {
                    // other errors while reading
<span class="nc" id="L2052">                    state.output.message(&quot;Server: Island &quot; + island_ids[x] + &quot; dropped connection&quot;);</span>
<span class="nc" id="L2053">                    clientRunning[x] = false;</span>
<span class="nc" id="L2054">                    continue;</span>
                    }
<span class="nc" id="L2056">                catch( NullPointerException e )</span>
                    {
                    // other errors while reading
<span class="nc" id="L2059">                    state.output.message(&quot;Server: Island &quot; + island_ids[x] + &quot; dropped connection&quot;);</span>
<span class="nc" id="L2060">                    clientRunning[x] = false;</span>
                    try
                        {
<span class="nc" id="L2063">                        dataIn[x].close();</span>
<span class="nc" id="L2064">                        dataOut[x].close();</span>
<span class="nc" id="L2065">                        con[x].close();</span>
                        }
<span class="nc" id="L2067">                    catch( IOException f )</span>
                        {
<span class="nc" id="L2069">                        }</span>
<span class="nc" id="L2070">                    continue;</span>
<span class="nc" id="L2071">                    }</span>
                }
            }

        try
            {
            // Next we wait until everyone acknowledges this
<span class="nc bnc" id="L2078" title="All 2 branches missed.">            for(int x=0;x&lt;dataIn.length;x++)</span>
                {
<span class="nc" id="L2080">                dataIn[x].readUTF();</span>
                }

            // Now we tell everyone to start running
<span class="nc bnc" id="L2084" title="All 2 branches missed.">            for(int x=0;x&lt;dataOut.length;x++)</span>
                {
<span class="nc" id="L2086">                dataOut[x].writeUTF( RUN );</span>
<span class="nc" id="L2087">                dataOut[x].flush();</span>
                }
            }
<span class="nc" id="L2090">        catch( IOException e )</span>
            {
<span class="nc" id="L2092">            }</span>

        // Okay we've sent off our information.  Now we wait until a client
        // tells us that he's found the solution, or until all the clients
        // have broken connections 
        
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        for(int x=0;x&lt;con.length;x++)</span>
            {
            try
                {
<span class="nc" id="L2102">                con[x].setSoTimeout(FOUND_TIMEOUT);</span>
                }
<span class="nc" id="L2104">            catch( SocketException e )</span>
                {
<span class="nc" id="L2106">                state.output.error( &quot;Could not set the connect with island &quot; + x + &quot; to non-blocking.&quot; );</span>
<span class="nc" id="L2107">                }</span>
            }

<span class="nc" id="L2110">        boolean shouldExit = false;</span>

<span class="nc bnc" id="L2112" title="All 2 branches missed.">        while(!shouldExit)</span>
            {
            // check whether there is at least one client running
            // otherwise the server might continue functioning just because the last client crashed or finished connection
<span class="nc" id="L2116">            shouldExit = true;</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">            for( int x = 0 ; x &lt; dataOut.length ; x++ )</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">                if( clientRunning[x] )</span>
                    {
<span class="nc" id="L2120">                    shouldExit = false;</span>
<span class="nc" id="L2121">                    break;</span>
                    }
<span class="nc bnc" id="L2123" title="All 2 branches missed.">            if( shouldExit )</span>
<span class="nc" id="L2124">                break;</span>

            // sleep a while
            try
                {
<span class="nc" id="L2129">                Thread.sleep(SLEEP_TIME);</span>
                }
<span class="nc" id="L2131">            catch( InterruptedException e )</span>
                {
<span class="nc" id="L2133">                }</span>

            String ww;

<span class="nc bnc" id="L2137" title="All 2 branches missed.">            for(int x=0;x&lt;dataOut.length;x++)</span>
                {
<span class="nc bnc" id="L2139" title="All 2 branches missed.">                if (clientRunning[x])</span>
                    {

                    // initialize ww
<span class="nc" id="L2143">                    ww = &quot;&quot;;</span>

                    // check to see if he's still up, and if he's
                    // sent us a &quot;I found it&quot; signal
                    try
                        {
<span class="nc" id="L2149">                        ww = dataIn[x].readUTF().trim();</span>
                        }
<span class="nc" id="L2151">                    catch( InterruptedIOException e )</span>
                        {
                        // means that it run out of time and got no message,
                        // so it should just continue with the other sockets
<span class="nc" id="L2155">                        continue;</span>
                        }
<span class="nc" id="L2157">                    catch( IOException e )</span>
                        {
                        // other errors while reading
<span class="nc" id="L2160">                        state.output.message(&quot;Server: Island &quot; + island_ids[x] + &quot; dropped connection&quot;);</span>
<span class="nc" id="L2161">                        clientRunning[x] = false;</span>
<span class="nc" id="L2162">                        continue;</span>
                        }
<span class="nc" id="L2164">                    catch( NullPointerException e )</span>
                        {
                        // other errors while reading
<span class="nc" id="L2167">                        state.output.message(&quot;Server: Island &quot; + island_ids[x] + &quot; dropped connection&quot;);</span>
<span class="nc" id="L2168">                        clientRunning[x] = false;</span>
                        try
                            {
<span class="nc" id="L2171">                            dataIn[x].close();</span>
<span class="nc" id="L2172">                            dataOut[x].close();</span>
<span class="nc" id="L2173">                            con[x].close();</span>
                            }
<span class="nc" id="L2175">                        catch( IOException f )</span>
                            {
<span class="nc" id="L2177">                            }</span>
<span class="nc" id="L2178">                        continue;</span>
<span class="nc" id="L2179">                        }</span>

                    // this will always be non-null
                    /*
                      if ( ww == null )  // the connection has been broken
                      {
                      state.output.message(&quot;Server: Island &quot; + island_ids[x] + &quot; dropped connection&quot;);
                      clientRunning[x] = false;
                      try
                      {
                      dataIn[x].close();
                      dataOut[x].close();
                      con[x].close();
                      }
                      catch( IOException e )
                      {
                      }
                      }
                      else 
                    */
<span class="nc bnc" id="L2199" title="All 2 branches missed.">                    if( ww.equals( FOUND ) ) // he found it!</span>
                        {
                        // inform everyone that they need to shut down --
                        // we do not need to wrap
                        // our println statements in anything, they just
                        // return even if the client has broken the connection
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                        for(int y=0;y&lt;dataOut.length;y++)</span>
                            {
<span class="nc bnc" id="L2207" title="All 2 branches missed.">                            if (clientRunning[y])</span>
                                {
                                try
                                    {
<span class="nc" id="L2211">                                    dataOut[y].writeUTF(GOODBYE);</span>
<span class="nc" id="L2212">                                    dataOut[y].close();</span>
<span class="nc" id="L2213">                                    dataIn[y].close();</span>
<span class="nc" id="L2214">                                    con[y].close();</span>
                                    }
<span class="nc" id="L2216">                                catch( IOException e )</span>
                                    {
<span class="nc" id="L2218">                                    }</span>
                                }
                            }
                        // now we can just get out of all this and
                        // quit the thread 
<span class="nc" id="L2223">                        shouldExit=true;</span>
<span class="nc" id="L2224">                        break;</span>
                        }
<span class="nc bnc" id="L2226" title="All 2 branches missed.">                    else if( ww.equals( SYNC ) )</span>
                        {
<span class="nc" id="L2228">                        who_is_synchronized[x] = true;</span>

<span class="nc" id="L2230">                        boolean complete_synchronization = true;</span>

<span class="nc bnc" id="L2232" title="All 2 branches missed.">                        for( int y = 0 ; y &lt; numIslands ; y++ )</span>
<span class="nc bnc" id="L2233" title="All 6 branches missed.">                            complete_synchronization = complete_synchronization &amp;&amp;</span>
                                ( ( ! clientRunning[y] ) || who_is_synchronized[y] );

                        // if the number of total running islands is smaller than the
                        // number of islands that ask for synchronization, let them continue
                        // running
<span class="nc bnc" id="L2239" title="All 2 branches missed.">                        if( complete_synchronization )</span>
                            {

<span class="nc bnc" id="L2242" title="All 2 branches missed.">                            for( int y = 0 ; y &lt; numIslands ; y++ )</span>
                                {
                                // send the okay message (the client can continue executing)
<span class="nc bnc" id="L2245" title="All 2 branches missed.">                                if( clientRunning[y] )</span>
                                    try
                                        {
<span class="nc" id="L2248">                                        dataOut[y].writeUTF( OKAY );</span>
<span class="nc" id="L2249">                                        dataOut[y].flush();</span>
                                        }
<span class="nc" id="L2251">                                    catch( IOException e ) {}</span>
                                // reset the who_is_synchronized variable
<span class="nc" id="L2253">                                who_is_synchronized[y] = false;</span>
                                }
                            }

                        }
                    }
                }
            }
<span class="nc" id="L2261">        state.output.message( &quot;Server Exiting&quot; );    </span>
<span class="nc" id="L2262">        }</span>

    /** Here we spawn off the thread on ourselves */
    public Thread spawnThread()
        {
<span class="nc" id="L2267">        Thread thread = new Thread( this );</span>
<span class="nc" id="L2268">        thread.start();</span>
<span class="nc" id="L2269">        return thread;</span>
        }

        
    public static final int ISLAND_INDEX_LOOKUP_FAILED = -1;
<span class="nc" id="L2274">    public static final Parameter islandIndexBase = new Parameter(&quot;exch.island&quot;);</span>
<span class="nc" id="L2275">    public static final Parameter islandIndexNumIslands = new Parameter(&quot;exch.num-islands&quot;);</span>

    /** Looks up the island id in the parameter database, assuming something like
        exch.island.1.id = GilligansIsland
        Then returns the index number (in the example before, this would be 1).
        If there is no such island in the parameter database using this parameter
        format, then returns ISLAND_INDEX_LOOKUP_FAILED and issues a one-time warning.  
        NOTE: This algorithm is O(n) for the number of
        islands.  No, it's not fast, but with a small number of islands, it's not a big
        deal.
    */ 
    public int getIslandIndex(EvolutionState state, String id)
        {
<span class="nc" id="L2288">        int num = state.parameters.getInt(islandIndexNumIslands, null, 0);</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">        if (num &lt; 0) // uh oh</span>
            {
<span class="nc" id="L2291">            state.output.warnOnce(&quot;IslandExchange.islandIndex could not find the number of islands&quot;, islandIndexNumIslands, null );</span>
<span class="nc" id="L2292">            return ISLAND_INDEX_LOOKUP_FAILED;</span>
            }
                        
<span class="nc bnc" id="L2295" title="All 2 branches missed.">        for(int i = 0; i &lt; num; i++)</span>
            {
<span class="nc" id="L2297">            Parameter b = islandIndexBase.push(&quot;&quot; + i).push(&quot;id&quot;);</span>
<span class="nc" id="L2298">            String island = state.parameters.getString(b, null);</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">            if (island == null)</span>
<span class="nc" id="L2300">                state.output.warnOnce(&quot;IslandExchange.islandIndex could not find island number &quot; + i, b, null);</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">            else if (island.equals(id))</span>
<span class="nc" id="L2302">                return i;</span>
            }
                        
<span class="nc" id="L2305">        state.output.warnOnce(&quot;IslandExchange.islandIndex could not find any island called &quot; + id);</span>
<span class="nc" id="L2306">        return ISLAND_INDEX_LOOKUP_FAILED;</span>
        }
    }

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>