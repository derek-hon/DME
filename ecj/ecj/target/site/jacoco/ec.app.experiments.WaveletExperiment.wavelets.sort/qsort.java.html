<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>qsort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.app.experiments.WaveletExperiment.wavelets.sort</a> &gt; <span class="el_source">qsort.java</span></div><h1>qsort.java</h1><pre class="source lang-java linenums">
package ec.app.experiments.WaveletExperiment.wavelets.sort;

/**
  &lt;p&gt;
  This class supports the Quicksort algorithm.  This is a slightly
  modified version of the Qsort class written by James Gosling at Sun
  Microsystems (see below).
  &lt;/p&gt;
  &lt;blockquote&gt;
  &lt;p&gt;
  @(#)QSortAlgorithm.java	1.3   29 Feb 1996 James Gosling
  &lt;/p&gt;
  &lt;p&gt;
  Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved.
  &lt;/p&gt;
  &lt;p&gt;
  Permission to use, copy, modify, and distribute this software
  and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
  without fee is hereby granted. 
  &lt;/p&gt;
  &lt;p&gt;
  Please refer to the file http://www.javasoft.com/copy_trademarks.html
  for further important copyright and trademark information and to
  http://www.javasoft.com/licensing.html for further important
  licensing information for the Java (tm) Technology.
  &lt;/p&gt;
  &lt;/pre&gt;
  
  */

<span class="nc" id="L32">public class qsort</span>
{
  /** This is a generic version of C.A.R Hoare's Quick Sort 
   * algorithm.  This will handle arrays that are already
   * sorted, and arrays with duplicate keys.&lt;BR&gt;
   *
   * If you think of a one dimensional array as going from
   * the lowest index on the left to the highest index on the right
   * then the parameters to this function are lowest index or
   * left and highest index or right.  The first time you call
   * this function it will be with the parameters 0, a.length - 1.
   *
   * @param a       an integer array
   * @param lo0     left boundary of array partition
   * @param hi0     right boundary of array partition
   */
  static void QuickSort(double a[], int lo0, int hi0)
  {
<span class="nc" id="L50">    int lo = lo0;</span>
<span class="nc" id="L51">    int hi = hi0;</span>
    double mid;
    
<span class="nc bnc" id="L54" title="All 2 branches missed.">    if ( hi0 &gt; lo0) {</span>
      /* Arbitrarily establishing partition element as the midpoint of
       * the array.
       */
<span class="nc" id="L58">      mid = a[ ( lo0 + hi0 ) / 2 ];</span>
      
      // loop through the array until indices cross
<span class="nc bnc" id="L61" title="All 2 branches missed.">      while( lo &lt;= hi )	{</span>
	/* find the first element that is greater than or equal to 
	 * the partition element starting from the left Index.
	 */
<span class="nc bnc" id="L65" title="All 4 branches missed.">	while( ( lo &lt; hi0 ) &amp;&amp; ( a[lo] &lt; mid ) )</span>
<span class="nc" id="L66">	  ++lo;</span>
	
	/* find an element that is smaller than or equal to 
	 * the partition element starting from the right Index.
	 */
<span class="nc bnc" id="L71" title="All 4 branches missed.">	while( ( hi &gt; lo0 ) &amp;&amp; ( a[hi] &gt; mid ) )</span>
<span class="nc" id="L72">	  --hi;</span>
	
	// if the indexes have not crossed, swap
<span class="nc bnc" id="L75" title="All 2 branches missed.">	if( lo &lt;= hi ) {</span>
<span class="nc" id="L76">	  swap(a, lo, hi);</span>
	  
<span class="nc" id="L78">	  ++lo;</span>
<span class="nc" id="L79">	  --hi;</span>
	}
      } // while
      
      /* If the right index has not reached the left side of array
       * must now sort the left partition.
       */
<span class="nc bnc" id="L86" title="All 2 branches missed.">      if( lo0 &lt; hi )</span>
<span class="nc" id="L87">	QuickSort( a, lo0, hi );</span>
      
      /* If the left index has not reached the right side of array
       * must now sort the right partition.
       */
<span class="nc bnc" id="L92" title="All 2 branches missed.">      if( lo &lt; hi0 )</span>
<span class="nc" id="L93">	QuickSort( a, lo, hi0 );</span>
      
    }
<span class="nc" id="L96">  }  // QuickSort</span>

  
  private static void swap(double a[], int i, int j)
  {
    double T;
<span class="nc" id="L102">    T = a[i]; </span>
<span class="nc" id="L103">    a[i] = a[j];</span>
<span class="nc" id="L104">    a[j] = T;</span>
<span class="nc" id="L105">  } // swap</span>

  
  public static void sort(double a[])
  {
<span class="nc" id="L110">    QuickSort(a, 0, a.length - 1);</span>
<span class="nc" id="L111">  } // sort</span>

} // qsort
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>