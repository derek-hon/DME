<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MuCommaLambdaBreeder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.es</a> &gt; <span class="el_source">MuCommaLambdaBreeder.java</span></div><h1>MuCommaLambdaBreeder.java</h1><pre class="source lang-java linenums">/*
  Copyright 2006 by Sean Luke
  Licensed under the Academic Free License version 3.0
  See the file &quot;LICENSE&quot; for more information
*/


package ec.es;
import java.util.ArrayList;
import java.util.Arrays;

import ec.*;
import ec.util.*;

/* 
 * MuCommaLambdaBreeder.java
 * 
 * Created: Thu Sep  7 17:27:47 2000
 * By: Sean Luke
 */

/**
 * MuCommaLambdaBreeder is a Breeder which, together with
 * ESSelection, implements the (mu,lambda) breeding strategy and gathers
 * the comparison data you can use to implement a 1/5-rule mutation mechanism.
 * 
 * &lt;p&gt;Evolution strategies breeders require a &quot;mu&quot; parameter and a &quot;lambda&quot;
 * parameter for each subpopulation.  &quot;mu&quot; refers to the number of parents
 * from which the new population will be built.  &quot;lambda&quot; refers to the
 * number of children generated by the mu parents.  Subpopulation sizes
 * will change as necessary to accommodate this fact in later generations.
 * The only rule for initial subpopulation sizes is that they must be
 * greater than or equal to the mu parameter for that subpopulation.
 *
 * &lt;p&gt;You can now set your initial subpopulation
 * size to whatever you like, totally independent of lambda and mu,
 * as long as it is &amp;gt;= mu.
 *
 * &lt;p&gt;MuCommaLambdaBreeder stores mu and lambda values for each subpopulation
 * in the population, as well as comparisons.  A comparison tells you
 * if &amp;gt;1/5, &amp;lt;1/5 or =1/5 of the new population was better than its
 * parents (the so-called evolution strategies &quot;one-fifth rule&quot;.
 * Although the comparisons are gathered, no mutation objects are provided
 * which actually &lt;i&gt;use&lt;/i&gt; them -- you're free to use them in any mutation
 * objects you care to devise which requires them.
 *
 * &lt;p&gt;To do evolution strategies evolution, the
 * breeding pipelines should contain at least one ESSelection selection method.
 * While a child is being generated by the pipeline, the ESSelection object will return a parent
 * from the pool of mu parents.  The particular parent is chosen round-robin, so all the parents
 * will have an equal number of children.  It's perfectly fine to have more than one ESSelection
 * object in the tree, or to call the same one repeatedly during the course of generating a child;
 * all such objects will consistently return the same parent.  They only increment to the next
 * parent in the pool of mu parents after the child has been created from the pipeline.  You can
 * also mix ESSelection operators with other operators (like Tournament Selection).  But you ought
 * to have &lt;b&gt;at least one&lt;/b&gt; ESSelection operator in the pipeline -- else it wouldn't be Evolution
 * Strategies, would it?
 
 &lt;p&gt;&lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;
 &lt;table&gt;
 &lt;tr&gt;&lt;td valign=top&gt;es.lambda.&lt;i&gt;subpop-num&lt;/i&gt;&lt;br&gt;
 &lt;font size=-1&gt;int &gt;= 0&lt;/font&gt;&lt;/td&gt;&lt;td&gt;Specifies the 'lambda' parameter for the subpopulation.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;&lt;td valign=top&gt;es.mu.&lt;i&gt;subpop-num&lt;/i&gt;&lt;br&gt;
 &lt;font size=-1&gt;int:  a multiple of &quot;lambda&quot;&lt;/font&gt;&lt;/td&gt;&lt;td&gt;Specifies the 'mu' parameter for the subpopulation.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/table&gt;

 * @author Sean Luke
 * @version 1.0 
 */

<span class="nc" id="L73">public class MuCommaLambdaBreeder extends Breeder</span>
    {    
    public static final String P_MU = &quot;mu&quot;;
    public static final String P_MU_FRACTION = &quot;mu-fraction&quot;;
    public static final String P_LAMBDA = &quot;lambda&quot;;

    public int[] mu;
    public int[] lambda;
    
    public Population parentPopulation;

    public byte[] comparison; 
    public static final byte C_OVER_ONE_FIFTH_BETTER = 1;
    public static final byte C_UNDER_ONE_FIFTH_BETTER = -1;
    public static final byte C_EXACTLY_ONE_FIFTH_BETTER = 0;
   
    // This is a DOUBLE ARRAY of ARRAYLISTS of &lt;INDIVIDUALS&gt;
    // Individuals are stored here by the breed pop chunk methods, and afterwards
    // we coalesce them into the new population. 
    public ArrayList newIndividuals[/*subpop*/][/*thread*/];
        
    /** Modified by multiple threads, don't fool with this */
    public int[] count;

    /** lambda should be no SMALLER than mu times this value. 
        This varies between (mu,lambda) (where it's 2) and
        (mu + lambda) (where it's 1).
    */
<span class="nc" id="L101">    public int maximumMuLambdaDivisor() { return 2; }</span>

    public void setup(final EvolutionState state, final Parameter base)
        {
        // we're not using the base
<span class="nc" id="L106">        Parameter p = new Parameter(Initializer.P_POP).push(Population.P_SIZE);</span>
<span class="nc" id="L107">        int size = state.parameters.getInt(p,null,1);  // if size is wrong, we'll let Population complain about it -- for us, we'll just make 0-sized arrays and drop out.</span>
        
<span class="nc" id="L109">        mu = new int[size];</span>
<span class="nc" id="L110">        lambda = new int[size];</span>
<span class="nc" id="L111">        comparison = new byte[size];</span>
        
        // load mu and lambda data
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for(int x=0;x&lt;size;x++)</span>
            {
<span class="nc" id="L116">            Parameter pp = new Parameter(Initializer.P_POP).push(Population.P_SUBPOP).push(&quot;&quot;+x).push(Subpopulation.P_SUBPOPSIZE);</span>
<span class="nc" id="L117">            int ppval = state.parameters.getInt(pp, null, 1);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (state.parameters.exists(ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null))  // we have a lambda</span>
                {
<span class="nc" id="L120">                lambda[x] = state.parameters.getInt(ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null,1);            </span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                if (lambda[x]==0) state.output.error(&quot;lambda must be an integer &gt;= 1&quot;,ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x));</span>
                }
            else
                {
<span class="nc" id="L125">                state.output.warning(&quot;lambda not specified for subpopulation &quot; + x + &quot;, setting it to the subopulation size, that is, &quot; + ppval + &quot;.&quot;, </span>
<span class="nc" id="L126">                    ESDefaults.base().push(P_LAMBDA).push(&quot;&quot;+x),null);</span>
<span class="nc" id="L127">                lambda[x] = ppval;</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (lambda[x] == 0)</span>
<span class="nc" id="L129">                    state.output.error(&quot;Subpouplation Size must be &gt;= 1&quot;, pp, null);</span>
                }
                                
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (state.parameters.exists(ESDefaults.base().push(P_MU).push(&quot;&quot;+x),null))  // we defined mu</span>
                {
                // did we also define a mu-fraction?
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (state.parameters.exists(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null))</span>
<span class="nc" id="L136">                    state.output.warning(&quot;Defined both a mu and mu-fraction for subpopulation &quot; + x + &quot;.  Only mu will be used. &quot;, </span>
<span class="nc" id="L137">                        ESDefaults.base().push(P_MU).push(&quot;&quot;+x),</span>
<span class="nc" id="L138">                        ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x));</span>
                
<span class="nc" id="L140">                mu[x] = state.parameters.getInt(ESDefaults.base().push(P_MU).push(&quot;&quot;+x),null,1);       </span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if (mu[x]==0) state.output.error(&quot;mu must be an integer &gt;= 1&quot;,ESDefaults.base().push(P_MU).push(&quot;&quot;+x), null);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                else if (lambda[x] % mu[x] != 0)</span>
                    {
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (mu[x] &gt; lambda[x] / maximumMuLambdaDivisor())</span>
                        {
<span class="nc" id="L146">                        state.output.warning(&quot;mu (&quot; + mu[x] + &quot;) for subpopulation &quot; + x + &quot; is greater than lambda (&quot; + lambda[x] + &quot;) / &quot; + maximumMuLambdaDivisor() + &quot;.  Mu will be set to half of lambda, that is, &quot; + lambda[x] / maximumMuLambdaDivisor() + &quot;.&quot;);                        </span>
<span class="nc" id="L147">                        mu[x] = lambda[x] / maximumMuLambdaDivisor();</span>
                        }
        
<span class="nc bnc" id="L150" title="All 2 branches missed.">                    if (lambda[x] % mu[x] != 0)  // check again</span>
<span class="nc" id="L151">                        state.output.error(&quot;mu must be a divisor of lambda&quot;, ESDefaults.base().push(P_MU).push(&quot;&quot;+x));</span>
                    }
<span class="nc bnc" id="L153" title="All 2 branches missed.">                else if (mu[x] &gt; ppval)</span>
                    {
<span class="nc" id="L155">                    state.output.warning(&quot;mu is presently &gt; the initial subpopulation size.  Mu will be set to the subpopulation size, that is, &quot; + ppval + &quot;.&quot;, ESDefaults.base().push(P_MU).push(&quot;&quot;+x), null);</span>
<span class="nc" id="L156">                    mu[x] = ppval;</span>
                    }
                }
<span class="nc bnc" id="L159" title="All 2 branches missed.">            else if (state.parameters.exists(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null))  // we defined mu in terms of a fraction</span>
                {
<span class="nc" id="L161">                double mufrac = state.parameters.getDoubleWithMax(ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null, 0.0, 1.0 / maximumMuLambdaDivisor());</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (mufrac &lt; 0.0)</span>
<span class="nc" id="L163">                    state.output.fatal(&quot;Mu-Fraction must be a value between 0.0 and &quot; + 1.0 / maximumMuLambdaDivisor(), ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x), null);</span>
                                
<span class="nc" id="L165">                int m = (int)Math.max(lambda[x] * mufrac, 1.0);</span>
<span class="nc" id="L166">                mu[x] = m;</span>
                // find the largest divisor of lambda[x] which is &lt;= m. This is ugly
<span class="nc" id="L168">                double val = lambda[x] / (double) mu[x];</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                while (val != (int) val)</span>
                    {
<span class="nc" id="L171">                    mu[x]--;</span>
<span class="nc" id="L172">                    val = lambda[x] / (double) mu[x];</span>
                    }
<span class="nc" id="L174">                state.output.message(&quot;Mu-Fraction &quot; + mufrac + &quot; yields a mu of &quot; + m + &quot;, adjusted to &quot; + mu[x]);</span>
<span class="nc" id="L175">                }</span>
<span class="nc" id="L176">            else state.output.fatal(&quot;Neither a Mu or a Mu-Fraction was provided for subpopulation &quot; + x, ESDefaults.base().push(P_MU).push(&quot;&quot;+x), ESDefaults.base().push(P_MU_FRACTION).push(&quot;&quot;+x));</span>
            }
<span class="nc" id="L178">        state.output.exitIfErrors();</span>
<span class="nc" id="L179">        }</span>



    /** Sets all subpopulations in pop to the expected lambda size.  Does not fill new slots with individuals. */
    //    public Population setToLambda(Population pop, EvolutionState state)
    //        {
    //        for(int x = 0; x&lt; pop.subpops.size(); x++)
    //            {
    //            int s = lambda[x];
    //            
    //            System.out.println(&quot;size of s is &quot;+s);
    //            System.out.println(&quot;size of size is &quot;+pop.subpops.get(x).individuals.size());
    //            
    //            // check to see if the array's not the right size
    //            if (pop.subpops.get(x).individuals.size() != s)
    //                // need to increase
    //                {
    //                Individual[] newinds = new Individual[s];
    //                System.arraycopy(pop.subpops.get(x).individuals,0,newinds,0,
    //                    s &lt; pop.subpops.get(x).individuals.size() ?
    //                    s : pop.subpops.get(x).individuals.size());
    //                pop.subpops.get(x).individuals = new ArrayList&lt;Individual&gt;(Arrays.asList(newinds));
    //                }
    //            }
    //        return pop;
    //        }
                

    public Population breedPopulation(EvolutionState state) 
        {
        // Complete 1/5 statistics for last population
        
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (parentPopulation != null)</span>
            {
            // Only go from 0 to lambda-1, as the remaining individuals may be parents.
            // A child C's parent's index I is equal to C / mu[subpopulation].
<span class="nc bnc" id="L216" title="All 2 branches missed.">            for (int x = 0; x&lt; state.population.subpops.size(); x++)</span>
                {
<span class="nc" id="L218">                int numChildrenBetter = 0;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                for (int i = 0; i &lt; lambda[x]; i++)</span>
                    {
<span class="nc" id="L221">                    int parent = i / (lambda[x] / mu[x]);  // note integer division</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                    if (state.population.subpops.get(x).individuals.get(i).fitness.betterThan(parentPopulation.subpops.get(x).individuals.get(parent).fitness))</span>
<span class="nc" id="L223">                        numChildrenBetter++;</span>
                    }
<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (numChildrenBetter &gt; lambda[x] / 5.0)  // note double division</span>
<span class="nc" id="L226">                    comparison[x] = C_OVER_ONE_FIFTH_BETTER;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                else if (numChildrenBetter &lt; lambda[x] / 5.0)  // note double division</span>
<span class="nc" id="L228">                    comparison[x] = C_UNDER_ONE_FIFTH_BETTER;</span>
<span class="nc" id="L229">                else comparison[x] = C_EXACTLY_ONE_FIFTH_BETTER;</span>
                }
            }
                        
        // load the parent population
<span class="nc" id="L234">        parentPopulation = state.population;</span>
        
        // MU COMPUTATION
        
        // At this point we need to do load our population info
        // and make sure it jibes with our mu info

        // the first issue is: is the number of subpopulations
        // equal to the number of mu's?

<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (mu.length!= state.population.subpops.size()) // uh oh</span>
<span class="nc" id="L245">            state.output.fatal(&quot;For some reason the number of subpops is different than was specified in the file (conflicting with Mu and Lambda storage).&quot;,null);</span>

        // next, load our population, make sure there are no subpopulations smaller than the mu's
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (state.population.subpops.get(0).individuals.size() &lt; mu[x])</span>
<span class="nc" id="L251">                state.output.error(&quot;Subpopulation &quot; + x + &quot; must be a multiple of the equivalent mu (that is, &quot;+ mu[x]+&quot;).&quot;);</span>
            }
<span class="nc" id="L253">        state.output.exitIfErrors();</span>
        
        
        // sort evaluation to get the Mu best of each subpopulation
        
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc" id="L260">            final ArrayList&lt;Individual&gt; i = state.population.subpops.get(x).individuals;</span>

<span class="nc" id="L262">            java.util.Collections.sort(i,</span>
                new java.util.Comparator&lt;Individual&gt;()
<span class="nc" id="L264">                    {</span>
                    public int compare(Individual i1, Individual i2)
                        {
<span class="nc" id="L267">                        Individual a = i1;</span>
<span class="nc" id="L268">                        Individual b = i2;</span>
                        // return 1 if should appear after object b in the array.
                        // This is the case if a has WORSE fitness.
<span class="nc bnc" id="L271" title="All 2 branches missed.">                        if (b.fitness.betterThan(a.fitness)) return 1;</span>
                        // return -1 if a should appear before object b in the array.
                        // This is the case if b has WORSE fitness.
<span class="nc bnc" id="L274" title="All 2 branches missed.">                        if (a.fitness.betterThan(b.fitness)) return -1;</span>
                        // else return 0
<span class="nc" id="L276">                        return 0;</span>
                        }
                    });
            }

        // now the subpops are sorted so that the best individuals appear in the lowest indexes.

        // by Ermo, it seems we no longer need setToLambda, so I am comment them out, if it works, we will delete them later
        //Population newpop = setToLambda((Population) state.population.emptyClone(),state);
<span class="nc" id="L285">        Population newpop = (Population) state.population.emptyClone();</span>
        
        // create the count array
<span class="nc" id="L288">        count = new int[state.breedthreads];</span>

        // divvy up the lambda individuals to create




        // how many threads do we really need?  No more than the maximum number of individuals in any subpopulation
<span class="nc" id="L296">        int numThreads = 0;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for(int x = 0; x &lt; state.population.subpops.size(); x++)</span>
<span class="nc" id="L298">            numThreads = Math.max(numThreads, lambda[x]);</span>
<span class="nc" id="L299">        numThreads = Math.min(numThreads, state.breedthreads);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (numThreads &lt; state.breedthreads)</span>
<span class="nc" id="L301">            state.output.warnOnce(&quot;Largest lambda size (&quot; + numThreads +&quot;) is smaller than number of breedthreads (&quot; + state.breedthreads +</span>
                &quot;), so fewer breedthreads will be created.&quot;);
            
<span class="nc" id="L304">        newIndividuals = new ArrayList[state.population.subpops.size()][numThreads];</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++)</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
<span class="nc" id="L307">                newIndividuals[subpop][thread] = new ArrayList&lt;Individual&gt;();</span>
            
<span class="nc" id="L309">        int numinds[][] = </span>
<span class="nc" id="L310">            new int[numThreads][state.population.subpops.size()];</span>
<span class="nc" id="L311">        int from[][] = </span>
<span class="nc" id="L312">            new int[numThreads][state.population.subpops.size()];</span>
        
<span class="nc bnc" id="L314" title="All 2 branches missed.">        for(int x = 0; x&lt; state.population.subpops.size(); x++)</span>
            {
<span class="nc bnc" id="L316" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
<span class="nc" id="L317">                newIndividuals[x][thread].clear();</span>

<span class="nc" id="L319">            int length = lambda[x];</span>

            // we will have some extra individuals.  We distribute these among the early subpopulations
<span class="nc" id="L322">            int individualsPerThread = length / numThreads;  // integer division</span>
<span class="nc" id="L323">            int slop = length - numThreads * individualsPerThread;</span>
<span class="nc" id="L324">            int currentFrom = 0;</span>
                                
<span class="nc bnc" id="L326" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++)</span>
                {
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (slop &gt; 0)</span>
                    {
<span class="nc" id="L330">                    numinds[y][x] = individualsPerThread + 1;</span>
<span class="nc" id="L331">                    slop--;</span>
                    }
                else
<span class="nc" id="L334">                    numinds[y][x] = individualsPerThread;</span>
                    
<span class="nc bnc" id="L336" title="All 2 branches missed.">                if (numinds[y][x] == 0)</span>
                    {
<span class="nc" id="L338">                    state.output.warnOnce(&quot;More threads exist than can be used to breed some subpopulations (first example: subpopulation &quot; + x + &quot;)&quot;);</span>
                    }
                    
<span class="nc" id="L341">                from[y][x] = currentFrom;</span>
<span class="nc" id="L342">                currentFrom += numinds[y][x];</span>
                }
            }

        /*

          for(int y=0;y&lt;state.breedthreads;y++)
          for(int x=0;x&lt;state.population.subpops.length;x++)
          {
          // figure numinds
          if (y&lt;state.breedthreads-1) // not last one
          numinds[y][x]=
          lambda[x]/state.breedthreads;
          else // in case we're slightly off in division
          numinds[y][x]=
          lambda[x]/state.breedthreads +
          (lambda[x] - (lambda[x] / state.breedthreads)  // note integer division
          *state.breedthreads);                   
                
          // figure from
          from[y][x]=
          (lambda[x]/
          state.breedthreads) * y;
          }
        */           
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (numThreads==1)</span>
            {
<span class="nc" id="L369">            breedPopChunk(newpop,state,numinds[0],from[0],0);</span>
            }
        else
            {
<span class="nc" id="L373">            Thread[] t = new Thread[numThreads];</span>
                
            // start up the threads
<span class="nc bnc" id="L376" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++)</span>
                {
<span class="nc" id="L378">                MuLambdaBreederThread r = new MuLambdaBreederThread();</span>
<span class="nc" id="L379">                r.threadnum = y;</span>
<span class="nc" id="L380">                r.newpop = newpop;</span>
<span class="nc" id="L381">                r.numinds = numinds[y];</span>
<span class="nc" id="L382">                r.from = from[y];</span>
<span class="nc" id="L383">                r.me = this;</span>
<span class="nc" id="L384">                r.state = state;</span>
<span class="nc" id="L385">                t[y] = new Thread(r);</span>
<span class="nc" id="L386">                t[y].start();</span>
                }
                
            // gather the threads
<span class="nc bnc" id="L390" title="All 2 branches missed.">            for(int y=0;y&lt;numThreads;y++) </span>
                try
                    {
<span class="nc" id="L393">                    t[y].join();</span>
                    }
<span class="nc" id="L395">                catch(InterruptedException e)</span>
                    {
<span class="nc" id="L397">                    state.output.fatal(&quot;Whoa! The main breeding thread got interrupted!  Dying...&quot;);</span>
<span class="nc" id="L398">                    }</span>
            }
            
        // Coalesce
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for(int subpop = 0; subpop &lt; state.population.subpops.size(); subpop++)</span>
            {
<span class="nc" id="L404">            ArrayList&lt;Individual&gt; newpopindividuals = newpop.subpops.get(subpop).individuals;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            for(int thread = 0; thread &lt; numThreads; thread++)</span>
                {
<span class="nc" id="L407">                newpopindividuals.addAll(newIndividuals[subpop][thread]);</span>
                }
            }

<span class="nc" id="L411">        return postProcess(newpop,state.population,state);</span>
        }

    /** A hook for Mu+Lambda, not used in Mu,Lambda */

    public Population postProcess(Population newpop, Population oldpop, EvolutionState state)
        {
<span class="nc" id="L418">        return newpop;</span>
        }
    
    
    int[] children;
    int[] parents;
    
    
    /** A private helper function for breedPopulation which breeds a chunk
        of individuals in a subpopulation for a given thread.
        Although this method is declared
        public (for the benefit of a private helper class in this file),
        you should not call it. */
    
    public void breedPopChunk(Population newpop, EvolutionState state, int[] numinds, int[] from, int threadnum) 
        {
<span class="nc bnc" id="L434" title="All 2 branches missed.">        for(int subpop = 0; subpop&lt; newpop.subpops.size(); subpop++)</span>
            {
<span class="nc" id="L436">            ArrayList&lt;Individual&gt; putHere = (ArrayList&lt;Individual&gt;)newIndividuals[subpop][threadnum];</span>

            // reset the appropriate count slot  -- this used to be outside the for-loop, a bug
            // I believe
<span class="nc" id="L440">            count[threadnum]=0;</span>
        
<span class="nc" id="L442">            BreedingSource bp = (BreedingSource) newpop.subpops.get(subpop).</span>
<span class="nc" id="L443">                species.pipe_prototype.clone();</span>
            
            // check to make sure that the breeding pipeline produces
            // the right kind of individuals.  Don't want a mistake there! :-)
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (!bp.produces(state,newpop,subpop,threadnum))</span>
<span class="nc" id="L448">                state.output.fatal(&quot;The Breeding Source of subpopulation &quot; + subpop + &quot; does not produce individuals of the expected species &quot; + newpop.subpops.get(subpop).species.getClass().getName() + &quot; or fitness &quot; + newpop.subpops.get(subpop).species.f_prototype );</span>
<span class="nc" id="L449">            bp.prepareToProduce(state,subpop,threadnum);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (count[threadnum] == 0)  // the ESSelection didn't set it to nonzero to inform us of his existence</span>
<span class="nc" id="L451">                state.output.warnOnce(&quot;Whoa!  Breeding Source for subpop &quot; + subpop + &quot; doesn't have an ESSelection, but is being used by MuCommaLambdaBreeder or MuPlusLambdaBreeder.  That's probably not right.&quot;);</span>
            // reset again
<span class="nc" id="L453">            count[threadnum] = 0;</span>
        
            // start breedin'!
            
<span class="nc" id="L457">            int upperbound = from[subpop]+numinds[subpop];</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for(int x=from[subpop];x&lt;upperbound;x++)</span>
                {
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (bp.produce(1,1,subpop, putHere, state,threadnum, newpop.subpops.get(subpop).species.buildMisc(state, subpop, threadnum)) != 1)</span>
<span class="nc" id="L461">                    state.output.fatal(&quot;Whoa! Breeding Source for subpop &quot; + subpop + &quot; is not producing one individual at a time, as is required by the MuLambda strategies.&quot;);</span>

                // increment the count
<span class="nc" id="L464">                count[threadnum]++;</span>
                }
<span class="nc" id="L466">            bp.finishProducing(state,subpop,threadnum);</span>
            }
<span class="nc" id="L468">        }</span>
    }


/** A private helper class for implementing multithreaded breeding */
<span class="nc" id="L473">class MuLambdaBreederThread implements Runnable</span>
    {
    Population newpop;
    public int[] numinds;
    public int[] from;
    public MuCommaLambdaBreeder me;
    public EvolutionState state;
    public int threadnum;
    public void run()
        {
<span class="nc" id="L483">        me.breedPopChunk(newpop,state,numinds,from,threadnum);</span>
<span class="nc" id="L484">        }</span>
    }


</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>