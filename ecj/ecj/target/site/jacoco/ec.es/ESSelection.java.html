<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ESSelection.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ecj</a> &gt; <a href="index.source.html" class="el_package">ec.es</a> &gt; <span class="el_source">ESSelection.java</span></div><h1>ESSelection.java</h1><pre class="source lang-java linenums">/*
  Copyright 2006 by Sean Luke
  Licensed under the Academic Free License version 3.0
  See the file &quot;LICENSE&quot; for more information
*/


package ec.es;
import ec.*;
import ec.util.*;

import java.util.*;

/* 
 * ESSelection.java
 * 
 * Created: Thu Sep  7 19:08:19 2000
 * By: Sean Luke
 */

/**
 * ESSelection is a special SelectionMethod designed to be used with 
 * evolutionary strategies-type breeders.
 *
 * &lt;p&gt;To do evolution strategies evolution, the
 * breeding pipelines should contain at least one ESSelection selection method.
 * While a child is being generated by the pipeline, the ESSelection object will return a parent
 * from the pool of mu parents.  The particular parent is chosen round-robin, so all the parents
 * will have an equal number of children.  It's perfectly fine to have more than one ESSelection
 * object in the tree, or to call the same one repeatedly during the course of generating a child;
 * all such objects will consistently return the same parent.  They only increment to the nex
 * parent in the pool of mu parents after the child has been created from the pipeline.  You can
 * also mix ESSelection operators with other operators (like Tournament Selection).  But you ought
 * to have &lt;b&gt;at least one&lt;/b&gt; ESSelection operator in the pipeline -- else it wouldn't be Evolution
 * Strategies, would it?

 &lt;p&gt;&lt;b&gt;Default Base&lt;/b&gt;&lt;br&gt;
 es.select

 * @author Sean Luke
 * @version 1.0 
 */

<span class="nc" id="L44">public class ESSelection extends SelectionMethod </span>
    {
    public static final String P_ESSELECT = &quot;select&quot;;

    public Parameter defaultBase()
        {
<span class="nc" id="L50">        return ESDefaults.base().push(P_ESSELECT);</span>
        }

    // MuCommaLambdaBreeder expects us to set the count to nonzero to indicate our existence
    public void prepareToProduce(final EvolutionState state,
        final int subpopulation,
        final int thread)
        {
<span class="nc" id="L58">        super.prepareToProduce(state, subpopulation, thread);</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (!(state.breeder instanceof MuCommaLambdaBreeder))</span>
<span class="nc" id="L60">            state.output.fatal(&quot;ESSelection was handed a Breeder that's not either MuCommaLambdaBreeder or MuCommaPlusLambdaBreeder.&quot;);</span>
<span class="nc" id="L61">        MuCommaLambdaBreeder breeder = (MuCommaLambdaBreeder)(state.breeder);</span>

<span class="nc" id="L63">        breeder.count[thread] = 1;</span>
<span class="nc" id="L64">        }</span>

    public int produce(final int subpopulation,
        final EvolutionState state,
        final int thread)
        {
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (!(state.breeder instanceof MuCommaLambdaBreeder))</span>
<span class="nc" id="L71">            state.output.fatal(&quot;ESSelection was handed a Breeder that's not either MuCommaLambdaBreeder or MuCommaPlusLambdaBreeder.&quot;);</span>
<span class="nc" id="L72">        MuCommaLambdaBreeder breeder = (MuCommaLambdaBreeder)(state.breeder);</span>
        
        // determine my position in the array
<span class="nc bnc" id="L75" title="All 2 branches missed.">        int pos = (breeder.lambda[subpopulation] % state.breedthreads == 0 ? </span>
<span class="nc" id="L76">            breeder.lambda[subpopulation]/state.breedthreads :</span>
<span class="nc" id="L77">            breeder.lambda[subpopulation]/state.breedthreads + 1) * </span>
            thread + breeder.count[thread];  // note integer division
        
        // determine the parent
<span class="nc" id="L81">        int parent = pos / (breeder.lambda[subpopulation] / breeder.mu[subpopulation]); // note outer integer division</span>

        // increment our count
        //breeder.count[thread]++;
        
<span class="nc" id="L86">        return parent;</span>
        }

    public int produceWithoutCloning(final int min,
        final int max,
        final int subpopulation,
        final ArrayList&lt;Individual&gt; inds,
        final EvolutionState state,
        final int thread, HashMap&lt;String, Object&gt; misc)
        {
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (min&gt;1) // uh oh</span>
<span class="nc" id="L97">            state.output.fatal(&quot;ESSelection used, but it's being asked to produce more than one individual.&quot;);</span>
<span class="nc" id="L98">        return super.produceWithoutCloning(min, max, subpopulation, inds, state, thread, misc);</span>
        }


    /*
      public int produce(final int min,
      final int max,
      final int start,
      final int subpopulation,
      final Individual[] inds,
      final EvolutionState state,
      final int thread, HashMap&lt;String, Object&gt; misc)
      {
      if (min&gt;1) // uh oh
      state.output.fatal(&quot;ESSelection used, but it's being asked to produce more than one individual.&quot;);
      if (!(state.breeder instanceof MuCommaLambdaBreeder))
      state.output.fatal(&quot;ESSelection was handed a Breeder that's not either MuCommaLambdaBreeder or MuCommaPlusLambdaBreeder.&quot;);
      MuCommaLambdaBreeder breeder = (MuCommaLambdaBreeder)(state.breeder);
        
      // determine my position in the array
      int pos = (breeder.lambda[subpopulation] % state.breedthreads == 0 ? 
      breeder.lambda[subpopulation]/state.breedthreads :
      breeder.lambda[subpopulation]/state.breedthreads + 1) * 
      thread + breeder.count[thread];  // note integer division
        
      // determine the parent
      int parent = pos / (breeder.lambda[subpopulation] / breeder.mu[subpopulation]); // note outer integer division

      // increment our count
      //breeder.count[thread]++;

      // and so we return the parent
      inds[start] = state.population.subpops.get(subpopulation).individuals.get(parent);

      // and so we return the parent
      return 1;
      }
    */
    }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>